{
    "class": "net.bytebuddy.dynamic.scaffold.MethodGraph",
    "detection": true,
    "justification": "MethodGraph exhibits hub-like modularization: it has a large number of outgoing dependencies (≈24) — e.g. MethodGraph.ForJVMMethod, MethodGraph.ForJavaMethod, MethodGraph.Resolved, MethodGraph.Linked, MethodGraph.Key, MethodGraph.Node, net.bytebuddy.description.method.MethodDescription, net.bytebuddy.description.type.TypeDescription, net.bytebuddy.matcher.ElementMatcher, net.bytebuddy.matcher.FilterableList, net.bytebuddy.build.HashCodeAndEqualsPlugin — and a very large number of incoming dependencies (≈69) from many different abstractions across the system — e.g. net.bytebuddy.dynamic.DynamicType (and its Builder/AbstractBase/Adapter variants), net.bytebuddy.dynamic.scaffold.MethodRegistry (and Prepared/Default), net.bytebuddy.implementation.Implementation (and targets), net.bytebuddy.implementation.MethodDelegation, net.bytebuddy.implementation.MethodCall, net.bytebuddy.asm.Advice, net.bytebuddy.asm.MemberSubstitution, net.bytebuddy.ByteBuddy, various dynamic/scaffold builders and inline/rebase classes. The combination of high in-degree (many clients depend on MethodGraph) and high out-degree (MethodGraph depends on many other abstractions) matches the Hub-like Modularization smell."
}