{
    "class": "net.bytebuddy.implementation.bytecode.assign.Assigner",
    "detection": false,
    "justification": "Assigner has a very large number of incoming dependencies (referenced by dozens of classes across many packages â€” e.g. net.bytebuddy.asm.Advice and many nested Advice types, net.bytebuddy.agent.builder.AgentBuilder and its Transformer/Appender types, net.bytebuddy.implementation.MethodCall/InvokeDynamic and many Implementation helpers, net.bytebuddy.ByteBuddy, net.bytebuddy.build.CachedReturnPlugin, etc.), but only a small set of outgoing dependencies (5 reported: net.bytebuddy.implementation.bytecode.assign.reference.ReferenceTypeAwareAssigner, net.bytebuddy.implementation.bytecode.assign.Assigner.Typing, net.bytebuddy.implementation.bytecode.assign.reference.GenericTypeAwareAssigner, net.bytebuddy.implementation.bytecode.StackManipulation, net.bytebuddy.description.type.TypeDescription). Because hub-like modularization requires an abstraction to have dependencies with a large number of other abstractions in both directions (many incoming AND many outgoing), the Assigner does not meet that criterion (many incoming but few outgoing), so the smell is not detected."
}