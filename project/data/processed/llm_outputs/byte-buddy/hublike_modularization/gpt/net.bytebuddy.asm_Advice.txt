{
    "class": "net.bytebuddy.asm.Advice",
    "detection": true,
    "justification": "The Advice abstraction exhibits hub-like modularization: it has outgoing dependencies on a very large and diverse set of abstractions across many packages (examples: net.bytebuddy.description.annotation.AnnotationDescription, net.bytebuddy.description.type.TypeDefinition / TypeDescription / TypeList, net.bytebuddy.implementation.Implementation, net.bytebuddy.implementation.bytecode.StackManipulation / StackSize / ByteCodeAppender, net.bytebuddy.pool.TypePool, net.bytebuddy.utility.JavaType / JavaConstant / AsmClassReader, net.bytebuddy.dynamic.scaffold.InstrumentedType / MethodGraph / FieldLocator, net.bytebuddy.build.HashCodeAndEqualsPlugin, and many nested Advice.* classes such as Advice.OffsetMapping, Advice.Factory, Advice.Dispatcher, Advice.AdviceMethodWriter, etc.). At the same time multiple disparate clients depend on Advice (incoming references include net.bytebuddy.agent.builder.AgentBuilder and many of its inner types such as AgentBuilder.Transformer, AgentBuilder.ForAdvice, AgentBuilder.Entry, AgentBuilder.ForUnifiedAdvice/ForSplitAdvice, plus build-time plugins like net.bytebuddy.build.CachedReturnPlugin and its AdviceResolver/CacheFieldOffsetMapping, and Advice.Appender). This combination of high fan-out (many outgoing relationships to varied abstractions) and non-trivial fan-in (many unrelated clients referencing Advice) matches the hub-like modularization smell: Advice is a central hub with numerous incoming and outgoing dependencies across the codebase."
}