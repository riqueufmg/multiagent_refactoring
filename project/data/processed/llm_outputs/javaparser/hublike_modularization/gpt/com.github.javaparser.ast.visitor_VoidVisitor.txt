{
    "class": "com.github.javaparser.ast.visitor.VoidVisitor",
    "detection": true,
    "justification": "VoidVisitor participates in a very large number of mutual dependencies: it has outgoing ties to many AST node types and language constructs (examples from the outgoing list: ImportDeclaration, MethodDeclaration, ClassOrInterfaceDeclaration, EnumDeclaration, CompilationUnit, BlockStmt, IfStmt, ForStmt, ReturnStmt, TryStmt, LambdaExpr, MethodCallExpr, FieldAccessExpr, ArrayCreationExpr, AnnotationDeclaration, JavadocComment, TraditionalJavadocComment, ModuleDeclaration, ModuleExportsDirective, RecordDeclaration, RecordPatternExpr) and it is referenced back (incoming) by many of the same kinds of AST types and core classes (examples from the incoming list: CompilationUnit, Node, ImportDeclaration, MethodDeclaration, ClassOrInterfaceDeclaration, FieldDeclaration, EnumDeclaration, Various Type nodes such as ArrayType/UnionType/PrimitiveType/WildcardType, many statement and expression nodes like IfStmt, ForStmt, ReturnStmt, TryStmt, LambdaExpr, MethodCallExpr, FieldAccessExpr, JavadocComment, TraditionalJavadocComment). Because VoidVisitor has both a very large number of outgoing dependencies to other abstractions and a very large number of incoming dependencies from those abstractions (i.e., it is heavily referenced and references many distinct classes across the AST), it matches the Hub-like Modularization smell."
}