{
    "class": "com.github.javaparser.ast.expr.ConditionalExpr",
    "detection": true,
    "justification": "ConditionalExpr shows hub-like modularization: it has a large number of incoming dependencies from many different abstractions (examples: numerous visitor and utility classes such as DefaultVisitorAdapter, TypeExtractor, ConditionalExprContext, TypeInference, ExpressionCompatibleWithType, VoidVisitor, HashCodeVisitor, EqualsVisitor, CloneVisitor, GeneratedJavaParser, PrettyPrintVisitor, DefaultPrettyPrinterVisitor, and many other visitor/solver/printer classes listed under incoming_dependencies). It also has multiple outgoing dependencies to core abstractions (examples: com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.ast.expr.Expression, com.github.javaparser.ast.Node, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.TokenRange, com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.Range, com.github.javaparser.metamodel.ConditionalExprMetaModel). Several of these outgoing dependencies themselves link to large sets of abstractions (see the long dependency lists for VoidVisitor, GenericVisitor, Expression, Node and JavaParserMetaModel in the provided data), increasing the effective coupling. The combination of many distinct incoming references plus multiple outgoing ties (including to highly-connected meta/visitor/core classes) indicates ConditionalExpr functions as a hub and therefore exhibits the Hub-like Modularization smell."
}