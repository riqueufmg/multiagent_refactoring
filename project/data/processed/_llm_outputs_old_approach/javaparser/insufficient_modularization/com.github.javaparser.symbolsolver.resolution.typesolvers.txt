{
  "smell": "Insufficient Modularization",
  "package": "com.github.javaparser.symbolsolver.resolution.typesolvers",
  "detections": [
    {
      "class": "TypeSolverBuilder",
      "detection": true,
      "justification": "Relatively large and complex builder: 14 methods (nom), 156 LOC and WMC 16, 14 public methods (nopm). The class aggregates many construction responsibilities (depends on multiple TypeSolver implementations) suggesting it concentrates creation logic that could be split into smaller, focused builders/factories."
    },
    {
      "class": "AarTypeSolver",
      "detection": false,
      "justification": "Small, focused type solver: 7 methods, 34 LOC and WMC 9. Limited dependencies and a narrow responsibility scope, indicating appropriate modularization."
    },
    {
      "class": "ClassLoaderTypeSolver",
      "detection": false,
      "justification": "Moderate size and responsibilities: 8 methods, 91 LOC and WMC 19. Although it interacts with module/classloading utilities, its method count and LOC are modest and cohesion (LCOM 0.25) does not indicate a clearly bloated abstraction."
    },
    {
      "class": "JavaParserTypeSolver",
      "detection": true,
      "justification": "Large and complex: 20 methods, 232 LOC and high WMC 48, with many dependencies (parser, cache, navigator, facade). The combination of size, complexity and multiple concerns (parsing, caching, navigation) indicates this class likely bundles responsibilities that could be separated into smaller, cohesive components."
    },
    {
      "class": "JarTypeSolver",
      "detection": true,
      "justification": "Substantial size and complexity: 19 methods, 247 LOC and WMC 39, several responsibilities (JAR handling, integration with Javassist, resolution). The high LOC and method count imply a bloated abstraction that could be decomposed (e.g., I/O/parsing, resolution, integration helpers)."
    },
    {
      "class": "MemoryTypeSolver",
      "detection": false,
      "justification": "Small and focused in-memory resolver: 8 methods, 48 LOC and WMC 14. Scope appears limited to a single responsibility (in-memory type resolution), so modularization is acceptable."
    },
    {
      "class": "CombinedTypeSolver",
      "detection": true,
      "justification": "Combines many solvers and responsibilities: 15 methods, 214 LOC and WMC 29, multiple dependencies and an inner ExceptionHandlers class. The class coordinates diverse behaviors (combining, caching, exception handling) suggesting it centralizes functionality that could be split into coordinator, cache, and handler classes to improve modularity."
    },
    {
      "class": "CombinedTypeSolver.ExceptionHandlers",
      "detection": false,
      "justification": "Small inner utility: 0 methods (nom), 63 LOC, implemented as a focused collection of handlers. Its limited scope and role as a helper/organizational unit make it appropriately modular for its purpose."
    },
    {
      "class": "ReflectionTypeSolver",
      "detection": false,
      "justification": "Focused reflection-based solver: 4 methods, 50 LOC and WMC 5, single clear responsibility interacting with reflection utilities. Metrics do not indicate an oversized or multi-responsibility class."
    }
  ]
}