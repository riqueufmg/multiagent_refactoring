{
  "smell": "Insufficient Modularization",
  "package": "com.github.javaparser.ast.visitor",
  "detections": [
    {
      "class": "Visitable",
      "detection": false,
      "justification": "Very small abstraction (loc=18, nom=2, wmc=2). Acts as a lightweight interface/marker used by visitors; not a bloated, multi-responsibility class."
    },
    {
      "class": "VoidVisitor",
      "detection": false,
      "justification": "Interface-like visitor with many visit signatures (nom=103, loc=109, wmc=103) intended to cover many node types. High method count is by design for the visitor abstraction, not a consequence of poor decomposition."
    },
    {
      "class": "HashCodeVisitor",
      "detection": false,
      "justification": "Moderate size specialized utility (loc=324, nom=105, wmc=106) with high cohesion (lcom=1.0). Focused on a single responsibility (hash code computation) rather than multiple unrelated responsibilities."
    },
    {
      "class": "VoidVisitorWithDefaults",
      "detection": false,
      "justification": "Provides default implementations (loc=324, nom=105, wmc=105). Its size stems from supplying defaults for many visit methods; it is a focused adaptor rather than a multipurpose class."
    },
    {
      "class": "GenericVisitor",
      "detection": false,
      "justification": "Interface-style abstraction with many method signatures (nom=103, loc=109, wmc=103). High method count corresponds to the visitor contract for many node types, not necessarily insufficient modularization."
    },
    {
      "class": "ModifierVisitor",
      "detection": true,
      "justification": "Large concrete visitor with many methods and behaviors (loc=1049, nom=105, wmc=178). Size and complexity indicate multiple responsibilities implemented in a single class (few children nc=3), suggesting it could be decomposed into smaller, more focused visitors/adapters."
    },
    {
      "class": "GenericListVisitorAdapter",
      "detection": true,
      "justification": "Very large adapter (loc=1803, nom=103, wmc=561) with extremely high complexity. The class implements many visit behaviors in one place, which signals a bloated abstraction that would benefit from modularization into smaller, focused components."
    },
    {
      "class": "ObjectIdentityEqualsVisitor",
      "detection": false,
      "justification": "Relatively compact concrete equals implementation (loc=319, nom=104, wmc=104) with high cohesion (lcom=1.0). Serves a specific equality strategy (object identity), so the method count is appropriate to its single responsibility."
    },
    {
      "class": "ObjectIdentityHashCodeVisitor",
      "detection": false,
      "justification": "Focused hash-code implementation (loc=318, nom=104, wmc=104) with cohesive metrics (lcom=1.0). Its size comes from handling many node types but with a single, well-defined responsibility."
    },
    {
      "class": "EqualsVisitor",
      "detection": true,
      "justification": "Large and complex equality implementation (loc=848, nom=112, wmc=481). Although somewhat cohesive (lcom=0.723), its high LOC and very high complexity indicate concentrated responsibilities that may be split (e.g., by node family or equality strategy) to improve modularity."
    },
    {
      "class": "TreeVisitor",
      "detection": false,
      "justification": "Small utility visitor (loc=55, nom=6, wmc=9). Size and responsibilities are limited; no indication of a bloated abstraction."
    },
    {
      "class": "GenericVisitorAdapter",
      "detection": true,
      "justification": "Very large adapter (loc=1707, nom=103, wmc=563). High size and complexity indicate many responsibilities concentrated in one class; suitable candidate for decomposition into smaller adapters or delegating handlers per node groups."
    },
    {
      "class": "NoCommentEqualsVisitor",
      "detection": true,
      "justification": "Substantial concrete visitor (loc=702, nom=109, wmc=366) with many methods. The combination of high LOC and high complexity suggests multiple responsibilities implemented together (despite moderate cohesion), so modularization could improve maintainability."
    },
    {
      "class": "CloneVisitor",
      "detection": true,
      "justification": "Large cloning visitor (loc=1082, nom=107, wmc=115). Its substantial LOC and numerous visit methods imply a broad responsibility surface; splitting cloning logic by node categories or using helper delegates would reduce class bloat."
    },
    {
      "class": "VoidVisitorAdapter",
      "detection": false,
      "justification": "Adapter providing default void-visitor behavior (loc=536, nom=103, wmc=104). While sizable, it is a coherent adaptor pattern intended to implement many visit hooks; its size is justified by that role rather than mixed responsibilities."
    },
    {
      "class": "GenericVisitorWithDefaults",
      "detection": false,
      "justification": "Provides default generic-visitor implementations (loc=326, nom=105, wmc=105). Acts as a single-purpose convenience class; method count reflects the visitor API rather than poor modularization."
    },
    {
      "class": "NoCommentHashCodeVisitor",
      "detection": false,
      "justification": "Focused hash-code visitor ignoring comments (loc=319, nom=104, wmc=105) with high cohesion (lcom=1.0). The class implements a single concern (hash code calculation without comments), so it is not a modularization smell."
    },
    {
      "class": "NodeFinderVisitor",
      "detection": true,
      "justification": "Extremely large and complex (loc=1868, nom=102, wmc=648) with very low cohesion (lcom=0.0196). These metrics strongly indicate a class that aggregates many unrelated responsibilities (searching/finding across many node types) and should be decomposed into smaller, more cohesive visitors or query objects."
    }
  ]
}