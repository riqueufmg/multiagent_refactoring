[
    {
        "identifier": "(default package).InnerClassContainer.InnerInnerClass",
        "detection": false,
        "justification": "Both incoming_dependencies and outgoing_dependencies are empty (0 incoming, 0 outgoing). Hub-like Modularization requires an abstraction to have many incoming and outgoing dependencies; this class has none, so the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.JavadocParser",
        "detection": false,
        "justification": "JavadocParser has a limited set of outgoing dependencies (6): com.github.javaparser.javadoc.Javadoc, com.github.javaparser.javadoc.JavadocBlockTag, com.github.javaparser.ast.comments.JavadocComment, com.github.javaparser.utils.LineSeparator, com.github.javaparser.javadoc.description.JavadocDescription, com.github.javaparser.utils.Utils. It has only two incoming dependents in the provided data: com.github.javaparser.StaticJavaParser and com.github.javaparser.JavaParserAdapter. The number of incoming and outgoing relationships is not large, and the outgoing dependencies are cohesive (all related to Javadoc functionality), so the class does not exhibit a hub-like modularization smell under the given data."
    },
    {
        "identifier": "com.github.javaparser.resolution.logic.MethodResolutionLogic",
        "detection": true,
        "justification": "MethodResolutionLogic has a large number of both outgoing and incoming couplings. Outgoing: 19 distinct dependencies (e.g. com.github.javaparser.resolution.types.ResolvedReferenceType, com.github.javaparser.resolution.declarations.ResolvedParameterDeclaration, com.github.javaparser.resolution.TypeSolver, com.github.javaparser.resolution.MethodUsage, com.github.javaparser.resolution.logic.FunctionalInterfaceLogic, com.github.javaparser.resolution.types.ResolvedType, com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration, com.github.javaparser.resolution.model.LambdaArgumentTypePlaceholder, com.github.javaparser.resolution.types.ResolvedArrayType, etc.). Incoming: many clients (at least 12) depend on it (e.g. ReflectionClassDeclaration, ReflectionRecordDeclaration, ReflectionMethodResolutionLogic, JavaParserFacade, TypeExtractor, several Javaparser model contexts like LambdaExprContext, MethodReferenceExprContext, MethodCallExprContext, CompilationUnitContext, JavaParserTypeDeclarationAdapter, JavassistUtils, ConstructorResolutionLogic). The class therefore acts as a central hub with numerous incoming and outgoing relationships across multiple packages and abstractions, matching the Hub-like Modularization smell."
    },
    {
        "identifier": "com.github.javaparser.javadoc.description.JavadocInlineTag",
        "detection": false,
        "justification": "Incoming dependencies: 2 classes (JavadocInlineTag.Type, JavadocDescription). Outgoing dependencies: 3 classes (JavadocInlineTag.Type, JavadocDescriptionElement, com.github.javaparser.utils.Utils). One dependency is bidirectional with the nested Type (Type -> JavadocInlineTag and JavadocInlineTag -> Type). The total number of distinct incoming and outgoing partners is small (2 incoming, 3 outgoing) and does not indicate a hub-like level of coupling."
    },
    {
        "identifier": "package_a.a",
        "detection": false,
        "justification": "The class has 0 incoming dependencies and 0 outgoing dependencies (incoming_dependencies: [], outgoing_dependencies: []), so it does not have dependencies with a large number of other abstractions and therefore is not a hub-like module."
    },
    {
        "identifier": "com.github.javaparser.javasymbolsolver.javassist_symbols.main_jar.StandaloneInterface",
        "detection": false,
        "justification": "Hub-like Modularization requires an abstraction to have many incoming and outgoing dependencies. This class has 0 incoming dependencies and 0 outgoing dependencies (both dependency lists are empty), so it does not exhibit hub-like modularization."
    },
    {
        "identifier": "com.github.javaparser.utils.Log.Adapter",
        "detection": false,
        "justification": "Not detected: the class has 0 outgoing dependencies and only 1 incoming dependency (from com.github.javaparser.utils.Log). Hub-like Modularization requires an abstraction to have many incoming and outgoing dependencies; this class does not exhibit that."
    },
    {
        "identifier": "com.github.javaparser.ast.nodeTypes.NodeWithParameters",
        "detection": false,
        "justification": "Not a hub: NodeWithParameters has outgoing dependencies to 4 other abstractions (com.github.javaparser.StaticJavaParser, com.github.javaparser.ast.type.Type, com.github.javaparser.ast.body.Parameter, com.github.javaparser.ast.NodeList) but has zero incoming dependencies. Hub-like Modularization requires an abstraction to have both many incoming and many outgoing dependencies; the absence of incoming dependencies means this class does not meet the smell criteria."
    },
    {
        "identifier": "com.github.javaparser.CommentsInserter",
        "detection": false,
        "justification": "CommentsInserter has 7 outgoing dependencies (com.github.javaparser.ParserConfiguration, com.github.javaparser.utils.PositionUtils, com.github.javaparser.ast.CompilationUnit, com.github.javaparser.ast.comments.LineComment, com.github.javaparser.ast.Node, com.github.javaparser.Range, com.github.javaparser.ast.comments.Comment) and only 1 incoming dependency (referenced by com.github.javaparser.JavaParser). The class does not exhibit dependencies with a large number of other abstractions on both incoming and outgoing sides, so it does not qualify as hub-like modularization."
    },
    {
        "identifier": "com.github.javaparser.TokenBase",
        "detection": false,
        "justification": "TokenBase has 0 incoming dependencies and only 1 outgoing dependency (com.github.javaparser.JavaToken). Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; these counts do not meet that criterion."
    },
    {
        "identifier": "com.github.javaparser.ast.expr.FieldAccessExpr",
        "detection": true,
        "justification": "FieldAccessExpr has a large number of outgoing dependencies (13): NameExpr, VoidVisitor, FieldAccessExprMetaModel, Range, Expression, NodeList, ResolvedValueDeclaration, SimpleName, TokenRange, ObservableProperty, JavaParserMetaModel, Node, GenericVisitor. It also has many incoming dependencies (27) from a wide variety of other abstractions, notably many visitor implementations and utilities (e.g., VoidVisitor, GenericVisitor, HashCodeVisitor, EqualsVisitor, PrettyPrintVisitor, DefaultPrettyPrinterVisitor, VoidVisitorAdapter, GenericVisitorAdapter, CloneVisitor, NodeFinderVisitor) and symbol-solver / parser components (e.g., JavaParserFacade, TypeExtractor, FieldAccessContext, AbstractJavaParserContext, NameLogic, GeneratedJavaParser, GeneratedJavaParserBase). The presence of many incoming clients combined with many outgoing links to core AST, meta-model, visitor and resolution types indicates FieldAccessExpr acts as a central hub, satisfying the Hub-like Modularization smell."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserTypeParameter",
        "detection": false,
        "justification": "Hub-like Modularization requires an abstraction to have dependencies in both directions (many incoming and many outgoing). JavaParserTypeParameter has 19 outgoing dependencies (e.g. com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration, com.github.javaparser.resolution.TypeSolver, com.github.javaparser.resolution.Navigator, com.github.javaparser.resolution.types.ResolvedReferenceType, com.github.javaparser.resolution.model.SymbolReference, com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade, com.github.javaparser.resolution.types.ResolvedType, com.github.javaparser.ast.type.Type, com.github.javaparser.ast.Node, com.github.javaparser.ast.type.TypeParameter, com.github.javaparser.ast.body.ClassOrInterfaceDeclaration, com.github.javaparser.ast.body.ConstructorDeclaration, com.github.javaparser.ast.body.RecordDeclaration, com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration, com.github.javaparser.ast.type.ClassOrInterfaceType), but it has 0 incoming dependencies. Because it lacks incoming dependencies, it does not meet the bidirectional connectivity requirement for a hub and therefore is not classified as Hub-like Modularization."
    },
    {
        "identifier": "(default package).HelloWorld",
        "detection": false,
        "justification": "The class has no incoming or outgoing dependencies: analyzed_package.dependencies = [], outgoing_dependencies = [], incoming_dependencies = []. Hub-like modularization requires a large number of both incoming and outgoing relationships; with 0 incoming and 0 outgoing dependencies the smell is not present."
    },
    {
        "identifier": "com.github.javaparser.resolution.declarations.ResolvedAnnotationMemberDeclaration",
        "detection": false,
        "justification": "ResolvedAnnotationMemberDeclaration has only 1 outgoing dependency (com.github.javaparser.ast.expr.Expression) and only 2 incoming dependencies (com.github.javaparser.symbolsolver.JavaSymbolSolver and com.github.javaparser.ast.body.AnnotationMemberDeclaration). A Hub-like Modularization would show a large number of both incoming and outgoing relationships; the provided data shows low fan-in and fan-out for this class (incoming=2, outgoing=1), so the smell is not detected. Note: Expression itself has many dependencies, but the analysis considers the class in isolation and the class does not directly depend on a large set of other abstractions."
    },
    {
        "identifier": "com.github.javaparser.javasymbolsolver.javassist_symbols.main_jar.SubClassOwnJar",
        "detection": false,
        "justification": "The class has 0 outgoing dependencies and 0 incoming dependencies. Hub-like Modularization requires an abstraction to have dependencies (both incoming and outgoing) with a large number of other abstractions; with no incoming or outgoing links this class does not meet that condition."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.declarations.common.MethodDeclarationCommonLogic",
        "detection": false,
        "justification": "Not detected: Hub-like Modularization requires the abstraction to have a large number of both incoming and outgoing dependencies. This class has 0 incoming dependencies and 8 outgoing dependencies (com.github.javaparser.resolution.Context, com.github.javaparser.resolution.MethodUsage, com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration, com.github.javaparser.resolution.declarations.ResolvedParameterDeclaration, com.github.javaparser.resolution.types.ResolvedType, com.github.javaparser.resolution.TypeSolver, com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration, com.github.javaparser.resolution.logic.InferenceContext). The absence of incoming dependencies means it does not act as a hub per the given definition."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.resolution.promotion.ReferenceConditionalExprHandler",
        "detection": false,
        "justification": "ReferenceConditionalExprHandler has 0 incoming dependencies and only 2 outgoing dependencies (com.github.javaparser.symbolsolver.resolution.typeinference.TypeHelper and com.github.javaparser.resolution.types.ResolvedType). Hub-like Modularization requires an abstraction to have dependencies (both incoming and outgoing) with a large number of other abstractions. Although the outgoing TypeHelper and ResolvedType types themselves reference many classes, the analyzed class in isolation does not exhibit a large number of incoming or outgoing relationships, so it is not a hub."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.cache.InMemoryCache",
        "detection": false,
        "justification": "Not detected: the class has a very small number of dependencies. Outgoing dependencies: 1 (com.github.javaparser.resolution.cache.CacheStats). Incoming dependencies: 1 (com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver). Hub-like Modularization requires many incoming and outgoing relationships; the provided data shows low fan-in and fan-out."
    },
    {
        "identifier": "com.github.javaparser.metamodel.NodeMetaModel",
        "detection": false,
        "justification": "NodeMetaModel has multiple incoming dependencies (6 distinct dependents: com.github.javaparser.ast.Node, com.github.javaparser.ast.validator.language_level_validations.chunks.CommonValidators, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.printer.XmlPrinter, com.github.javaparser.printer.DotPrinter, com.github.javaparser.printer.YamlPrinter) but only a single outgoing dependency (com.github.javaparser.metamodel.PropertyMetaModel). Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; here the outgoing degree is very low (1), so NodeMetaModel is not a hub by this definition."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.contexts.ArrayAccessExprContext",
        "detection": false,
        "justification": "Not a hub: Hub-like modularization requires an abstraction to have many incoming and outgoing dependencies. This class has zero incoming dependencies (incoming_dependencies = []) and only three direct outgoing dependencies: com.github.javaparser.resolution.model.SymbolReference, com.github.javaparser.resolution.TypeSolver, and com.github.javaparser.ast.expr.ArrayAccessExpr. Although those outgoing classes themselves reference other types, the analyzed class lacks the large number of both incoming and outgoing links required to be considered a hub."
    },
    {
        "identifier": "com.github.javaparser.ast.comments.Comment",
        "detection": true,
        "justification": "The class has a large number of both incoming and outgoing dependencies: 11 outgoing dependencies (TraditionalJavadocComment, CommentMetaModel, JavadocComment, BlockComment, TokenRange, ObservableProperty, LineComment, JavaParserMetaModel, Node, MarkdownComment, Range) and 16 incoming dependents (including core/system classes such as com.github.javaparser.ast.Node, com.github.javaparser.JavaParser, com.github.javaparser.printer.PrettyPrintVisitor, com.github.javaparser.printer.lexicalpreservation.LexicalPreservingPrinter, GeneratedJavaParserTokenManager). Being referenced by central/core abstractions (Node, JavaParser, lexical-preserving printer, token manager) while itself depending on many comment variants, meta-models and node/token range types indicates it functions as a hub with numerous incoming and outgoing connections — matching the Hub-like Modularization smell."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javassistmodel.JavassistConstructorDeclaration",
        "detection": false,
        "justification": "JavassistConstructorDeclaration has outgoing dependencies to 7 other abstractions (AccessSpecifier; ResolvedParameterDeclaration; JavassistMethodLikeDeclarationAdapter; ResolvedType; TypeSolver; JavassistFactory; ResolvedReferenceTypeDeclaration) but has zero incoming dependencies. Hub-like Modularization requires an abstraction to have both many incoming and many outgoing dependencies; the absence of incoming dependencies means this class is not a hub."
    },
    {
        "identifier": "a.b.c.ExampleClass",
        "detection": false,
        "justification": "Hub-like Modularization requires an abstraction to have dependencies (both incoming and outgoing) with a large number of other abstractions. ExampleClass has 2 outgoing dependencies (a.b.c.DataObjectFactory, a.b.c.DataObject) and 0 incoming dependencies. The absence of incoming dependencies and the small number of outgoing dependencies indicate it is not a hub."
    },
    {
        "identifier": "com.github.javaparser.metamodel.LongLiteralExprMetaModel",
        "detection": false,
        "justification": "LongLiteralExprMetaModel has no outgoing dependencies (empty outgoing_dependencies) and only two incoming dependencies: com.github.javaparser.ast.expr.LongLiteralExpr and com.github.javaparser.metamodel.JavaParserMetaModel. Although JavaParserMetaModel references many meta-model classes, LongLiteralExprMetaModel itself is directly connected to only these two classes, so it does not exhibit hub-like modularization (not a high number of both incoming and outgoing dependencies)."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserAnnotationDeclaration",
        "detection": false,
        "justification": "Outgoing dependencies exist (6): com.github.javaparser.ast.body.AnnotationDeclaration, com.github.javaparser.symbolsolver.javaparsermodel.declarations.AstResolutionUtils, com.github.javaparser.resolution.types.ResolvedType, com.github.javaparser.resolution.TypeSolver, com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration, com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserTypeAdapter. Incoming dependencies: 0. Hub-like Modularization requires the abstraction to have many both incoming and outgoing dependencies; this class has no incoming dependencies, so it is not a hub."
    },
    {
        "identifier": "com.github.javaparser.ast.type.WildcardType",
        "detection": true,
        "justification": "WildcardType has a large number of both outgoing and incoming dependencies. Outgoing: 13 distinct abstractions (examples: com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.resolution.Context, com.github.javaparser.resolution.types.ResolvedType, com.github.javaparser.Range, com.github.javaparser.ast.NodeList, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.TokenRange, com.github.javaparser.ast.type.ReferenceType, com.github.javaparser.metamodel.WildcardTypeMetaModel, com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.ast.Node, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.resolution.types.ResolvedWildcard). Incoming: 22 distinct abstractions depend on WildcardType (examples include DefaultVisitorAdapter, JavaParserFacade, com.github.javaparser.ast.type.Type, multiple visitor implementations such as VoidVisitor, GenericVisitor, ModifierVisitor, CloneVisitor, HashCodeVisitor, EqualsVisitor, PrettyPrintVisitor, GeneratedJavaParser, DefaultPrettyPrinterVisitor, and several other visitor/adapter classes). The presence of many incoming links from diverse visitors/parsers and many outgoing links to core meta/model/resolution/AST classes indicates WildcardType functions as a hub-like abstraction (many-to-many coupling), satisfying the Hub-like Modularization smell."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.contexts.FieldAccessContext",
        "detection": false,
        "justification": "Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies. FieldAccessContext has many outgoing dependencies (12 distinct targets including com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade, com.github.javaparser.resolution.types.ResolvedType, com.github.javaparser.ast.expr.Expression, com.github.javaparser.ast.expr.FieldAccessExpr, com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFactory, com.github.javaparser.resolution.Navigator, com.github.javaparser.resolution.TypeSolver, com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration, com.github.javaparser.resolution.declarations.ResolvedEnumDeclaration, com.github.javaparser.resolution.types.ResolvedPrimitiveType, com.github.javaparser.resolution.model.SymbolReference, com.github.javaparser.resolution.types.ResolvedReferenceType) but has zero incoming dependencies in the provided data. Because there are no incoming dependencies, the class does not meet the definition of a hub (requires many incoming and outgoing links)."
    },
    {
        "identifier": "com.github.javaparser.metamodel.SuperExprMetaModel",
        "detection": false,
        "justification": "SuperExprMetaModel has a single outgoing dependency (com.github.javaparser.metamodel.PropertyMetaModel) and only two incoming dependencies in the provided data (com.github.javaparser.ast.expr.SuperExpr and com.github.javaparser.metamodel.JavaParserMetaModel). This yields three distinct adjacency links in total. A hub-like modularization requires an abstraction to have incoming and outgoing dependencies with a large number of other abstractions; the observed number of connections is small, so the smell is not present."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.resolution.typeinference.LeastUpperBoundLogic",
        "detection": false,
        "justification": "LeastUpperBoundLogic has 7 outgoing dependencies (ResolvedTypeParameterDeclaration, ResolvedType, ResolvedReferenceTypeDeclaration, TypeHelper, LeastUpperBoundLogic.TypeSubstitution, ResolvedWildcard, ResolvedReferenceType) and 3 incoming dependents (TypeExtractor, MethodCallExprContext, TypeHelper). Although it interacts with several types, the number of incoming dependents is small and the outgoing dependencies are limited to a focused set of type- and inference-related abstractions. Therefore it does not exhibit the characteristic many-to-many incoming and outgoing connectivity required for a hub-like modularization smell."
    },
    {
        "identifier": "com.github.javaparser.ast.validator.language_level_validations.Java5Validator",
        "detection": false,
        "justification": "Java5Validator has 0 incoming dependencies and only 2 direct outgoing dependencies (com.github.javaparser.ast.validator.Validator and com.github.javaparser.ParserConfiguration). Hub-like Modularization requires an abstraction to have both many incoming and many outgoing relationships; in isolation this class does not exhibit a large number of incoming or outgoing connections. Although the two outgoing targets themselves list multiple dependencies, the class under analysis only directly depends on two abstractions, so it is not a hub."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.reflectionmodel.ReflectionFactory",
        "detection": true,
        "justification": "ReflectionFactory has a large number of outgoing dependencies (11 distinct types: e.g. AccessSpecifier, ResolvedTypeParameterDeclaration, ResolvedType, AbstractTypeDeclaration, ReflectionTypeParameter, TypeSolver, ResolvedPrimitiveType, ResolvedReferenceTypeDeclaration, ResolvedVoidType, ResolvedWildcard, ResolvedReferenceType) and many incoming dependents (15 distinct classes reference it: e.g. ReflectionMethodDeclaration, ReflectionClassDeclaration, ReflectionAnnotationDeclaration, ReflectionParameterDeclaration, ReflectionEnumDeclaration, ReflectionRecordDeclaration, ReflectionTypeParameter, ReflectionClassAdapter, ReflectionInterfaceDeclaration, ReflectionConstructorDeclaration, ReflectionFieldDeclaration, JavaParserEnumDeclaration, ClassLoaderTypeSolver, ReflectionTypeSolver, ReflectionPatternDeclaration). These connections span multiple packages (symbolsolver.reflectionmodel, resolution.types, resolution.declarations, javaparsermodel, resolution.typesolvers, etc.), indicating the class both depends on and is depended upon by a large number of other abstractions. This pattern matches the Hub-like Modularization smell."
    },
    {
        "identifier": "japa.bdd.samples.JavaConcepts.A",
        "detection": false,
        "justification": "Outgoing dependencies: [] (no outgoing dependencies). Incoming dependencies: 1 entry (japa.bdd.samples.JavaConcepts) which lists dependencies [com.github.javaparser.ast.CompilationUnit, japa.bdd.samples.JavaConcepts.A, japa.bdd.samples.JavaConcepts.QWE]. With only one incoming relation and zero outgoing relations, the class does not have dependencies with a large number of other abstractions and therefore is not a hub-like module."
    },
    {
        "identifier": "com.github.javaparser.ast.validator.language_level_validations.Java16Validator",
        "detection": false,
        "justification": "The class has 0 incoming dependencies and 0 outgoing dependencies (both dependency lists are empty). Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; this class does not meet that condition."
    },
    {
        "identifier": "(default package).FieldDotExpressions.InnerClass",
        "detection": false,
        "justification": "No hub detected: incoming_dependencies = 0 and outgoing_dependencies = 0 (both lists are empty), so the class has no dependencies with other abstractions and therefore does not exhibit hub-like modularization."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.contexts.LambdaExprContext",
        "detection": false,
        "justification": "LambdaExprContext has a large set of outgoing dependencies (22 listed) including com.github.javaparser.resolution.TypeSolver, com.github.javaparser.ast.expr.Expression, com.github.javaparser.resolution.Navigator, com.github.javaparser.resolution.logic.MethodResolutionLogic, com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade, com.github.javaparser.symbolsolver.javaparsermodel.contexts.AbstractJavaParserContext, com.github.javaparser.resolution.types.ResolvedType, com.github.javaparser.ast.expr.LambdaExpr, com.github.javaparser.resolution.logic.FunctionalInterfaceLogic, com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFactory, com.github.javaparser.ast.expr.MethodCallExpr, com.github.javaparser.ast.expr.CastExpr, etc. However, it has no incoming dependencies (incoming_dependencies is empty). Because Hub-like Modularization requires an abstraction to have many incoming and many outgoing connections, the absence of incoming dependencies means LambdaExprContext is not a hub. Therefore detection = false."
    },
    {
        "identifier": "com.github.javaparser.ast.validator.postprocessors.Java17PostProcessor",
        "detection": false,
        "justification": "incoming_dependencies = 0, outgoing_dependencies = 0 (both dependency lists are empty). Hub-like Modularization requires many incoming and outgoing dependencies; this class has none."
    },
    {
        "identifier": "com.github.javaparser.utils.VisitorMap.EqualsHashcodeOverridingFacade",
        "detection": false,
        "justification": "The class has 0 incoming dependencies and 1 outgoing dependency (to com.github.javaparser.utils.VisitorMap). Hub-like Modularization requires an abstraction to have many incoming and outgoing dependencies; the provided data shows low fan-in and fan-out, so the smell is not present."
    },
    {
        "identifier": "com.github.javaparser.metamodel.ModuleUsesDirectiveMetaModel",
        "detection": false,
        "justification": "ModuleUsesDirectiveMetaModel has only 1 outgoing dependency (to com.github.javaparser.metamodel.PropertyMetaModel) and 2 incoming dependencies (from com.github.javaparser.ast.modules.ModuleUsesDirective and com.github.javaparser.metamodel.JavaParserMetaModel). These counts are small and do not show dependencies with a large number of other abstractions in either direction, so it does not qualify as a hub-like module."
    },
    {
        "identifier": "com.github.javaparser.ast.visitor.EqualsVisitor",
        "detection": false,
        "justification": "EqualsVisitor has a very large outgoing fan-out: it depends on many AST classes (examples include com.github.javaparser.ast.comments.TraditionalJavadocComment, com.github.javaparser.ast.type.WildcardType, com.github.javaparser.ast.expr.UnaryExpr, com.github.javaparser.ast.expr.TextBlockLiteralExpr, com.github.javaparser.ast.modules.ModuleDeclaration, com.github.javaparser.ast.body.MethodDeclaration, com.github.javaparser.ast.body.ClassOrInterfaceDeclaration, com.github.javaparser.ast.CompilationUnit, com.github.javaparser.ast.Node, etc.). However, its incoming fan-in is minimal: only com.github.javaparser.ast.Node is listed as depending on EqualsVisitor. The hub-like modularization smell requires an abstraction to have many incoming and many outgoing dependencies; because EqualsVisitor has many outgoing but only a single incoming dependency in the provided data, it does not meet the full criteria for a hub."
    },
    {
        "identifier": "com.github.javaparser.LineEndingProcessingProvider",
        "detection": false,
        "justification": "LineEndingProcessingProvider has only 2 outgoing dependencies (com.github.javaparser.Provider, com.github.javaparser.utils.LineSeparator) and only 2 incoming dependents (com.github.javaparser.ParserConfiguration and com.github.javaparser.ParserConfiguration.LineEndingProcessor). The number of incoming and outgoing relationships is small, so it does not exhibit a hub-like modularization (no large number of both incoming and outgoing dependencies)."
    },
    {
        "identifier": "issue1945.implementations.HairTypeWool",
        "detection": false,
        "justification": "HairTypeWool has only a single outgoing dependency (issue1945.implementations.WoolRenderer) and a single incoming dependency from the same class (WoolRenderer). It interacts with one other abstraction, not a large number of other abstractions required to qualify as Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.printer.concretesyntaxmodel.CsmToken",
        "detection": true,
        "justification": "CsmToken has many outgoing and incoming ties: outgoing dependencies to 6 distinct abstractions (com.github.javaparser.TokenTypes, com.github.javaparser.GeneratedJavaParserConstants, com.github.javaparser.ast.Node, com.github.javaparser.utils.LineSeparator, com.github.javaparser.printer.SourcePrinter, com.github.javaparser.printer.lexicalpreservation.TextElement) and is referenced by 5 distinct classes (com.github.javaparser.printer.lexicalpreservation.Kept, DifferenceElementCalculator, LexicalPreservingPrinter, Removed, RemovedGroup). These connections span multiple packages (core parser types, AST, printer, lexicalpreservation) and include shared/common types (e.g., TokenTypes, Node, LineSeparator) between CsmToken and its clients, indicating the class functions as a central hub linking many abstractions. The breadth of both incoming and outgoing dependencies meets the definition of Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.storage.PrimaryType",
        "detection": false,
        "justification": "The class has 0 incoming dependencies and 0 outgoing dependencies (incoming_dependencies = [], outgoing_dependencies = []), so it does not have dependencies with a large number of other abstractions and therefore does not exhibit Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.ast.modules.ModuleUsesDirective",
        "detection": true,
        "justification": "ModuleUsesDirective exhibits hub-like modularization: it has many incoming dependencies (21 distinct callers in the provided data) including numerous visitor and printer classes such as DefaultVisitorAdapter, VoidVisitor, HashCodeVisitor, VoidVisitorWithDefaults, GenericVisitor, ModifierVisitor, GeneratedJavaParser, PrettyPrintVisitor and DefaultPrettyPrinterVisitor, as well as ModuleDirective. At the same time it has outgoing dependencies to multiple core abstractions (8 listed): com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.expr.Name, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.TokenRange, com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.ast.Node, com.github.javaparser.ast.visitor.GenericVisitor, and com.github.javaparser.metamodel.ModuleUsesDirectiveMetaModel. The combination of a large number of incoming clients and a nontrivial set of outgoing dependencies matches the hub-like modularization smell."
    },
    {
        "identifier": "demo.Main",
        "detection": false,
        "justification": "Hub-like Modularization requires an abstraction to have both a large number of incoming and outgoing dependencies. demo.Main has 0 incoming dependencies (incoming_dependencies is empty) and only 4 outgoing dependencies (com.github.javaparser.utils.ParserCollectionStrategy, com.github.javaparser.utils.ProjectRoot, demo.Main.Callback, com.github.javaparser.utils.SourceRoot). Because there are no incoming dependencies and the outgoing set is small, demo.Main does not meet the hub-like criteria."
    },
    {
        "identifier": "com.github.javaparser.ast.validator.postprocessors.Java20PostProcessor",
        "detection": false,
        "justification": "The class has 0 incoming dependencies and 0 outgoing dependencies (incoming_dependencies: [], outgoing_dependencies: []). Hub-like Modularization requires an abstraction to have dependencies with a large number of other abstractions; this class has none, so the smell is not present."
    },
    {
        "identifier": "com.github.javaparser.GeneratedJavaParser.LookaheadSuccess",
        "detection": false,
        "justification": "The class has 0 outgoing dependencies and only 1 incoming dependency (from com.github.javaparser.GeneratedJavaParser). Hub-like Modularization requires an abstraction to have both many incoming and many outgoing dependencies. Here LookaheadSuccess lacks outgoing dependencies and has a single incoming reference, so it does not meet the hub-like criteria."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.resolution.naming.NameCategory",
        "detection": false,
        "justification": "NameCategory has 0 outgoing dependencies and only 1 incoming dependency (from com.github.javaparser.symbolsolver.resolution.naming.NameLogic). Hub-like Modularization requires an abstraction to have incoming and/or outgoing relationships with a large number of other abstractions; here incoming_count = 1 and outgoing_count = 0, so NameCategory is not a hub. (Although NameLogic references many types, that does not make NameCategory itself have many incoming/outgoing dependencies in isolation.)"
    },
    {
        "identifier": "com.github.javaparser.TokenTypes",
        "detection": false,
        "justification": "TokenTypes is referenced by many other classes (incoming references from: JavaToken; GeneratedJavaParserTokenManagerBase; GeneratedJavaParserTokenManager; com.github.javaparser.printer.concretesyntaxmodel.CsmToken; com.github.javaparser.printer.concretesyntaxmodel.CsmElement; com.github.javaparser.printer.lexicalpreservation.Kept; com.github.javaparser.printer.lexicalpreservation.LexicalPreservingPrinter; com.github.javaparser.printer.lexicalpreservation.Difference; com.github.javaparser.printer.lexicalpreservation.RemovedGroup — 9 incoming callers), but it has only two outgoing dependencies (JavaToken and com.github.javaparser.utils.LineSeparator). The Hub-like Modularization smell requires an abstraction to have a large number of dependencies in both directions; here the incoming degree is high but the outgoing degree is low, so the class does not meet the definition of a hub-like module."
    },
    {
        "identifier": "com.github.javaparser.serialization.JavaParserJsonSerializer",
        "detection": false,
        "justification": "The class has many outgoing dependencies (11 distinct types: com.github.javaparser.metamodel.BaseNodeMetaModel, com.github.javaparser.serialization.JavaParserJsonSerializer.JsonRange, com.github.javaparser.serialization.JavaParserJsonSerializer.JsonToken, com.github.javaparser.TokenRange, com.github.javaparser.ast.Node, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.ast.NodeList, com.github.javaparser.serialization.JavaParserJsonSerializer.JsonTokenRange, com.github.javaparser.Range, com.github.javaparser.serialization.JavaParserJsonSerializer.JsonNode, com.github.javaparser.JavaToken) but has zero incoming dependencies. Hub-like Modularization requires both a large number of incoming and outgoing dependencies; because incoming_dependencies = 0, this class does not meet the hub-like criterion."
    },
    {
        "identifier": "com.github.javaparser.ast.type.ArrayType.Origin",
        "detection": false,
        "justification": "ArrayType.Origin has 0 outgoing dependencies and only 1 incoming dependency (from com.github.javaparser.ast.type.ArrayType). The incoming class's dependency list contains 18 entries (e.g. com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.utils.Pair, com.github.javaparser.resolution.types.ResolvedType, com.github.javaparser.ast.type.ArrayType.Origin, ...), but the analyzed class itself is referenced by a single other abstraction and does not depend on other abstractions. Hub-like Modularization requires an abstraction to have many incoming and many outgoing relationships; this class has neither, so the smell is not present."
    },
    {
        "identifier": "foo.A",
        "detection": false,
        "justification": "Class foo.A has 1 incoming dependency (foo.C -> foo.A) and 1 outgoing dependency (foo.A -> foo.A.FindMeIfYouCan). The number of incoming and outgoing connections is small (one each), so it does not exhibit hub-like modularization."
    },
    {
        "identifier": "com.github.javaparser.utils.VisitorSet.EqualsHashcodeOverridingFacade",
        "detection": false,
        "justification": "Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies. This class has 1 outgoing dependency (com.github.javaparser.utils.VisitorSet) and 0 incoming dependencies. The low counts (1 outgoing, 0 incoming) do not meet the 'hub-like' criteria, so the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.ast.Node.PostOrderIterator",
        "detection": false,
        "justification": "Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies. For com.github.javaparser.ast.Node.PostOrderIterator, incoming_dependencies = [] and outgoing_dependencies = [], indicating no incoming or outgoing dependencies; therefore it does not exhibit hub-like modularization."
    },
    {
        "identifier": "com.github.javaparser.Provider",
        "detection": false,
        "justification": "Provider has many incoming dependencies (9 distinct callers: com.github.javaparser.JavaParser, com.github.javaparser.Processor, com.github.javaparser.UnicodeEscapeProcessingProvider, com.github.javaparser.LineEndingProcessingProvider, com.github.javaparser.Providers, com.github.javaparser.GeneratedJavaParserBase, com.github.javaparser.GeneratedJavaParser, com.github.javaparser.SimpleCharStream, com.github.javaparser.utils.Utils) but zero outgoing dependencies (no listed dependencies from Provider). Hub-like Modularization requires an abstraction to have widespread both incoming and outgoing dependencies; Provider only exhibits widespread incoming links, so the hub-like smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.UnicodeEscapeProcessingProvider",
        "detection": false,
        "justification": "The class has 5 outgoing dependencies (UnicodeEscapeProcessingProvider.PositionMappingBuilder, Provider, UnicodeEscapeProcessingProvider.LineCounter, UnicodeEscapeProcessingProvider.PositionUpdate, UnicodeEscapeProcessingProvider.PositionMapping) and only 2 incoming dependents (ParserConfiguration, ParserConfiguration.UnicodeEscapeProcessor). Hub-like Modularization requires a large number of both incoming and outgoing relationships; here the counts are small and the outgoing links are primarily to closely related nested/helper types, so this class does not exhibit a hub-like smell."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.resolution.naming.NameLogic",
        "detection": false,
        "justification": "NameLogic has many outgoing dependencies (11): com.github.javaparser.resolution.model.SymbolReference, com.github.javaparser.resolution.Context, com.github.javaparser.resolution.TypeSolver, com.github.javaparser.ast.expr.FieldAccessExpr, com.github.javaparser.ast.Node, com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration, com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration, com.github.javaparser.symbolsolver.resolution.naming.NameLogic.PredicateOnParentAndChild, com.github.javaparser.symbolsolver.resolution.naming.NameRole, com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFactory, com.github.javaparser.symbolsolver.resolution.naming.NameCategory. However, it has zero incoming dependencies (no other abstractions depend on it). The Hub-like Modularization smell requires an abstraction to have both many incoming and many outgoing connections; because incoming dependencies = 0, the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.ast.modules.ModuleProvidesDirective",
        "detection": true,
        "justification": "ModuleProvidesDirective has a large number of incoming dependencies (21 distinct clients in the provided data) including many visitor and utility classes such as com.github.javaparser.symbolsolver.javaparsermodel.DefaultVisitorAdapter, com.github.javaparser.ast.visitor.VoidVisitor, HashCodeVisitor, EqualsVisitor, CloneVisitor, GeneratedJavaParser, PrettyPrintVisitor and DefaultPrettyPrinterVisitor. It also has multiple outgoing dependencies (9 distinct suppliers) to core abstractions such as com.github.javaparser.ast.Node, com.github.javaparser.ast.expr.Name, com.github.javaparser.ast.NodeList, com.github.javaparser.TokenRange, com.github.javaparser.ast.observer.ObservableProperty and com.github.javaparser.metamodel.JavaParserMetaModel. The presence of many incoming links combined with multiple outgoing links (both across visitor/printer infrastructure and core AST/meta-model types) matches the Hub-like Modularization smell."
    },
    {
        "identifier": "com.github.javaparser.generator.core.other.TokenKindGenerator",
        "detection": false,
        "justification": "Hub-like Modularization requires an abstraction to have many incoming and many outgoing dependencies. TokenKindGenerator has outgoing dependencies to 8 other abstractions (EnumDeclaration, IntegerLiteralExpr, CompilationUnit, ClassOrInterfaceDeclaration, EnumConstantDeclaration, SwitchStmt, SwitchEntry, SourceRoot) but has 0 incoming dependencies. Because there are no incoming dependencies, it does not meet the 'both incoming and outgoing with a large number' criterion and therefore is not a hub."
    },
    {
        "identifier": "com.github.javaparser.ast.ArrayCreationLevel",
        "detection": true,
        "justification": "ArrayCreationLevel has a large number of incoming and outgoing dependencies. Incoming: referenced by many visitor/printer/adaptor classes (at least 19 distinct incoming abstractions such as DefaultVisitorAdapter, VoidVisitor, GenericVisitor, HashCodeVisitor, EqualsVisitor, CloneVisitor, PrettyPrintVisitor, DefaultPrettyPrinterVisitor, NodeFinderVisitor, VoidVisitorAdapter, etc.). Outgoing: depends on a sizeable set of core and meta abstractions (11 distinct outgoing dependencies including com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.ast.expr.Expression, com.github.javaparser.ast.NodeList, com.github.javaparser.metamodel.ArrayCreationLevelMetaModel, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.TokenRange, com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.ast.Node, com.github.javaparser.Range). The class therefore acts as a hub with many incoming connectors (various visitors/printers) and many outgoing links to core AST and meta-model types, matching the Hub-like Modularization smell."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserTypePatternDeclaration",
        "detection": false,
        "justification": "The class has a small set of direct outgoing dependencies (4): com.github.javaparser.resolution.TypeSolver, com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade, com.github.javaparser.ast.expr.TypePatternExpr, com.github.javaparser.resolution.types.ResolvedType. It has a small set of direct incoming dependencies (3): com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserSymbolDeclaration, com.github.javaparser.symbolsolver.javaparsermodel.contexts.InstanceOfExprContext, com.github.javaparser.symbolsolver.javaparsermodel.contexts.AbstractJavaParserContext. Hub-like modularization requires an abstraction to have incoming and outgoing links with a large number of other abstractions; here the direct incoming and outgoing degree (3 incoming, 4 outgoing) is low. (Note: one outgoing target, JavaParserFacade, itself references many types in the provided data, but the analyzed class's direct coupling count remains small, so it is not a hub.)"
    },
    {
        "identifier": "com.github.javaparser.resolution.types.parametrization.ResolvedTypeParametersMap",
        "detection": false,
        "justification": "The class has a small number of outgoing dependencies (3: ResolvedTypeParametersMap.Builder, com.github.javaparser.resolution.types.ResolvedType, com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration) and a small number of incoming dependencies (5: JavaParserEnumDeclaration, MethodUsage, ReferenceTypeImpl, ResolvedReferenceType, ResolvedTypeParametrized). Because Hub-like Modularization requires an abstraction to have dependencies (both incoming and outgoing) with a large number of other abstractions, the observed counts (total distinct related abstractions = 8) do not indicate a hub-like role."
    },
    {
        "identifier": "com.github.javaparser.metamodel.ThrowStmtMetaModel",
        "detection": false,
        "justification": "ThrowStmtMetaModel has a small number of dependencies: 1 outgoing dependency (com.github.javaparser.metamodel.PropertyMetaModel) and 2 incoming dependents (com.github.javaparser.ast.stmt.ThrowStmt and com.github.javaparser.metamodel.JavaParserMetaModel). Hub-like Modularization requires an abstraction to have incoming and outgoing links with a large number of other abstractions. The provided data shows only a few direct connections, so ThrowStmtMetaModel does not exhibit a hub-like modularization smell."
    },
    {
        "identifier": "com.github.javaparser.generator.core.node.PropertyGenerator",
        "detection": false,
        "justification": "PropertyGenerator has 13 outgoing dependencies (com.github.javaparser.StaticJavaParser, com.github.javaparser.metamodel.BaseNodeMetaModel, com.github.javaparser.ast.stmt.BlockStmt, com.github.javaparser.utils.Utils, com.github.javaparser.ast.CompilationUnit, com.github.javaparser.ast.body.ClassOrInterfaceDeclaration, com.github.javaparser.ast.body.EnumDeclaration, com.github.javaparser.ast.body.EnumConstantDeclaration, com.github.javaparser.generator.core.utils.CodeUtils, com.github.javaparser.ast.body.MethodDeclaration, com.github.javaparser.metamodel.PropertyMetaModel, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.utils.SourceRoot) but has 0 incoming dependencies. Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; the absence of incoming dependencies means PropertyGenerator is not a hub."
    },
    {
        "identifier": "com.github.javaparser.ast.Node.Level",
        "detection": false,
        "justification": "The class has 0 incoming dependencies and 0 outgoing dependencies (incoming_dependencies: [], outgoing_dependencies: [], analyzed_package.dependencies: []). Hub-like Modularization requires an abstraction to have many incoming and outgoing dependencies; since this class has none, it is not a hub."
    },
    {
        "identifier": "com.github.javaparser.ast.stmt.LocalRecordDeclarationStmt",
        "detection": true,
        "justification": "LocalRecordDeclarationStmt has outgoing dependencies to multiple core abstractions (VoidVisitor, GenericVisitor, Node, RecordDeclaration, JavaParserMetaModel, TokenRange, ObservableProperty, LocalRecordDeclarationStmtMetaModel) and is the target of a large number of incoming dependencies from many different modules and visitors (for example: DefaultVisitorAdapter, ControlFlowLogic, Statement, VoidVisitor, HashCodeVisitor, VoidVisitorWithDefaults, GenericVisitor, ModifierVisitor, GenericListVisitorAdapter, ObjectIdentityEqualsVisitor, EqualsVisitor, CloneVisitor, VoidVisitorAdapter, GenericVisitorWithDefaults, NodeFinderVisitor, GeneratedJavaParser, PrettyPrintVisitor, DefaultPrettyPrinterVisitor, etc.). The presence of many incoming callers across parsing, visiting, printing and resolution components together with multiple outgoing ties to core AST/meta-model classes indicates hub-like modularization."
    },
    {
        "identifier": "com.github.javaparser.ast.validator.language_level_validations.chunks.CommonValidators",
        "detection": false,
        "justification": "Hub-like Modularization requires an abstraction to have many incoming and many outgoing dependencies. CommonValidators has outgoing dependencies to three provided abstractions: com.github.javaparser.metamodel.NodeMetaModel, com.github.javaparser.ast.expr.Expression, and com.github.javaparser.ast.NodeList (Expression itself references many classes transitively). However, the analysis shows zero incoming dependencies for CommonValidators. Because there are no incoming dependencies, the class does not exhibit the required pattern of having both large incoming and outgoing coupling, so the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.declarations.AstResolutionUtils",
        "detection": true,
        "justification": "AstResolutionUtils has a large number of both incoming and outgoing ties: outgoing dependencies to 6 distinct abstractions (com.github.javaparser.resolution.model.SymbolReference, com.github.javaparser.resolution.TypeSolver, com.github.javaparser.ast.nodeTypes.NodeWithAnnotations, com.github.javaparser.ast.Node, com.github.javaparser.ast.nodeTypes.NodeWithMembers, com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFactory) and incoming dependencies from 8 distinct declaration classes (JavaParserTypeVariableDeclaration, JavaParserAnonymousClassDeclaration, JavaParserAnnotationDeclaration, JavaParserTypeAdapter, JavaParserEnumDeclaration, JavaParserRecordDeclaration, JavaParserClassDeclaration, JavaParserInterfaceDeclaration). Many of the outgoing dependencies are core AST and resolution services (Node, NodeWithAnnotations/Members, TypeSolver, SymbolReference, JavaParserFactory), while the incoming set consists of many different declaration types that all depend on AstResolutionUtils. This pattern — a utility used by many different modules and itself depending on many core abstractions — matches the hub-like modularization smell."
    },
    {
        "identifier": "com.github.javaparser.utils.SourceZip",
        "detection": false,
        "justification": "SourceZip has 0 incoming dependencies and only 4 outgoing dependencies (com.github.javaparser.ParserConfiguration, com.github.javaparser.JavaParser, com.github.javaparser.ParseResult, com.github.javaparser.utils.SourceZip.Callback). Hub-like Modularization requires an abstraction to have dependencies both incoming and outgoing with a large number of other abstractions; the absence of incoming dependencies and the small number of outgoing dependencies means the smell is not present."
    },
    {
        "identifier": "implements_duplicate.A",
        "detection": false,
        "justification": "The class has 0 outgoing dependencies and 0 incoming dependencies (both dependency lists are empty). Hub-like Modularization requires many incoming and outgoing dependencies; with none present, the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.ast.type.TypeParameter",
        "detection": true,
        "justification": "TypeParameter has a large number of both outgoing and incoming dependencies. Outgoing: it directly depends on at least 13 distinct abstractions (com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.resolution.types.ResolvedTypeVariable, com.github.javaparser.resolution.Context, com.github.javaparser.resolution.types.ResolvedType, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.ast.NodeList, com.github.javaparser.ast.expr.SimpleName, com.github.javaparser.TokenRange, com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.ast.Node, com.github.javaparser.metamodel.TypeParameterMetaModel, com.github.javaparser.Range). Incoming: it is referenced by a large set of other abstractions (many visitor and tooling classes), for example DefaultVisitorAdapter, JavaParserTypeVariableDeclaration, JavaParserTypeParameter, JavaParserTypeDeclarationAdapter, com.github.javaparser.ast.type.Type, NodeWithTypeParameters, VoidVisitor, GenericVisitor, ModifierVisitor, StaticJavaParser, JavaParserAdapter, GeneratedJavaParser, PrettyPrintVisitor, DefaultPrettyPrinterVisitor, plus numerous other visitor implementations (HashCodeVisitor, EqualsVisitor, CloneVisitor, VoidVisitorAdapter, GenericVisitorAdapter, etc.). Because it has many outgoing links and is depended upon by many (dozens of) other classes, it functions as a central hub and therefore exhibits the Hub-like Modularization smell."
    },
    {
        "identifier": "com.github.javaparser.ast.visitor.VoidVisitor",
        "detection": true,
        "justification": "VoidVisitor participates in a very large number of mutual dependencies: it has outgoing ties to many AST node types and language constructs (examples from the outgoing list: ImportDeclaration, MethodDeclaration, ClassOrInterfaceDeclaration, EnumDeclaration, CompilationUnit, BlockStmt, IfStmt, ForStmt, ReturnStmt, TryStmt, LambdaExpr, MethodCallExpr, FieldAccessExpr, ArrayCreationExpr, AnnotationDeclaration, JavadocComment, TraditionalJavadocComment, ModuleDeclaration, ModuleExportsDirective, RecordDeclaration, RecordPatternExpr) and it is referenced back (incoming) by many of the same kinds of AST types and core classes (examples from the incoming list: CompilationUnit, Node, ImportDeclaration, MethodDeclaration, ClassOrInterfaceDeclaration, FieldDeclaration, EnumDeclaration, Various Type nodes such as ArrayType/UnionType/PrimitiveType/WildcardType, many statement and expression nodes like IfStmt, ForStmt, ReturnStmt, TryStmt, LambdaExpr, MethodCallExpr, FieldAccessExpr, JavadocComment, TraditionalJavadocComment). Because VoidVisitor has both a very large number of outgoing dependencies to other abstractions and a very large number of incoming dependencies from those abstractions (i.e., it is heavily referenced and references many distinct classes across the AST), it matches the Hub-like Modularization smell."
    },
    {
        "identifier": "com.github.javaparser.generator.metamodel.InitializePropertyMetaModelsStatementsGenerator",
        "detection": false,
        "justification": "Outgoing dependencies: 7 distinct abstractions (com.github.javaparser.utils.CodeGenerationUtils, com.github.javaparser.StaticJavaParser, com.github.javaparser.generator.metamodel.MetaModelGenerator, com.github.javaparser.ast.body.ClassOrInterfaceDeclaration, com.github.javaparser.generator.metamodel.AstTypeAnalysis, com.github.javaparser.ast.NodeList, com.github.javaparser.utils.Utils). Incoming dependencies: only 1 abstraction depends on this class (com.github.javaparser.generator.metamodel.NodeMetaModelGenerator). Hub-like Modularization requires an abstraction to have both many incoming and many outgoing dependencies. Here the outgoing degree is moderate and the incoming degree is low (1), so this class does not meet the hub-like criteria."
    },
    {
        "identifier": "(default package).InnerClassDotExpressions.InnerClass",
        "detection": false,
        "justification": "The class has 0 incoming dependencies and 0 outgoing dependencies (incoming_dependencies: [], outgoing_dependencies: []). Hub-like Modularization requires many incoming and outgoing dependencies; this class has none, so the smell is not present."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.FailureHandler",
        "detection": false,
        "justification": "FailureHandler has no outgoing dependencies (outgoing_dependencies = []). It has a single incoming dependency from com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade. Hub-like Modularization requires an abstraction to have dependencies (both incoming and outgoing) with a large number of other abstractions; FailureHandler has only one incoming and zero outgoing, so it does not meet the hub-like criteria."
    },
    {
        "identifier": "com.github.javaparser.ast.nodeTypes.NodeWithDeclaration",
        "detection": false,
        "justification": "The class has 0 incoming dependencies and 0 outgoing dependencies (both dependency lists are empty). Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; since this class has none, the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.javasymbolsolver.javassist_symbols.main_jar.ConcreteEnum",
        "detection": false,
        "justification": "ConcreteEnum has 0 incoming dependencies and 0 outgoing dependencies (incoming_dependencies: [], outgoing_dependencies: []). Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies, which is not the case here."
    },
    {
        "identifier": "com.github.javaparser.metamodel.NormalAnnotationExprMetaModel",
        "detection": false,
        "justification": "NormalAnnotationExprMetaModel has only 1 outgoing dependency (com.github.javaparser.metamodel.PropertyMetaModel) and only 2 incoming dependents (com.github.javaparser.ast.expr.NormalAnnotationExpr and com.github.javaparser.metamodel.JavaParserMetaModel). A hub-like module would have a large number of both incoming and outgoing relationships; the provided data shows low counts, so this class is not a hub. Note: JavaParserMetaModel references many meta-model classes (including NormalAnnotationExprMetaModel), but that reflects many incoming edges to JavaParserMetaModel, not many outgoing edges from NormalAnnotationExprMetaModel."
    },
    {
        "identifier": "com.github.javaparser.ast.comments.JavadocComment",
        "detection": true,
        "justification": "The class has a large number of incoming dependencies (23 distinct callers in the provided data) including many visitor and AST node classes such as com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.visitor.GenericVisitor, VoidVisitorAdapter, GenericVisitorAdapter, PrettyPrintVisitor, EqualsVisitor, CloneVisitor, JavadocParser, and numerous AST node types (MethodDeclaration, ClassOrInterfaceDeclaration, FieldDeclaration, EnumDeclaration, ConstructorDeclaration, AnnotationDeclaration, EnumConstantDeclaration, AnnotationMemberDeclaration, InitializerDeclaration, TypeDeclaration, CommentsCollection, Comment, NodeWithJavadoc, DefaultVisitorAdapter). It also has multiple outgoing dependencies (8 distinct abstractions) including com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.javadoc.Javadoc, com.github.javaparser.Range, com.github.javaparser.TokenRange, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.metamodel.JavadocCommentMetaModel, and com.github.javaparser.StaticJavaParser. The combination of many incoming connections from diverse modules and several outgoing dependencies qualifies it as a hub-like modularization smell."
    },
    {
        "identifier": "com.github.javaparser.ast.validator.postprocessors.Java25PostProcessor",
        "detection": false,
        "justification": "The class has 0 incoming dependencies and 0 outgoing dependencies (both dependency lists are empty). Therefore it does not depend on, nor is depended on by, a large number of other abstractions and does not exhibit Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.logic.AbstractClassDeclaration",
        "detection": false,
        "justification": "Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies. The analyzed class has no incoming dependencies (incoming_dependencies = []), and only two direct outgoing dependencies: com.github.javaparser.resolution.declarations.ResolvedClassDeclaration and com.github.javaparser.resolution.types.ResolvedReferenceType. Although ResolvedReferenceType itself depends on many types, those are transitive (dependencies of an outgoing dependency), not incoming dependencies of AbstractClassDeclaration. Therefore AbstractClassDeclaration does not exhibit hub-like modularization in isolation."
    },
    {
        "identifier": "com.github.javaparser.resolution.declarations.ResolvedFieldDeclaration",
        "detection": false,
        "justification": "ResolvedFieldDeclaration has many incoming dependencies (referenced by at least these classes: com.github.javaparser.symbolsolver.JavaSymbolSolver, com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassDeclaration, com.github.javaparser.symbolsolver.reflectionmodel.ReflectionEnumDeclaration, com.github.javaparser.symbolsolver.reflectionmodel.ReflectionRecordDeclaration, com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassAdapter, com.github.javaparser.symbolsolver.reflectionmodel.ReflectionInterfaceDeclaration, com.github.javaparser.symbolsolver.reflectionmodel.ReflectionFieldDeclaration, com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserTypeVariableDeclaration, com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserTypeParameter, com.github.javaparser.symbolsolver.javassistmodel.JavassistEnumDeclaration, com.github.javaparser.ast.body.FieldDeclaration, com.github.javaparser.resolution.declarations.ResolvedDeclaration, com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration), but it has only one outgoing dependency listed (com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration). Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; here the incoming side is high (≈13) while the outgoing side is minimal (1), so the hub-like smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.ast.nodeTypes.NodeWithArguments",
        "detection": false,
        "justification": "NodeWithArguments has only 3 outgoing dependencies (com.github.javaparser.StaticJavaParser, com.github.javaparser.ast.expr.Expression, com.github.javaparser.ast.NodeList) and has no incoming dependencies. Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing relationships; since this class has few direct outgoing dependencies and zero incoming dependencies, it does not meet the hub-like criteria."
    },
    {
        "identifier": "another.String",
        "detection": false,
        "justification": "The class has 0 incoming dependencies and 0 outgoing dependencies. Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies, which is not present here."
    },
    {
        "identifier": "com.github.javaparser.ast.stmt.BreakStmt",
        "detection": true,
        "justification": "BreakStmt has outgoing dependencies to 9 distinct abstractions (com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.Range, com.github.javaparser.ast.expr.SimpleName, com.github.javaparser.TokenRange, com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.ast.Node, com.github.javaparser.metamodel.BreakStmtMetaModel, com.github.javaparser.ast.visitor.GenericVisitor) and receives incoming dependencies from a large number (20+) of other abstractions across visitors, printers, symbol solver and core AST classes (examples include com.github.javaparser.symbolsolver.javaparsermodel.DefaultVisitorAdapter, com.github.javaparser.symbolsolver.javaparsermodel.NormalCompletionVisitor, com.github.javaparser.symbolsolver.resolution.typeinference.ControlFlowLogic, com.github.javaparser.ast.stmt.Statement, com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.printer.PrettyPrintVisitor, com.github.javaparser.GeneratedJavaParser, com.github.javaparser.printer.DefaultPrettyPrinterVisitor, com.github.javaparser.ast.visitor.ModifierVisitor). The combination of many incoming clients together with multiple outgoing links indicates a hub-like modularization smell."
    },
    {
        "identifier": "com.github.javaparser.javadoc.description.JavadocInlineTag.Type",
        "detection": false,
        "justification": "Not detected: the class has only one incoming dependency (from com.github.javaparser.javadoc.description.JavadocInlineTag) and one outgoing dependency (to com.github.javaparser.javadoc.description.JavadocInlineTag). There are no dependencies with a large number of other abstractions, so it does not exhibit Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.ast.nodeTypes.modifiers.NodeWithFinalModifier",
        "detection": false,
        "justification": "The class has 0 incoming dependencies and 0 outgoing dependencies (incoming_dependencies: [], outgoing_dependencies: []). Hub-like Modularization requires an abstraction to have dependencies both incoming and outgoing with a large number of other abstractions; this class has no such dependencies."
    },
    {
        "identifier": "com.github.javaparser.ast.validator.language_level_validations.Java14Validator",
        "detection": false,
        "justification": "Java14Validator has only 1 outgoing dependency (com.github.javaparser.ast.validator.Validator) and 0 incoming dependencies. Hub-like Modularization requires an abstraction to have many incoming and outgoing dependencies; the provided data shows minimal connections, so the smell is not present."
    },
    {
        "identifier": "com.github.javaparser.ast.visitor.GenericListVisitorAdapter",
        "detection": false,
        "justification": "Hub-like Modularization requires an abstraction to have both a large number of incoming and outgoing dependencies. For this class the incoming_dependencies list is empty (0 incoming). Although there are many outgoing dependencies to numerous AST node types (examples include TraditionalJavadocComment, WildcardType, UnaryExpr, TextBlockLiteralExpr, YieldStmt, SynchronizedStmt, DoStmt, ImportDeclaration, ReturnStmt, ClassExpr, CharLiteralExpr, BooleanLiteralExpr, InstanceOfExpr, ModuleDeclaration, MethodDeclaration, VariableDeclarator, SimpleName, MethodReferenceExpr, ClassOrInterfaceDeclaration, RecordDeclaration, NullLiteralExpr, ArrayCreationExpr, ExpressionStmt, EnumConstantDeclaration, Name, ThisExpr, FieldAccessExpr, ArrayInitializerExpr, LocalClassDeclarationStmt, VariableDeclarationExpr, InitializerDeclaration, MarkdownComment, CompilationUnit, ClassOrInterfaceType, etc.), the absence of any incoming dependencies means it does not meet the definition (requires both incoming and outgoing to be large). Therefore the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.printer.concretesyntaxmodel.CsmAttribute",
        "detection": false,
        "justification": "CsmAttribute has only 5 direct outgoing dependencies (com.github.javaparser.GeneratedJavaParserConstants, com.github.javaparser.ast.Node, com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.printer.concretesyntaxmodel.PrintingHelper, com.github.javaparser.printer.SourcePrinter) and is directly referenced by a single incoming dependency (com.github.javaparser.printer.lexicalpreservation.LexicalDifferenceCalculator). Hub-like modularization requires an abstraction to have many incoming and outgoing connections; the direct incoming/outgoing counts here are low, so the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.printer.concretesyntaxmodel.CsmChar",
        "detection": false,
        "justification": "Hub-like Modularization not detected: CsmChar has only outgoing dependencies to 3 other abstractions (com.github.javaparser.printer.SourcePrinter, com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.ast.Node) and has no incoming dependencies. The smell requires an abstraction to have both a large number of incoming and outgoing relationships; CsmChar does not exhibit a large number of connections in either direction based on the provided data."
    },
    {
        "identifier": "com.github.javaparser.utils.Log",
        "detection": false,
        "justification": "Log has only 2 incoming dependencies (com.github.javaparser.utils.SourceRoot, com.github.javaparser.generator.core.CoreGenerator) and 1 outgoing dependency (com.github.javaparser.utils.Log.Adapter). Hub-like Modularization requires an abstraction to have incoming and outgoing relationships with a large number of other abstractions; the provided data shows small counts, so Log is not a hub."
    },
    {
        "identifier": "com.github.javaparser.printer.RuntimeXMLStreamException",
        "detection": false,
        "justification": "Not detected: the class has 0 incoming dependencies and 0 outgoing dependencies (no relationships to other abstractions), so it does not exhibit hub-like modularization."
    },
    {
        "identifier": "com.github.javaparser.ast.type.ReferenceType",
        "detection": true,
        "justification": "ReferenceType has a relatively large number of both incoming and outgoing relationships. Outgoing: 8 direct dependencies (com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.metamodel.ReferenceTypeMetaModel, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.ast.NodeList, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.TokenRange, com.github.javaparser.ast.type.Type, com.github.javaparser.Range). Incoming: 17 distinct dependents across multiple packages (examples: com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserEnumDeclaration, com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserClassDeclaration, com.github.javaparser.ast.type.Type, com.github.javaparser.ast.type.WildcardType, com.github.javaparser.ast.nodeTypes.NodeWithThrownExceptions, many visitor classes such as com.github.javaparser.ast.visitor.VoidVisitor, GenericVisitor, ModifierVisitor, EqualsVisitor, and printing/parser components like com.github.javaparser.GeneratedJavaParser and com.github.javaparser.printer.PrettyPrintVisitor). The combination of numerous incoming references from diverse abstractions and multiple outgoing ties to core visitors and meta-models indicates a hub-like modularization smell."
    },
    {
        "identifier": "(default package).Usage",
        "detection": false,
        "justification": "The class (default package).Usage has 1 outgoing dependency ((default package).Extends) and 0 incoming dependencies. Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; the observed counts (outgoing=1, incoming=0) do not meet that condition."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.reflectionmodel.comparators.ClassComparator",
        "detection": false,
        "justification": "Not a hub: ClassComparator has 0 outgoing dependencies and only 2 incoming dependencies (from com.github.javaparser.symbolsolver.reflectionmodel.comparators.ParameterComparator and com.github.javaparser.symbolsolver.reflectionmodel.comparators.MethodComparator). Hub-like modularization requires a large number of both incoming and outgoing dependencies, which is not present here."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassDeclaration",
        "detection": false,
        "justification": "ReflectionClassDeclaration has a large number of outgoing dependencies (19 distinct abstractions) including ResolvedTypeParameterDeclaration, TypeSolver, ReflectionMethodDeclaration, MethodResolutionLogic, ResolvedReferenceType, SymbolReference, ResolvedType, ReflectionFactory, ReflectionClassAdapter, Node, MethodUsage, AccessSpecifier, ResolvedMethodDeclaration and ResolvedReferenceTypeDeclaration. However, it has a small set of incoming dependencies (3 distinct clients): AnonymousClassDeclarationContext, JavaParserTypeDeclarationAdapter, and SymbolSolver. Because the hub-like modularization smell requires an abstraction to have many dependencies both incoming and outgoing, the asymmetry here (many outgoing but only a few incoming) indicates the class is not a hub in the sense defined."
    },
    {
        "identifier": "foo.bar.AnInterface",
        "detection": false,
        "justification": "AnInterface has 0 outgoing dependencies and 2 incoming dependencies (foo.bar.AClass, foo.bar.differentpackage.AClass). Hub-like modularization requires an abstraction to have many incoming and outgoing connections; with only two incoming and no outgoing dependencies, this does not constitute a hub."
    },
    {
        "identifier": "com.github.javaparser.printer.lexicalpreservation.DefaultLexicalPreservingPrinter",
        "detection": false,
        "justification": "DefaultLexicalPreservingPrinter has a single incoming dependency (from com.github.javaparser.printer.lexicalpreservation.LexicalPreservingPrinter) and four outgoing dependencies (com.github.javaparser.printer.lexicalpreservation.LexicalPreservingVisitor, com.github.javaparser.printer.lexicalpreservation.NodeText, com.github.javaparser.printer.lexicalpreservation.LexicalPreservingPrinter, com.github.javaparser.ast.Node). Because the class interacts with only a small number of other abstractions (1 incoming, 4 outgoing) it does not exhibit Hub-like Modularization."
    },
    {
        "identifier": "com.foo.Widget",
        "detection": false,
        "justification": "Widget has outgoing dependencies to 5 distinct abstractions (com.github.javaparser.ast.CompilationUnit, com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver, com.github.javaparser.ParseException, com.github.javaparser.ast.body.MethodDeclaration, com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade) but has zero incoming dependencies (incoming_dependencies is empty). Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; because there are no incoming dependencies for Widget, the hub-like smell is not present."
    },
    {
        "identifier": "com.github.javaparser.metamodel.MarkdownCommentMetaModel",
        "detection": false,
        "justification": "The class has no outgoing dependencies (outgoing_dependencies = []), so it does not have many outgoing links. It only has two incoming dependents (com.github.javaparser.ast.comments.MarkdownComment and com.github.javaparser.metamodel.JavaParserMetaModel). Although JavaParserMetaModel references many meta-model types (including MarkdownCommentMetaModel), the analyzed class itself does not depend on a large number of other abstractions. Hub-like Modularization requires an abstraction to have both many incoming and many outgoing dependencies; this class lacks the outgoing side, so the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.Providers",
        "detection": false,
        "justification": "The class has only 1 outgoing dependency (com.github.javaparser.Provider) and is referenced by 2 incoming classes (com.github.javaparser.JavaParser and com.github.javaparser.ParserConfiguration). These are a small number of incoming/outgoing relationships, so it does not exhibit hub-like modularization."
    },
    {
        "identifier": "com.github.javaparser.ast.stmt.ForEachStmt",
        "detection": true,
        "justification": "The class has a large number of both outgoing and incoming dependencies: 14 distinct outgoing dependencies (e.g. com.github.javaparser.ast.Node, com.github.javaparser.ast.expr.Expression, com.github.javaparser.ast.stmt.Statement, com.github.javaparser.ast.body.VariableDeclarator, com.github.javaparser.ast.stmt.BlockStmt, com.github.javaparser.TokenRange, com.github.javaparser.metamodel.JavaParserMetaModel) and 22 distinct incoming dependents (many visitor and printer classes and tooling adapters depend on it, e.g. com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.printer.PrettyPrintVisitor, com.github.javaparser.printer.DefaultPrettyPrinterVisitor, com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFactory, com.github.javaparser.symbolsolver.javaparsermodel.ForEachStatementContext). Because it is connected to a large number of other abstractions in both directions (numerous classes depend on it and it depends on numerous classes), it fits the Hub-like Modularization smell."
    },
    {
        "identifier": "com.github.javaparser.ast.stmt.CatchClause",
        "detection": true,
        "justification": "CatchClause exhibits hub-like modularization: it has a relatively large set of outgoing dependencies (15) including com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.metamodel.CatchClauseMetaModel, com.github.javaparser.ast.NodeList, com.github.javaparser.ast.expr.SimpleName, com.github.javaparser.ast.stmt.BlockStmt, com.github.javaparser.TokenRange, com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.ast.type.Type, com.github.javaparser.ast.body.Parameter, com.github.javaparser.ast.Node, com.github.javaparser.ast.type.ClassOrInterfaceType, com.github.javaparser.Range. It also has many incoming dependencies (≈22) from numerous visitors, printers, validators and context classes (for example: com.github.javaparser.ast.visitor.VoidVisitor, GenericVisitor, HashCodeVisitor, EqualsVisitor, ModifierVisitor, PrettyPrintVisitor, GeneratedJavaParser, CatchClauseContext, ModifierValidator, and many visitor adapters). The combination of many incoming clients and many outgoing collaborators makes CatchClause act as a central hub, satisfying the hub-like modularization smell."
    },
    {
        "identifier": "(default package).Ancestor.Iterator",
        "detection": false,
        "justification": "The class (default package).Ancestor.Iterator has 0 incoming dependencies and 0 outgoing dependencies. Hub-like Modularization requires an abstraction to have many incoming and outgoing dependencies; since both counts are zero, the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.ast.expr.ClassExpr",
        "detection": false,
        "justification": "ClassExpr has a relatively large number of incoming dependencies (~22 distinct callers, mainly many visitor and utility classes), but only 9 outgoing dependencies (VoidVisitor, GenericVisitor, JavaParserMetaModel, TokenRange, ObservableProperty, Type, Node, ClassExprMetaModel, Range). The hub-like modularization smell requires both high fan-in and high fan-out; here the outgoing dependency set is not large, so ClassExpr does not meet the criterion for a hub-like abstraction."
    },
    {
        "identifier": "com.github.javaparser.ast.validator.postprocessors.PostProcessors",
        "detection": false,
        "justification": "PostProcessors has outgoing dependencies to 3 classes (com.github.javaparser.Processor, com.github.javaparser.ParseResult, com.github.javaparser.ParserConfiguration) and incoming dependencies from 2 classes (com.github.javaparser.ParserConfiguration, com.github.javaparser.ParserConfiguration.LanguageLevel). The total number of distinct other abstractions involved is 4, and although there is a mutual dependency with ParserConfiguration, the number of incoming and outgoing relationships is small and does not meet the \"large number of other abstractions\" criterion for Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.reflectionmodel.ReflectionMethodResolutionLogic",
        "detection": true,
        "justification": "ReflectionMethodResolutionLogic has a large number of outgoing dependencies (10 distinct abstractions: com.github.javaparser.resolution.model.SymbolReference, com.github.javaparser.resolution.Context, com.github.javaparser.resolution.MethodUsage, com.github.javaparser.resolution.types.ResolvedTypeVariable, com.github.javaparser.resolution.TypeSolver, com.github.javaparser.symbolsolver.reflectionmodel.ReflectionMethodDeclaration, com.github.javaparser.resolution.model.typesystem.ReferenceTypeImpl, com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration, com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration, com.github.javaparser.resolution.logic.MethodResolutionLogic) while also receiving incoming dependencies from multiple other abstractions (3 callers: com.github.javaparser.symbolsolver.reflectionmodel.ReflectionAnnotationDeclaration, com.github.javaparser.symbolsolver.reflectionmodel.ReflectionEnumDeclaration, com.github.javaparser.symbolsolver.reflectionmodel.ReflectionInterfaceDeclaration). The class therefore has both many outgoing and several incoming ties across different packages and roles, matching the Hub-like Modularization smell."
    },
    {
        "identifier": "com.github.javaparser.UnicodeEscapeProcessingProvider.PositionMappingBuilder",
        "detection": false,
        "justification": "The class has 0 outgoing dependencies (outgoing_dependencies is empty) and only 1 incoming dependency (from com.github.javaparser.UnicodeEscapeProcessingProvider). Hub-like Modularization requires an abstraction to have a large number of incoming and/or outgoing relationships; those conditions are not met here. Note: the incoming class lists several other dependencies, but that does not make the analyzed class itself a hub."
    },
    {
        "identifier": "(default package).DerivedClass.BaseClass",
        "detection": false,
        "justification": "The class does not exhibit Hub-like Modularization: incoming_dependencies = 0 and outgoing_dependencies = 0 (both arrays are empty), so it has no incoming or outgoing dependency relationships with many other abstractions."
    },
    {
        "identifier": "com.github.javaparser.ast.visitor.NoCommentHashCodeVisitor",
        "detection": false,
        "justification": "Hub-like modularization requires an abstraction to have many incoming and outgoing dependencies. The provided data shows NoCommentHashCodeVisitor has a large number of outgoing dependencies (e.g., TraditionalJavadocComment, WildcardType, UnaryExpr, TextBlockLiteralExpr, ModuleDeclaration, MethodDeclaration, VariableDeclarator, SimpleName, Node, CompilationUnit, ClassOrInterfaceType, many AST node and type classes) but zero incoming dependencies (incoming_dependencies is an empty list). Because there are no incoming dependencies, this class does not satisfy the 'both incoming and outgoing with a large number' criterion, so it is not detected as hub-like."
    },
    {
        "identifier": "com.github.javaparser.ast.expr.AnnotationExpr",
        "detection": true,
        "justification": "AnnotationExpr exhibits hub-like modularization: it has high fan-in (10 incoming dependents: JavaParserFacade, ArrayType, Type, NodeWithAnnotations, Expression, JavaParser, StaticJavaParser, JavaParserAdapter, GeneratedJavaParser, PositionUtils) and high fan-out (9 outgoing dependencies: NameExpr, Name, AnnotationExprMetaModel, ResolvedAnnotationDeclaration, JavaParserMetaModel, TokenRange, ObservableProperty, Node, Range). These dependencies span multiple concerns (AST expressions/nodes, metamodel, resolution, token/range, observer infrastructure), indicating the class is a central hub connecting many other abstractions."
    },
    {
        "identifier": "com.github.javaparser.metamodel.AnnotationExprMetaModel",
        "detection": false,
        "justification": "AnnotationExprMetaModel has only 1 outgoing dependency (com.github.javaparser.metamodel.PropertyMetaModel) and only 2 incoming dependents (com.github.javaparser.ast.expr.AnnotationExpr and com.github.javaparser.metamodel.JavaParserMetaModel). A hub-like modularization would show many incoming and many outgoing connections; the provided data shows limited connections for this class (even though JavaParserMetaModel itself references many other meta-models, that increases JavaParserMetaModel's degree, not AnnotationExprMetaModel's)."
    },
    {
        "identifier": "com.github.javaparser.ast.validator.postprocessors.Java14PostProcessor",
        "detection": false,
        "justification": "incoming_dependencies = 0 and outgoing_dependencies = 0 (both dependency lists are empty). Hub-like Modularization requires an abstraction to have many incoming and outgoing dependencies; with no incoming or outgoing dependencies, this class does not exhibit the smell."
    },
    {
        "identifier": "com.github.javaparser.generator.AbstractGenerator",
        "detection": false,
        "justification": "AbstractGenerator has numerous outgoing dependencies (13 distinct external abstractions: com.github.javaparser.StaticJavaParser, com.github.javaparser.ast.stmt.Statement, com.github.javaparser.ast.body.EnumDeclaration, com.github.javaparser.ast.body.ClassOrInterfaceDeclaration, com.github.javaparser.ast.CompilationUnit, com.github.javaparser.ast.body.CallableDeclaration, com.github.javaparser.ast.body.TypeDeclaration, com.github.javaparser.ast.expr.Expression, com.github.javaparser.ast.body.MethodDeclaration, com.github.javaparser.ast.NodeList, com.github.javaparser.ast.stmt.SwitchStmt, com.github.javaparser.utils.SourceRoot, com.github.javaparser.ParseResult) but has no incoming dependencies (0). Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; because AbstractGenerator lacks incoming dependencies it does not meet the hub-like smell criteria."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.JavaSymbolSolver.ArrayLengthValueDeclaration",
        "detection": false,
        "justification": "Not a hub: the class has 1 incoming dependency (from com.github.javaparser.symbolsolver.JavaSymbolSolver) and 1 outgoing dependency (to com.github.javaparser.resolution.types.ResolvedPrimitiveType). Hub-like Modularization requires an abstraction to have dependencies with a large number of other abstractions (many incoming and many outgoing); these counts are low, so the smell is not detected."
    },
    {
        "identifier": "(default package).ObjectContextDecorator",
        "detection": false,
        "justification": "The class has no incoming dependencies (0) and no outgoing dependencies (0). Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; with both counts at zero, this class does not exhibit the smell."
    },
    {
        "identifier": "com.github.javaparser.metamodel.ExpressionMetaModel",
        "detection": false,
        "justification": "ExpressionMetaModel has many incoming dependencies (e.g., referenced by com.github.javaparser.ast.expr.Expression which lists ExpressionMetaModel among its dependencies, and by com.github.javaparser.metamodel.JavaParserMetaModel which also lists ExpressionMetaModel among many meta-model dependencies), but it has no outgoing dependencies (outgoing_dependencies is empty). Hub-like Modularization requires an abstraction to have large numbers of both incoming and outgoing dependencies; since outgoing dependencies are absent, the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.ast.expr.LiteralExpr",
        "detection": false,
        "justification": "LiteralExpr has only one incoming dependency in the provided data (com.github.javaparser.ast.expr.Expression) and four direct outgoing dependencies (com.github.javaparser.metamodel.LiteralExprMetaModel, com.github.javaparser.Range, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.TokenRange). While com.github.javaparser.metamodel.JavaParserMetaModel references many other abstractions, LiteralExpr itself has only a single direct link to that meta-model; there is not a large number of distinct incoming and outgoing dependencies for LiteralExpr in the given data."
    },
    {
        "identifier": "com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration",
        "detection": true,
        "justification": "ResolvedTypeDeclaration has a high out-degree (7 outgoing dependencies: ResolvedInterfaceDeclaration, ResolvedEnumDeclaration, ResolvedTypeParameterDeclaration, ResolvedClassDeclaration, ResolvedReferenceTypeDeclaration, ResolvedAnnotationDeclaration, ResolvedRecordDeclaration) and a high in-degree (20 distinct incoming dependents in the provided data). Incoming dependents include core components and many declaration adapters/consumers such as JavaParserFacade, TypeExtractor, SymbolSolver, MethodResolutionLogic, JavaParserClassDeclaration, JavaParserInterfaceDeclaration, JavaParserRecordDeclaration, JavaParserFieldDeclaration, ReflectionFieldDeclaration, CompilationUnitContext, etc. The presence of many both incoming and outgoing links (multiple core resolver and parser components depending on it while it depends on many specific declaration types) matches the Hub-like Modularization smell."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade",
        "detection": true,
        "justification": "JavaParserFacade exhibits hub-like modularization: it has a large number of outgoing dependencies (51 distinct outgoing types) and is depended on by many other abstractions (37 distinct incoming types). Outgoing examples include numerous AST node and type classes (NameExpr, Expression, Node, MethodCallExpr, MethodReferenceExpr, ClassOrInterfaceType, Type, PrimitiveType, ArrayType, VoidType, WildcardType), resolution/core classes (ResolvedType, ResolvedReferenceTypeDeclaration, TypeSolver, MethodResolutionLogic, ConstructorResolutionLogic, Navigator, Solver, SymbolResolver, JavaSymbolSolver), and internal helpers (TypeExtractor, JavaParserFactory, FailureHandler). Incoming examples show many symbol-solver and context classes depending on it (JavaParserFieldDeclaration, JavaParserMethodDeclaration, JavaParserClassDeclaration, JavaParserEnumDeclaration, JavaParserTypeVariableDeclaration, JavaParserTypeParameter, JavaParserAnonymousClassDeclaration, JavaParserSymbolDeclaration, JavaParserFactory consumers, and many context classes such as MethodCallExprContext, LambdaExprContext, ObjectCreationContext, CompilationUnitContext). The combination of high fan-in and high fan-out across many modules and responsibilities indicates JavaParserFacade functions as a central hub and therefore matches the Hub-like Modularization smell."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.core.resolution.SymbolResolutionCapability",
        "detection": false,
        "justification": "Hub-like Modularization requires an abstraction to have many incoming and many outgoing dependencies. The analyzed class has outgoing dependencies to 2 abstractions: com.github.javaparser.resolution.model.SymbolReference and com.github.javaparser.resolution.TypeSolver, and has 0 incoming dependencies (incoming_dependencies is empty). Therefore it does not exhibit hub-like modularization."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.utils.SymbolSolverCollectionStrategy",
        "detection": false,
        "justification": "Hub-like Modularization requires an abstraction to have many incoming and outgoing dependencies. SymbolSolverCollectionStrategy has outgoing dependencies to com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver, com.github.javaparser.ParserConfiguration, and com.github.javaparser.utils.ProjectRoot (3 outgoing), but there are no incoming dependencies (incoming_dependencies is empty). The lack of incoming relations prevents it from being a hub."
    },
    {
        "identifier": "(default package).EnumWithInnerType.EnumInner",
        "detection": false,
        "justification": "No hub-like modularization: incoming_dependencies = 0 and outgoing_dependencies = 0 (dependencies array is empty). The class has no incoming or outgoing links to other abstractions, so it does not exhibit hub characteristics."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javassistmodel.JavassistEnumConstantDeclaration",
        "detection": false,
        "justification": "The class has 0 incoming dependencies and 3 outgoing dependencies (com.github.javaparser.resolution.model.typesystem.ReferenceTypeImpl, com.github.javaparser.resolution.TypeSolver, com.github.javaparser.resolution.types.ResolvedType). Hub-like Modularization requires an abstraction to have both a large number of incoming and outgoing dependencies; because incoming_dependencies is empty and outgoing count is small, the smell is not detected. (Note: the outgoing targets themselves depend on many classes, but the analyzed class in isolation does not exhibit hub-like connectivity.)"
    },
    {
        "identifier": "com.github.javaparser.ast.body.ConstructorDeclaration",
        "detection": true,
        "justification": "ConstructorDeclaration has a large number of both outgoing and incoming dependencies. Outgoing: it directly depends on many core abstractions (17 distinct dependencies) such as com.github.javaparser.ast.Node, com.github.javaparser.ast.NodeList, com.github.javaparser.Range, com.github.javaparser.TokenRange, com.github.javaparser.ast.Modifier, com.github.javaparser.ast.expr.SimpleName, com.github.javaparser.ast.comments.JavadocComment, com.github.javaparser.ast.stmt.BlockStmt, com.github.javaparser.ast.body.ReceiverParameter, com.github.javaparser.resolution.declarations.ResolvedConstructorDeclaration, and metamodel types (com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.metamodel.ConstructorDeclarationMetaModel), indicating broad outgoing coupling. Incoming: many (34) other abstractions depend on ConstructorDeclaration, including core visitors and their implementations (com.github.javaparser.ast.visitor.VoidVisitor, GenericVisitor and numerous visitor classes and adapters such as VoidVisitorAdapter, GenericVisitorAdapter, ModifierVisitor, HashCodeVisitor, EqualsVisitor, CloneVisitor, PrettyPrintVisitor, DefaultPrettyPrinterVisitor, NodeFinderVisitor, etc.), symbol-solver and facade classes (com.github.javaparser.symbolsolver.JavaSymbolSolver, com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade, JavaParserConstructorDeclaration, JavaParserClassDeclaration, ConstructorContext), generator and validation components (NodeMetaModelGenerator, MainConstructorGenerator, NotNullGenerator, ModifierValidator), and resolver/navigation utilities (com.github.javaparser.resolution.Navigator). The combination of many outgoing ties to core AST/metamodel types and many incoming ties from broad parts of the system (visitors, printers, symbol solver, generators, validators) fits the Hub-like Modularization smell."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.resolution.promotion.BooleanConditionalExprHandler",
        "detection": false,
        "justification": "The class has 0 incoming dependencies and only 1 outgoing dependency (to com.github.javaparser.resolution.types.ResolvedType). Hub-like Modularization requires an abstraction to have many incoming and outgoing dependencies; this class does not meet that criterion."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javassistmodel.JavassistAnnotationDeclaration",
        "detection": false,
        "justification": "Not detected: the class has no incoming dependencies (incoming_dependencies is empty) and only four direct outgoing dependencies (ResolvedType, TypeSolver, ResolvedReferenceTypeDeclaration, JavassistTypeDeclarationAdapter). Although those outgoing targets themselves depend on multiple other abstractions, the analyzed class in isolation does not exhibit a large number of incoming and outgoing relationships required for a hub-like modularization smell."
    },
    {
        "identifier": "com.github.javaparser.printer.lexicalpreservation.NodeText",
        "detection": true,
        "justification": "NodeText has a high number of incoming and outgoing connections: incoming dependencies from at least 8 distinct classes (LexicalDifferenceCalculator, DifferenceElementCalculator, LexicalPreservingPrinter, Difference, TextElementIteratorsFactory, ReshuffledDiffElementExtractor, DefaultLexicalPreservingPrinter, ChildTextElement) and outgoing dependencies to 4 distinct abstractions (TextElementMatchers, com.github.javaparser.ast.Node, TextElementMatcher, TextElement). The incoming callers include core lexical-preservation components (e.g., LexicalPreservingPrinter, LexicalDifferenceCalculator, Difference) while the outgoing edges link to AST Node and multiple text-related types, indicating NodeText functions as a central connector between many modules — a characteristic hub-like modularization smell."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.contexts.AnnotationDeclarationContext",
        "detection": false,
        "justification": "AnnotationDeclarationContext has outgoing dependencies to 5 other abstractions (com.github.javaparser.resolution.model.SymbolReference, com.github.javaparser.ast.body.AnnotationDeclaration, com.github.javaparser.symbolsolver.javaparsermodel.contexts.JavaParserTypeDeclarationAdapter, com.github.javaparser.resolution.TypeSolver, com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration) but has 0 incoming dependencies. Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies (acting as a central hub). Because there are no incoming dependencies, the class does not meet the hub-like criterion."
    },
    {
        "identifier": "com.github.javaparser.ast.body.BodyDeclaration",
        "detection": true,
        "justification": "BodyDeclaration has a large number of outgoing dependencies (21 distinct abstractions) including many specific body types and core AST primitives: EnumConstantDeclaration, TypeDeclaration, AnnotationDeclaration, AnnotationMemberDeclaration, InitializerDeclaration, FieldDeclaration, MethodDeclaration, ConstructorDeclaration, RecordDeclaration, ClassOrInterfaceDeclaration, CallableDeclaration, CompactConstructorDeclaration, Node, NodeList, TokenRange, ObservableProperty, Range, JavaParserMetaModel, BodyDeclarationMetaModel, Utils, etc. It also has many incoming dependencies (8 distinct abstractions) from major components that treat it as a central element: TypeDeclaration, NodeWithMembers, ObjectCreationExpr, JavaParser, StaticJavaParser, JavaParserAdapter, GeneratedJavaParser, NodeMetaModelGenerator. Several elements appear in both directions (e.g., TypeDeclaration, Node, NodeList, JavaParserMetaModel/BodyDeclarationMetaModel, ObservableProperty, TokenRange), indicating bidirectional coupling with many parts of the system. The combination of high outgoing and high incoming coupling across many different abstractions (core AST nodes, parser components, and metamodel utilities) meets the definition of a hub-like modularization."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserSymbolDeclaration",
        "detection": true,
        "justification": "The class has a large number of both outgoing and incoming dependencies. Outgoing: 13 distinct dependents referenced (e.g. JavaParserTypePatternDeclaration, JavaParserFacade, JavaParserVariableDeclaration, JavaParserParameterDeclaration, VariableDeclarator, TypeSolver, JavaParserFieldDeclaration, TypePatternExpr, Node, Parameter, Navigator, JavaParserFactory, MethodCallExpr). Incoming: many callers/references (at least 11) including TypeExtractor, ParameterSymbolDeclarator, FieldSymbolDeclarator, TypePatternSymbolDeclarator, VariableSymbolDeclarator and multiple context classes (InstanceOfExprContext, ForEachStatementContext, BlockStmtContext, TryWithResourceContext, ForStatementContext, AbstractJavaParserContext). The class therefore participates in numerous incoming and outgoing ties to diverse abstractions (core solver types, AST nodes, factory/bridge classes and various context/declarator classes), matching the Hub-like Modularization smell."
    },
    {
        "identifier": "com.github.javaparser.ast.nodeTypes.NodeWithAnnotations",
        "detection": false,
        "justification": "Not detected: the class has a small number of incoming dependencies (2: com.github.javaparser.symbolsolver.javaparsermodel.declarations.AstResolutionUtils, com.github.javaparser.ast.visitor.VoidVisitorAdapter) and a limited set of outgoing dependencies (7: com.github.javaparser.ast.expr.MarkerAnnotationExpr, com.github.javaparser.ast.expr.Expression, com.github.javaparser.ast.NodeList, com.github.javaparser.ast.expr.AnnotationExpr, com.github.javaparser.ast.expr.NormalAnnotationExpr, com.github.javaparser.StaticJavaParser, com.github.javaparser.ast.expr.SingleMemberAnnotationExpr). The outgoing dependencies are closely related (annotation/expression-related types), indicating cohesion rather than the many incoming and outgoing, wide-ranging connections characteristic of hub-like modularization."
    },
    {
        "identifier": "issue241.TypeWithMemberType.MemberInterface",
        "detection": false,
        "justification": "The class has 0 incoming dependencies and 0 outgoing dependencies (both empty). Hub-like Modularization requires a large number of incoming and/or outgoing dependencies; this class has none, so it is not a hub."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserEnumDeclaration",
        "detection": false,
        "justification": "Not a hub: the class has a large number of outgoing dependencies (21 distinct target abstractions, e.g. JavaParserFacade, TypeSolver, ResolvedType, ResolvedReferenceType, JavaParserTypeAdapter, JavaParserFactory, ReferenceTypeImpl, ReflectionFactory) but only a small number of incoming dependencies (3 distinct sources: com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade and the two inner callers JavaParserEnumDeclaration.ValuesMethod and JavaParserEnumDeclaration.ValueOfMethod). Hub-like modularization requires many incoming and outgoing connections; here incoming dependency count is low, so the class does not qualify as a hub."
    },
    {
        "identifier": "com.github.javaparser.ast.nodeTypes.NodeWithCondition",
        "detection": false,
        "justification": "NodeWithCondition has 1 outgoing dependency (com.github.javaparser.ast.expr.Expression) and 0 incoming dependencies. Hub-like Modularization requires an abstraction to have dependencies (both incoming and outgoing) with a large number of other abstractions. Although the referenced Expression type itself depends on many other types (≈47 listed), NodeWithCondition in isolation only directly depends on a single abstraction and has no incoming ties, so it does not meet the hub-like criteria."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.resolution.typeinference.TypeInference",
        "detection": false,
        "justification": "TypeInference has a large number of outgoing dependencies (many collaborators such as InferenceVariable, ResolvedTypeParameterDeclaration, SubtypeOfBound, TypeSolver, Expression, JavaParserFacade, InstantiationSet, ResolvedType, TypeInferenceCache, BoundSet, ConstraintFormulaSet, MethodUsage, Substitution, LambdaExpr, MethodReferenceExpr, ExpressionCompatibleWithType, etc.), but only a single incoming dependency is shown (ExpressionCompatibleWithType depends on TypeInference). Hub-like Modularization requires both many incoming and many outgoing dependencies; since incoming dependencies are minimal (1) while outgoing are many, TypeInference does not meet the full criteria for a hub-like module in the provided data."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javassistmodel.JavassistClassDeclaration",
        "detection": false,
        "justification": "JavassistClassDeclaration has 13 outgoing dependencies (Context, SymbolReference, AccessSpecifier, ResolvedType, TypeSolver, JavassistInterfaceDeclaration, JavassistFactory, Node, JavassistUtils, ResolvedReferenceTypeDeclaration, ResolvedReferenceType, JavassistTypeDeclarationAdapter, etc.) but only 3 incoming dependents (JavassistEnumDeclaration, JavassistInterfaceDeclaration, JavassistUtils). Hub-like modularization requires an abstraction to have many both incoming and outgoing connections. Here incoming coupling is small and the outgoing dependencies are largely to closely related types (several other javassistmodel classes and resolution/type system types), so it does not qualify as a hub."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javassistmodel.JavassistUtils",
        "detection": true,
        "justification": "JavassistUtils has a high number of outgoing dependencies (17 distinct abstractions: e.g. com.github.javaparser.resolution.types.ResolvedType, com.github.javaparser.resolution.TypeSolver, com.github.javaparser.resolution.logic.MethodResolutionLogic, com.github.javaparser.resolution.model.SymbolReference, com.github.javaparser.resolution.MethodUsage, com.github.javaparser.symbolsolver.javassistmodel.JavassistClassDeclaration, com.github.javaparser.symbolsolver.javassistmodel.JavassistInterfaceDeclaration, etc.) and is depended on by many other classes (6 incoming: JavassistEnumDeclaration, JavassistInterfaceDeclaration, JavassistRecordDeclaration, JavassistMethodLikeDeclarationAdapter, JavassistClassDeclaration, JavassistTypeDeclarationAdapter). It also has bidirectional links with key javassistmodel types (both incoming and outgoing with JavassistClassDeclaration and JavassistInterfaceDeclaration), indicating it functions as a central connector between multiple packages (resolution.*, resolution.types, model, javassistmodel). These characteristics match the Hub-like Modularization smell."
    },
    {
        "identifier": "com.github.javaparser.resolution.types.ResolvedTypeTransformer",
        "detection": false,
        "justification": "ResolvedTypeTransformer has only 2 incoming dependents (com.github.javaparser.resolution.model.typesystem.ReferenceTypeImpl, com.github.javaparser.resolution.types.ResolvedReferenceType) and a single outgoing dependency (com.github.javaparser.resolution.types.ResolvedType). The counts of incoming and outgoing relationships are low; therefore it does not exhibit hub-like modularization in the provided data."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserFieldDeclaration",
        "detection": false,
        "justification": "Outgoing dependencies: 11 distinct abstractions (com.github.javaparser.ast.AccessSpecifier, com.github.javaparser.ast.body.EnumConstantDeclaration, com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade, com.github.javaparser.resolution.types.ResolvedType, com.github.javaparser.ast.body.VariableDeclarator, com.github.javaparser.resolution.TypeSolver, com.github.javaparser.ast.Modifier, com.github.javaparser.ast.body.EnumDeclaration, com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration, com.github.javaparser.resolution.Navigator, com.github.javaparser.ast.body.FieldDeclaration) — shows moderate outward coupling. Incoming dependencies: only 2 distinct abstractions reference this class (com.github.javaparser.symbolsolver.JavaSymbolSolver and com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserSymbolDeclaration). Hub-like Modularization requires a large number of both incoming and outgoing dependencies; because the number of incoming dependents is small (2), this class does not meet the hub-like criterion."
    },
    {
        "identifier": "com.github.javaparser.metamodel.ForStmtMetaModel",
        "detection": false,
        "justification": "ForStmtMetaModel has a very small number of direct dependencies: only 1 outgoing dependency (com.github.javaparser.metamodel.PropertyMetaModel) and 2 incoming dependencies (com.github.javaparser.ast.stmt.ForStmt and com.github.javaparser.metamodel.JavaParserMetaModel). Although JavaParserMetaModel references many meta-model classes, ForStmtMetaModel itself is not directly connected to a large number of other abstractions, so it does not exhibit hub-like modularization."
    },
    {
        "identifier": "com.github.javaparser.metamodel.CharLiteralExprMetaModel",
        "detection": false,
        "justification": "CharLiteralExprMetaModel has no outgoing dependencies (outgoing_dependencies: []). It is referenced by only two incoming classes: com.github.javaparser.ast.expr.CharLiteralExpr and com.github.javaparser.metamodel.JavaParserMetaModel. Hub-like Modularization requires an abstraction to have large numbers of both incoming and outgoing dependencies; here incoming count is small (2) and outgoing is zero, so the smell is not detected."
    },
    {
        "identifier": "javaparser.GenericClass",
        "detection": false,
        "justification": "GenericClass has only one outgoing dependency (javaparser.GenericClass.Foo) and no incoming dependencies. Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; with 1 outgoing and 0 incoming, this class does not meet that criterion."
    },
    {
        "identifier": "(default package).InnerClassFieldContainer.InnerInnerInnerClass",
        "detection": false,
        "justification": "The class has 0 incoming dependencies and 0 outgoing dependencies (incoming_dependencies: [], outgoing_dependencies: []), so it does not exhibit hub-like modularization which requires a large number of both incoming and outgoing dependencies."
    },
    {
        "identifier": "com.github.javaparser.metamodel.PatternExprMetaModel",
        "detection": false,
        "justification": "PatternExprMetaModel has only one outgoing dependency (PropertyMetaModel) and only two incoming dependents (com.github.javaparser.ast.expr.PatternExpr and com.github.javaparser.metamodel.JavaParserMetaModel). Although JavaParserMetaModel itself depends on many meta-model classes, PatternExprMetaModel is not directly connected to a large number of other abstractions (low fan-out = 1, low fan-in = 2), so it does not exhibit Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.printer.concretesyntaxmodel.CsmList",
        "detection": false,
        "justification": "CsmList has 7 outgoing dependencies (ConcreteSyntaxModel, Node, CsmElement, NodeList, ObservableProperty, PrintingHelper, SourcePrinter) and a single incoming dependency (LexicalDifferenceCalculator). Hub-like modularization requires many incoming and many outgoing connections; here the incoming fan-in is low (1) and the outgoing fan-out is moderate and largely confined to a small set of related parser/printer types, so it does not qualify as a hub."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.core.resolution.MethodUsageResolutionCapability",
        "detection": false,
        "justification": "Not detected: the class has 0 incoming dependencies and only 1 outgoing dependency (to com.github.javaparser.resolution.Context). Hub-like Modularization requires many incoming and outgoing relationships; this class does not exhibit a large number of dependencies in either direction."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.reflectionmodel.ReflectionParameterDeclaration",
        "detection": false,
        "justification": "No: the class has no incoming dependencies (incoming_dependencies is empty) and only three outgoing dependencies (com.github.javaparser.resolution.TypeSolver, com.github.javaparser.symbolsolver.reflectionmodel.ReflectionFactory, com.github.javaparser.resolution.types.ResolvedType). Hub-like Modularization requires an abstraction to have many incoming and outgoing relationships; this class does not exhibit a large number of both incoming and outgoing dependencies."
    },
    {
        "identifier": "com.github.javaparser.metamodel.WhileStmtMetaModel",
        "detection": false,
        "justification": "WhileStmtMetaModel has only 1 outgoing dependency: com.github.javaparser.metamodel.PropertyMetaModel, and only 2 incoming dependencies: com.github.javaparser.ast.stmt.WhileStmt and com.github.javaparser.metamodel.JavaParserMetaModel. Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; the provided data shows neither a large outgoing fan-out nor many distinct incoming callers, so the smell is not present."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.reflectionmodel.ReflectionInterfaceDeclaration",
        "detection": false,
        "justification": "Outgoing dependencies: the class depends on 15 distinct abstractions (com.github.javaparser.resolution.TypeSolver, com.github.javaparser.resolution.declarations.ResolvedInterfaceDeclaration, com.github.javaparser.resolution.model.SymbolReference, com.github.javaparser.resolution.types.ResolvedType, com.github.javaparser.resolution.declarations.ResolvedFieldDeclaration, com.github.javaparser.resolution.Context, com.github.javaparser.symbolsolver.reflectionmodel.ReflectionMethodResolutionLogic, com.github.javaparser.resolution.model.typesystem.ReferenceTypeImpl, com.github.javaparser.symbolsolver.reflectionmodel.ReflectionFactory, com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassAdapter, com.github.javaparser.ast.Node, com.github.javaparser.resolution.MethodUsage, com.github.javaparser.ast.AccessSpecifier, com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration, com.github.javaparser.resolution.logic.InferenceContext). Incoming dependencies: only one recorded direct client (com.github.javaparser.symbolsolver.resolution.SymbolSolver). Hub-like Modularization requires a large number of both incoming and outgoing dependencies; here the outgoing fan-out is high but the incoming fan-in is minimal (one), so the class does not meet the hub-like modularization smell based on the provided data."
    },
    {
        "identifier": "com.github.javaparser.ast.body.CallableDeclaration",
        "detection": true,
        "justification": "CallableDeclaration has many outgoing dependencies (12) to diverse core abstractions and infrastructure: CallableDeclaration.Signature, ReceiverParameter, NodeList, SimpleName, TokenRange, ObservableProperty, JavaParserMetaModel, ArrayType, Node, Type, Parameter, CallableDeclarationMetaModel. It also has multiple incoming dependencies (4) from higher-level abstractions that use it: TypeDeclaration, BodyDeclaration, AbstractGenerator, Generator. The combination of numerous outgoing links to core AST types, meta-model and observer/token types, plus several incoming links from important container/generator classes, indicates the class acts as a hub connecting many unrelated abstractions, matching the Hub-like Modularization smell."
    },
    {
        "identifier": "com.github.javaparser.resolution.types.parametrization.ResolvedTypeParametrized",
        "detection": false,
        "justification": "ResolvedTypeParametrized has only 1 outgoing dependency (com.github.javaparser.resolution.types.parametrization.ResolvedTypeParametersMap) and 0 incoming dependencies. Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; the provided data shows no large fan-in or fan-out for this class."
    },
    {
        "identifier": "com.github.javaparser.ast.validator.language_level_validations.Java21Validator",
        "detection": false,
        "justification": "The class has 0 incoming dependencies (incoming_dependencies = []) and 0 outgoing dependencies (outgoing_dependencies = []). Since there are no incoming or outgoing ties to other abstractions, it does not exhibit hub-like modularization."
    },
    {
        "identifier": "org.tensorflow.op.Ops",
        "detection": false,
        "justification": "The class has no recorded relationships: dependencies = [], outgoing_dependencies = [], incoming_dependencies = []. With zero incoming and zero outgoing connections, it cannot be a hub-like abstraction (no large number of dependencies)."
    },
    {
        "identifier": "com.github.javaparser.utils.VisitorSet",
        "detection": false,
        "justification": "VisitorSet has only one direct outgoing dependency (com.github.javaparser.ast.visitor.GenericVisitor) and one incoming dependency (com.github.javaparser.utils.VisitorSet.EqualsHashcodeOverridingFacade). Hub-like Modularization requires an abstraction to have incoming and outgoing dependencies with a large number of other abstractions. Considering the class in isolation, VisitorSet's direct fan-in and fan-out are both low (1 each). Although GenericVisitor itself references many AST types, those are transitive from VisitorSet and do not increase VisitorSet's direct number of dependencies under the provided data, so the hub-like smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.ast.validator.language_level_validations.Java13Validator",
        "detection": false,
        "justification": "No incoming or outgoing dependencies: incoming_dependencies = 0, outgoing_dependencies = 0. Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies, which is not the case here."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.resolution.typeinference.ConstraintFormula",
        "detection": false,
        "justification": "ConstraintFormula has only one incoming dependency (com.github.javaparser.symbolsolver.resolution.typeinference.ConstraintFormulaSet) and two direct outgoing dependencies (com.github.javaparser.symbolsolver.resolution.typeinference.ConstraintFormula.ReductionResult and com.github.javaparser.symbolsolver.resolution.typeinference.BoundSet). While BoundSet itself is highly connected to many abstractions, ConstraintFormula's own incoming and outgoing dependency counts are low and do not constitute a hub."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.contexts.ExpressionContext",
        "detection": false,
        "justification": "Not a hub: the class has 0 incoming dependencies and only 2 direct outgoing dependencies (com.github.javaparser.resolution.model.SymbolReference, com.github.javaparser.resolution.TypeSolver). Hub-like Modularization requires an abstraction to have many incoming and many outgoing dependencies; here incoming = 0 and outgoing is small. (Note: TypeSolver itself depends on three classes, but those are not additional direct incoming dependencies to ExpressionContext.)"
    },
    {
        "identifier": "com.github.javaparser.ast.expr.ComponentPatternExpr",
        "detection": false,
        "justification": "ComponentPatternExpr has a small number of direct outgoing dependencies (3: com.github.javaparser.metamodel.ComponentPatternExprMetaModel, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.TokenRange) and a small number of direct incoming dependents (4: com.github.javaparser.symbolsolver.javaparsermodel.PatternVariableVisitor, com.github.javaparser.symbolsolver.javaparsermodel.contexts.AbstractJavaParserContext, com.github.javaparser.ast.expr.Expression, com.github.javaparser.GeneratedJavaParser). The hub-like smell requires an abstraction to have incoming and outgoing dependencies with a large number of other abstractions; the direct coupling counts here (outgoing = 3, incoming = 4) are low. Note: although JavaParserMetaModel (one outgoing dependency) itself lists many meta-model classes, ComponentPatternExpr only directly depends on that single meta-model abstraction, so ComponentPatternExpr does not act as a hub."
    },
    {
        "identifier": "com.github.javaparser.javadoc.description.JavadocDescription",
        "detection": false,
        "justification": "JavadocDescription has only 3 outgoing dependencies (com.github.javaparser.utils.Pair, com.github.javaparser.javadoc.description.JavadocDescriptionElement, com.github.javaparser.javadoc.description.JavadocInlineTag) and 3 incoming dependents (com.github.javaparser.JavadocParser, com.github.javaparser.javadoc.Javadoc, com.github.javaparser.javadoc.JavadocBlockTag). The number of distinct incoming and outgoing relationships is small and does not indicate an abstraction acting as a hub connected to a large number of other abstractions, so the Hub-like Modularization smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.generator.core.visitor.NoCommentEqualsVisitorGenerator",
        "detection": false,
        "justification": "The class has 0 incoming dependencies and 6 direct outgoing dependencies: com.github.javaparser.metamodel.BaseNodeMetaModel, com.github.javaparser.ast.stmt.BlockStmt, com.github.javaparser.ast.CompilationUnit, com.github.javaparser.ast.body.MethodDeclaration, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.utils.SourceRoot. Hub-like Modularization requires an abstraction to have dependencies (both incoming and outgoing) with a large number of other abstractions; here there are no incoming dependencies and only a small set of direct outgoing dependencies, so the smell is not present."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.resolution.typeinference.InstantiationSet",
        "detection": false,
        "justification": "InstantiationSet has a small, bounded set of dependencies: outgoing dependencies to 3 abstractions (com.github.javaparser.resolution.types.ResolvedType, com.github.javaparser.symbolsolver.resolution.typeinference.BoundSet, com.github.javaparser.symbolsolver.resolution.typeinference.Instantiation) and incoming dependencies from 2 abstractions (com.github.javaparser.symbolsolver.resolution.typeinference.TypeInference and com.github.javaparser.symbolsolver.resolution.typeinference.BoundSet). Although there is a mutual dependency with BoundSet, the total number of distinct incoming and outgoing collaborators is low (5), so it does not exhibit the large-many incoming-and-outgoing interactions characteristic of Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.metamodel.SimpleNameMetaModel",
        "detection": false,
        "justification": "SimpleNameMetaModel has only one outgoing dependency (com.github.javaparser.metamodel.PropertyMetaModel) and only two incoming dependents (com.github.javaparser.ast.expr.SimpleName and com.github.javaparser.metamodel.JavaParserMetaModel). The number of incoming and outgoing relationships is small and does not constitute dependencies with a large number of other abstractions, so it does not exhibit Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.contexts.VariableDeclaratorContext",
        "detection": false,
        "justification": "Hub-like Modularization requires an abstraction to have many incoming and many outgoing dependencies. For VariableDeclaratorContext the incoming_dependencies list is empty (no classes depend on it). Although it has multiple outgoing dependencies (to com.github.javaparser.ast.body.VariableDeclarator which itself references many types: [VoidVisitor, NameExpr, Expression, Utils, JavaParserMetaModel, ArrayType, Type, VariableDeclaratorMetaModel, NodeWithVariables, ResolvedValueDeclaration, SimpleName, TokenRange, ObservableProperty, Node, Range, Pair, GenericVisitor], to com.github.javaparser.resolution.TypeSolver which references [SymbolReference, UnsolvedSymbolException, ResolvedReferenceTypeDeclaration], and to com.github.javaparser.ast.Node which references many types [VoidVisitor, Position, ObserverRegistrationMode, ConfigurablePrinter, PrinterConfiguration, Comment, JavaParserMetaModel, Printer, DataKey, EqualsVisitor, PropagatingAstObserver, TokenRange, ObservableProperty, LineSeparator, Parsedness, SymbolResolver, Range, AstObserver, TreeTraversal, NodeList, NodeMetaModel, HashCodeVisitor, CompilationUnit, GenericVisitor]), the absence of any incoming dependencies means it does not meet the 'both many incoming and outgoing' criterion. Therefore the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.core.resolution.TypeVariableResolutionCapability",
        "detection": false,
        "justification": "Incoming dependencies: none (incoming_dependencies is empty). Outgoing dependencies: only 2 distinct abstractions (com.github.javaparser.resolution.Context, com.github.javaparser.resolution.MethodUsage). Hub-like Modularization requires an abstraction to have many incoming and outgoing dependencies; this class has no incoming dependencies and a small number of outgoing dependencies, so the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.utils.Utils",
        "detection": false,
        "justification": "Utils has a high incoming degree (33 distinct classes depend on Utils, e.g. PackageDeclaration, VariableDeclarator, PrettyPrintVisitor, LexicalPreservingPrinter, MetaModelGenerator, NodeMetaModelGenerator, PropertyGenerator) but a low outgoing degree (Utils directly depends on only 4 abstractions: com.github.javaparser.ast.Node, com.github.javaparser.Provider, com.github.javaparser.ast.expr.UnaryExpr, com.github.javaparser.utils.LineSeparator). The Hub-like Modularization smell requires an abstraction to have dependencies (both incoming and outgoing) with a large number of other abstractions; here only the incoming side is large while the outgoing side is small, so the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.ast.stmt.ThrowStmt",
        "detection": true,
        "justification": "ThrowStmt has a large number of incoming dependencies (22 distinct clients in the provided data — e.g. DefaultVisitorAdapter, NormalCompletionVisitor, Statement, many visitor implementations like VoidVisitor, GenericVisitor, HashCodeVisitor, EqualsVisitor, CloneVisitor, GeneratedJavaParser, PrettyPrintVisitor, DefaultPrettyPrinterVisitor, etc.), and also has multiple outgoing dependencies to core abstractions (9 outgoing dependencies: com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.ast.expr.Expression, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.TokenRange, com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.ast.Node, com.github.javaparser.metamodel.ThrowStmtMetaModel, com.github.javaparser.Range). The combination of many incoming clients and multiple outgoing ties to central framework types indicates a hub-like modularization smell."
    },
    {
        "identifier": "(default package).FieldDotExpressions.InnerInnerInnerClass",
        "detection": false,
        "justification": "Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies. This class has 0 outgoing dependencies and 0 incoming dependencies (no recorded dependency relationships), so it does not meet the criterion for a hub."
    },
    {
        "identifier": "com.github.javaparser.javasymbolsolver.javassist_symbols.main_jar.SuperClassOwnJar",
        "detection": false,
        "justification": "The class has no incoming dependencies and no outgoing dependencies (incoming_dependencies and outgoing_dependencies are both empty). Hub-like Modularization requires many incoming and outgoing relationships; this class has none, so the smell is not present."
    },
    {
        "identifier": "com.github.javaparser.ast.stmt.SwitchEntry",
        "detection": true,
        "justification": "SwitchEntry is a hub: it has many incoming dependents (numerous visitor classes and utilities reference it — e.g. com.github.javaparser.ast.visitor.VoidVisitor, GenericVisitor, HashCodeVisitor, EqualsVisitor, PrettyPrintVisitor, multiple Void/Generic visitor adapters, symbol-solver classes like DefaultVisitorAdapter, NormalCompletionVisitor, SwitchEntryContext, and core classes like SwitchStmt and SwitchExpr), and it also has multiple outgoing dependencies on core abstractions (it depends on com.github.javaparser.ast.visitor.VoidVisitor and GenericVisitor, com.github.javaparser.ast.expr.Expression, com.github.javaparser.ast.NodeList, com.github.javaparser.ast.Node, com.github.javaparser.TokenRange, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.metamodel.SwitchEntryMetaModel, com.github.javaparser.ast.observer.ObservableProperty, and its nested SwitchEntry.Type). The presence of a large set of both incoming clients and outgoing core-type dependencies indicates hub-like modularization."
    },
    {
        "identifier": "com.github.javaparser.javasymbolsolver.javassist_symbols.included_jar.InterfaceIncludedJar",
        "detection": false,
        "justification": "No incoming or outgoing dependencies were reported (incoming_dependencies: [], outgoing_dependencies: [], analyzed_package.dependencies: []). Hub-like Modularization requires an abstraction to have dependencies with a large number of other abstractions; this class has none."
    },
    {
        "identifier": "com.github.javaparser.ast.modules.ModuleRequiresDirective",
        "detection": true,
        "justification": "ModuleRequiresDirective has a large number of both incoming and outgoing relationships. Outgoing: it directly depends on 9 diverse core abstractions (com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.expr.Name, com.github.javaparser.metamodel.ModuleRequiresDirectiveMetaModel, com.github.javaparser.ast.NodeList, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.TokenRange, com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.ast.Node, com.github.javaparser.ast.visitor.GenericVisitor). Incoming: it is depended upon by many (22) other classes across the system (examples include numerous visitor implementations such as DefaultVisitorAdapter, VoidVisitor, GenericVisitor, HashCodeVisitor, EqualsVisitor, ModifierVisitor, CloneVisitor, various PrettyPrint visitors, GeneratedJavaParser, ModifierValidator, ModuleDirective, NodeFinderVisitor, etc.). Combined this yields on the order of 30+ distinct dependency relationships (many visitors, printers, parser, validator and meta-model components), matching the Hub-like Modularization smell (an abstraction acting as a hub with high fan-in and fan-out)."
    },
    {
        "identifier": "com.github.javaparser.generator.core.quality.NotNullGenerator",
        "detection": false,
        "justification": "NotNullGenerator has many outgoing dependencies (10 direct dependencies: com.github.javaparser.ast.body.Parameter, com.github.javaparser.StaticJavaParser, com.github.javaparser.ast.body.ConstructorDeclaration, com.github.javaparser.ast.stmt.BlockStmt, com.github.javaparser.ast.CompilationUnit, com.github.javaparser.ast.body.MethodDeclaration, com.github.javaparser.ast.NodeList, com.github.javaparser.ast.expr.MethodCallExpr, com.github.javaparser.utils.SourceRoot, com.github.javaparser.ast.stmt.Statement) but no incoming dependencies (incoming_dependencies is empty). Hub-like Modularization requires an abstraction to have both many incoming and many outgoing connections; because there are zero incoming dependencies, this class does not meet the hub-like smell criteria."
    },
    {
        "identifier": "com.github.javaparser.ast.validator.language_level_validations.chunks.NoUnderscoresInIntegerLiteralsValidator",
        "detection": false,
        "justification": "Hub-like Modularization requires an abstraction to have dependencies both incoming and outgoing with a large number of other abstractions. This class has 0 incoming dependencies and 4 outgoing dependencies (com.github.javaparser.ast.expr.LiteralStringValueExpr, com.github.javaparser.ast.expr.LongLiteralExpr, com.github.javaparser.ast.validator.ProblemReporter, com.github.javaparser.ast.expr.IntegerLiteralExpr). Because incoming dependencies are absent and the outgoing set is small, it does not meet the hub-like smell criteria."
    },
    {
        "identifier": "com.github.javaparser.utils.SourceRoot.Callback",
        "detection": false,
        "justification": "The class has 0 outgoing dependencies and only 1 incoming dependency (from com.github.javaparser.utils.SourceRoot). Hub-like Modularization requires an abstraction to have dependencies with a large number of other abstractions (many incoming and/or outgoing); this class does not meet that criterion."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.declarators.NoSymbolDeclarator",
        "detection": false,
        "justification": "NoSymbolDeclarator has only 1 outgoing dependency (com.github.javaparser.resolution.TypeSolver) and 0 incoming dependencies. Hub-like Modularization requires an abstraction to have many incoming and outgoing dependencies; because this class has neither many outgoing nor any incoming dependencies, it is not a hub."
    },
    {
        "identifier": "com.github.javaparser.metamodel.TextBlockLiteralExprMetaModel",
        "detection": false,
        "justification": "TextBlockLiteralExprMetaModel has no outgoing dependencies (outgoing_dependencies = []). It has only two incoming dependencies: com.github.javaparser.ast.expr.TextBlockLiteralExpr and com.github.javaparser.metamodel.JavaParserMetaModel. A hub-like modularization requires an abstraction to have many incoming and outgoing relationships; here both directions are minimal (0 outgoing, 2 incoming), so this class is not a hub."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserVariableDeclaration",
        "detection": false,
        "justification": "The class has a limited number of direct outgoing dependencies (6): com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade, com.github.javaparser.resolution.types.ResolvedType, com.github.javaparser.ast.body.VariableDeclarator, com.github.javaparser.resolution.TypeSolver, com.github.javaparser.ast.expr.VariableDeclarationExpr, and com.github.javaparser.resolution.Navigator. It also has only two incoming dependents: com.github.javaparser.symbolsolver.JavaSymbolSolver and com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserSymbolDeclaration. Because both fan-in (2) and fan-out (6) are small in the provided data, this does not constitute a hub-like modularization (which requires a large number of both incoming and outgoing dependencies)."
    },
    {
        "identifier": "(default package).StackOverflowTestCase",
        "detection": false,
        "justification": "The class has outgoing dependencies to (default package).C and (default package).ConstantA (2 outgoing), but the incoming_dependencies list is empty (0 incoming). Hub-like Modularization requires an abstraction to have both many incoming and outgoing relationships; this class lacks incoming links and has only two outgoing links, so it does not qualify as a hub."
    },
    {
        "identifier": "com.github.javaparser.ast.stmt.AssertStmt",
        "detection": true,
        "justification": "AssertStmt has a high number of incoming dependencies (22 distinct clients) and multiple outgoing dependencies (9 distinct suppliers). Incoming dependents include many visitor and utility classes (e.g., com.github.javaparser.symbolsolver.javaparsermodel.DefaultVisitorAdapter, com.github.javaparser.symbolsolver.resolution.typeinference.ControlFlowLogic, com.github.javaparser.ast.stmt.Statement, com.github.javaparser.ast.visitor.VoidVisitor, HashCodeVisitor, PrettyPrintVisitor, DefaultPrettyPrinterVisitor, GeneratedJavaParser, CloneVisitor, etc.), showing many other abstractions depend on AssertStmt. Outgoing dependencies include core abstractions and cross-cutting meta/types (com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.metamodel.AssertStmtMetaModel, com.github.javaparser.Range, com.github.javaparser.ast.expr.Expression, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.TokenRange, com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.ast.Node, com.github.javaparser.ast.visitor.GenericVisitor). Because AssertStmt both depends on multiple core/meta abstractions and is depended upon by a large set of other modules, it functions as a hub and meets the criteria for Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.metamodel.PrimitiveTypeMetaModel",
        "detection": false,
        "justification": "PrimitiveTypeMetaModel has only 1 outgoing dependency (com.github.javaparser.metamodel.PropertyMetaModel) and only 2 distinct incoming dependents (com.github.javaparser.ast.type.PrimitiveType and com.github.javaparser.metamodel.JavaParserMetaModel). Although JavaParserMetaModel itself references many meta-model classes (including PrimitiveTypeMetaModel), that still counts as a single incoming abstraction. The numbers of incoming and outgoing dependencies are low (incoming=2, outgoing=1), so this class is not a hub-like module."
    },
    {
        "identifier": "com.github.javaparser.javasymbolsolver.javassist_symbols.main_jar.SubInterfaceOwnJar",
        "detection": false,
        "justification": "The class has 0 incoming dependencies and 0 outgoing dependencies (incoming_dependencies: [], outgoing_dependencies: []), so it does not have dependencies with a large number of other abstractions and therefore does not exhibit Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.ast.validator.language_level_validations.Java11Validator",
        "detection": false,
        "justification": "Java11Validator has only one outgoing dependency (com.github.javaparser.ast.validator.Validator) and no incoming dependencies. The Hub-like Modularization smell requires an abstraction to have many incoming and outgoing dependencies; the provided data shows neither a large number of outgoing dependencies nor any incoming dependencies. While Validator itself depends on ProblemReporter and Node, those are indirect and do not make Java11Validator a hub."
    },
    {
        "identifier": "com.github.javaparser.metamodel.StringLiteralExprMetaModel",
        "detection": false,
        "justification": "Not detected: the class has 0 outgoing dependencies and only 2 incoming dependencies (from com.github.javaparser.ast.expr.StringLiteralExpr and com.github.javaparser.metamodel.JavaParserMetaModel). Hub-like modularization requires an abstraction to have dependencies (incoming and outgoing) with a large number of other abstractions; this class does not exhibit a large number in either direction."
    },
    {
        "identifier": "foo.bar.AClass",
        "detection": false,
        "justification": "foo.bar.AClass has 0 incoming dependencies and 2 outgoing dependencies (foo.bar.AnInterface, foo.bar.BinaryExpr). Hub-like Modularization requires an abstraction to have many incoming and outgoing dependency relationships; the absence of incoming dependencies and only two outgoing dependencies mean the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.generator.core.node.TypeCastingGenerator",
        "detection": false,
        "justification": "TypeCastingGenerator has multiple outgoing dependencies (StaticJavaParser, BaseNodeMetaModel, CompilationUnit, ClassOrInterfaceDeclaration, MethodDeclaration, JavaParserMetaModel, Pair, SourceRoot) but has no incoming dependencies. Hub-like Modularization requires an abstraction to have both many incoming and outgoing dependencies; the absence of incoming dependencies prevents this class from being a hub."
    },
    {
        "identifier": "com.github.javaparser.resolution.types.parametrization.ResolvedTypeParametersMap.Builder",
        "detection": false,
        "justification": "The class has 0 outgoing dependencies and only 1 incoming dependency (from com.github.javaparser.resolution.types.parametrization.ResolvedTypeParametersMap). Hub-like Modularization requires many incoming and outgoing links to many other abstractions; the provided metrics show low counts, so this is not a hub."
    },
    {
        "identifier": "com.github.javaparser.ast.nodeTypes.NodeWithIdentifier",
        "detection": false,
        "justification": "NodeWithIdentifier has only one direct outgoing dependency (com.github.javaparser.utils.Utils) and zero incoming dependencies. Hub-like Modularization is characterized by an abstraction having many incoming and outgoing dependencies; this class has a single direct connection and therefore does not meet that criterion. (Although Utils has its own dependencies — UnaryExpr, LineSeparator, Node, Provider — those are indirect and, per the isolation constraint, are not counted toward NodeWithIdentifier's direct coupling.)"
    },
    {
        "identifier": "com.github.javaparser.resolution.Resolvable",
        "detection": false,
        "justification": "The class has 0 incoming dependencies and 0 outgoing dependencies (both dependency lists are empty), so it does not exhibit hub-like modularization which requires many incoming and outgoing connections."
    },
    {
        "identifier": "(default package).Issue300",
        "detection": false,
        "justification": "No incoming or outgoing dependencies: incoming_dependencies = [], outgoing_dependencies = [], dependencies = []. Hub-like Modularization requires an abstraction to have many incoming and outgoing dependencies, which Issue300 does not have."
    },
    {
        "identifier": "foo.bar.BinaryExpr",
        "detection": false,
        "justification": "BinaryExpr has 0 outgoing dependencies and only 2 incoming dependencies (from foo.bar.AClass and foo.bar.differentpackage.AClass). Hub-like Modularization requires an abstraction to have many incoming and many outgoing dependencies; here outgoing = 0 and incoming is small, so the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.ast.nodeTypes.NodeWithJavadoc",
        "detection": false,
        "justification": "NodeWithJavadoc has no incoming dependencies (incoming_dependencies is empty) and only four outgoing dependencies (com.github.javaparser.javadoc.Javadoc, com.github.javaparser.ast.Node, com.github.javaparser.ast.comments.Comment, com.github.javaparser.ast.comments.JavadocComment). Hub-like Modularization requires an abstraction to have both many incoming and many outgoing relationships. Given 0 incoming and only 4 outgoing, this class does not exhibit a hub-like modularization smell."
    },
    {
        "identifier": "com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration.Bound",
        "detection": false,
        "justification": "The class has only one outgoing dependency: com.github.javaparser.resolution.types.ResolvedType, and zero incoming dependencies. Hub-like Modularization requires an abstraction to have many incoming and many outgoing dependencies; the analyzed class does not show the required fan-in/fan-out. (Although ResolvedType itself depends on multiple types, the analyzed class in isolation does not.)"
    },
    {
        "identifier": "com.github.javaparser.resolution.cache.Cache",
        "detection": false,
        "justification": "The Cache class has only 1 outgoing dependency (com.github.javaparser.resolution.cache.CacheStats) and only 2 incoming dependents (com.github.javaparser.symbolsolver.resolution.typesolvers.JavaParserTypeSolver and com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver). Although the incoming classes have many other dependencies, the Cache itself is connected to a small number of other abstractions, so it does not constitute a hub-like modularization."
    },
    {
        "identifier": "implements_duplicate.A.DuplicateTypeName",
        "detection": false,
        "justification": "The class has 0 incoming_dependencies and 0 outgoing_dependencies (both are empty arrays). Hub-like Modularization requires many incoming and outgoing dependencies; with no incoming or outgoing dependencies, this class is not a hub."
    },
    {
        "identifier": "com.github.javaparser.javasymbolsolver.javassist_symbols.main_jar.InterfaceUserIncludedJar",
        "detection": false,
        "justification": "The analyzed_package.dependencies array is empty and both incoming_dependencies and outgoing_dependencies are empty, indicating no incoming or outgoing links to other abstractions. Therefore the class does not have dependencies with a large number of other abstractions and is not a hub."
    },
    {
        "identifier": "com.github.javaparser.metamodel.BodyDeclarationMetaModel",
        "detection": false,
        "justification": "BodyDeclarationMetaModel has a low outgoing dependency set (1 outgoing: com.github.javaparser.metamodel.PropertyMetaModel) and a small incoming set (2 incoming references in the provided data: com.github.javaparser.ast.body.BodyDeclaration and com.github.javaparser.metamodel.JavaParserMetaModel). Because it does not exhibit a large number of both incoming and outgoing dependencies, it does not qualify as a hub-like modularization smell."
    },
    {
        "identifier": "com.github.javaparser.ast.stmt.Statement",
        "detection": true,
        "justification": "The class has a large number of outgoing dependencies (26 distinct dependencies including many concrete statement types: ExpressionStmt, ForStmt, ExplicitConstructorInvocationStmt, ThrowStmt, YieldStmt, SynchronizedStmt, DoStmt, BlockStmt, LabeledStmt, ReturnStmt, LocalClassDeclarationStmt, IfStmt, AssertStmt, UnparsableStmt, ContinueStmt, TryStmt, SwitchStmt, LocalRecordDeclarationStmt, WhileStmt, ForEachStmt, EmptyStmt, BreakStmt; plus meta/utility types JavaParserMetaModel, StatementMetaModel, TokenRange, Range). It also has many incoming dependencies (25 distinct clients across multiple packages) such as symbolsolver classes (NormalCompletionVisitor, StatementContext, BlockStmtContext, ControlFlowLogic, ExpressionCompatibleWithType), AST node types and visitors (NodeWithBody, NodeWithStatements, ModifierVisitor, CloneVisitor), parser and generator classes (JavaParser, StaticJavaParser, GeneratedJavaParser, GeneratedJavaParserBase, JavaParserAdapter, AbstractGenerator, NotNullGenerator), and printer classes (PrettyPrintVisitor, DefaultPrettyPrinterVisitor). The class therefore has both many incoming and many outgoing links spanning multiple packages and responsibilities, matching the Hub-like Modularization smell."
    },
    {
        "identifier": "com.github.javaparser.ast.expr.SingleMemberAnnotationExpr",
        "detection": true,
        "justification": "SingleMemberAnnotationExpr exhibits hub-like modularization: it has a relatively large number of incoming dependencies (22 distinct clients reference it — e.g. many visitor classes such as com.github.javaparser.ast.visitor.VoidVisitor, GenericVisitor, VoidVisitorAdapter, ModifierVisitor, HashCodeVisitor, EqualsVisitor, PrettyPrintVisitor, DefaultPrettyPrinterVisitor, NodeFinderVisitor, GeneratedJavaParser) and a non-trivial set of outgoing dependencies (11 targets it directly depends on — e.g. com.github.javaparser.ast.Node, com.github.javaparser.ast.expr.Expression, com.github.javaparser.ast.expr.Name, com.github.javaparser.ast.expr.NameExpr, com.github.javaparser.Range, com.github.javaparser.TokenRange, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.metamodel.SingleMemberAnnotationExprMetaModel). The combination of many incoming connections from varied visitors/printers/parsers and multiple outgoing ties to core AST/metamodel/token types matches the definition of a hub: an abstraction with dependencies in both directions with a large number of other abstractions."
    },
    {
        "identifier": "com.github.javaparser.metamodel.ModuleExportsDirectiveMetaModel",
        "detection": false,
        "justification": "ModuleExportsDirectiveMetaModel has low fan-out (1 outgoing dependency: com.github.javaparser.metamodel.PropertyMetaModel) and low fan-in (2 incoming dependents: com.github.javaparser.ast.modules.ModuleExportsDirective and com.github.javaparser.metamodel.JavaParserMetaModel). Because it does not have dependencies both incoming and outgoing with a large number of other abstractions, it does not exhibit the Hub-like Modularization smell."
    },
    {
        "identifier": "com.github.javaparser.ast.nodeTypes.modifiers.NodeWithStrictfpModifier",
        "detection": false,
        "justification": "Hub-like Modularization requires the abstraction to have a large number of both incoming and outgoing dependencies. For this class, incoming_dependencies = 0 and outgoing_dependencies = 0 (both empty), so it does not exhibit hub-like modularization."
    },
    {
        "identifier": "com.github.javaparser.ast.CompilationUnit",
        "detection": true,
        "justification": "CompilationUnit has a large number of outgoing dependencies (25 distinct abstractions, e.g. com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.expr.Name, com.github.javaparser.ast.body.TypeDeclaration, com.github.javaparser.ast.Node, com.github.javaparser.printer.Printer, com.github.javaparser.metamodel.JavaParserMetaModel) and a very large number of incoming dependencies (69 distinct abstractions depend on it, including com.github.javaparser.symbolsolver.JavaSymbolSolver, com.github.javaparser.JavaParser, com.github.javaparser.StaticJavaParser, many visitor classes such as com.github.javaparser.ast.visitor.VoidVisitor/GenericVisitor/EqualsVisitor/HashCodeVisitor, numerous generator classes, serializer/deserializer, and tooling classes). The presence of many incoming and outgoing links to many different abstractions identifies CompilationUnit as a hub-like module (central abstraction with widespread coupling)."
    },
    {
        "identifier": "com.github.javaparser.UnicodeEscapeProcessingProvider.DeltaInfo",
        "detection": false,
        "justification": "Both incoming and outgoing dependencies are empty (0 incoming, 0 outgoing). Hub-like Modularization requires an abstraction to have dependencies with a large number of other abstractions; this class has no dependencies in isolation, so it is not a hub."
    },
    {
        "identifier": "com.github.javaparser.ast.expr.ArrayCreationExpr",
        "detection": true,
        "justification": "ArrayCreationExpr shows hub-like modularization: it has a large number of both outgoing and incoming dependencies. Outgoing: 13 distinct dependencies (examples: com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.metamodel.ArrayCreationExprMetaModel, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.ast.NodeList, com.github.javaparser.ast.Node, com.github.javaparser.ast.type.ArrayType, com.github.javaparser.ast.type.Type, com.github.javaparser.ast.expr.ArrayInitializerExpr, com.github.javaparser.Range, com.github.javaparser.TokenRange, com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.StaticJavaParser). Incoming: 23 distinct dependents reference it (examples: symbolsolver DefaultVisitorAdapter and TypeExtractor, many visitor classes such as VoidVisitor, HashCodeVisitor, EqualsVisitor, ModifierVisitor, CloneVisitor, GenericVisitor and their adapters/variants, GeneratedJavaParser / GeneratedJavaParserBase, PrettyPrintVisitor / DefaultPrettyPrinterVisitor, NodeFinderVisitor, Expression). Combined this is 36 other abstractions linked to ArrayCreationExpr, indicating it acts as a central hub connecting many parts of the system and therefore exhibits the Hub-like Modularization smell."
    },
    {
        "identifier": "(default package).Trie.Node",
        "detection": false,
        "justification": "Incoming dependencies: 0 (incoming_dependencies = []). Outgoing dependencies: 0 (outgoing_dependencies = []). Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; with zero incoming and zero outgoing dependencies, Trie.Node does not meet this smell."
    },
    {
        "identifier": "com.github.javaparser.resolution.declarations.HasAccessSpecifier",
        "detection": false,
        "justification": "HasAccessSpecifier has only 1 outgoing dependency (com.github.javaparser.ast.AccessSpecifier) and 0 incoming dependencies. Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; the provided data does not meet that condition."
    },
    {
        "identifier": "com.github.javaparser.ast.validator.VisitorValidator",
        "detection": false,
        "justification": "VisitorValidator has no incoming dependencies (incoming_dependencies is empty) and only two outgoing dependencies: com.github.javaparser.ast.validator.ProblemReporter and com.github.javaparser.ast.Node. Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies. Because incoming dependencies = 0 and outgoing dependencies = 2 (only two distinct abstractions), VisitorValidator does not meet the hub-like criteria. Note: the many dependencies listed for com.github.javaparser.ast.Node are dependencies of Node itself and do not increase VisitorValidator's incoming/outgoing connectivity."
    },
    {
        "identifier": "com.github.javaparser.utils.TypeUtils",
        "detection": false,
        "justification": "Type com.github.javaparser.utils.TypeUtils has 0 outgoing dependencies and only 2 incoming dependencies (from com.github.javaparser.symbolsolver.reflectionmodel.ReflectionMethodDeclaration and com.github.javaparser.resolution.types.ResolvedPrimitiveType). Hub-like Modularization requires an abstraction to have both many incoming and many outgoing dependencies; this class lacks outgoing connections and has a small number of incoming connections, so it is not a hub."
    },
    {
        "identifier": "com.github.javaparser.resolution.declarations.AssociableToAST",
        "detection": false,
        "justification": "No hub-like modularization: incoming_dependencies = [] and outgoing_dependencies = []. The class has zero incoming and zero outgoing dependencies, so it does not depend on or is depended on by a large number of other abstractions."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.resolution.typeinference.InferenceVariableSubstitution",
        "detection": false,
        "justification": "Incoming dependencies: 6 distinct classes reference InferenceVariableSubstitution (Bound, SubtypeOfBound, CapturesBound, SameAsBound, FalseBound, ThrowsBound). Outgoing dependencies: only 2 distinct classes are depended on by InferenceVariableSubstitution (InferenceVariable, ResolvedType). Hub-like Modularization requires an abstraction to have both many incoming and many outgoing dependencies with a large number of other abstractions. While this class has several incoming references, its outgoing dependency set is small (2), so it does not exhibit a hub-like modularization smell."
    },
    {
        "identifier": "(default package).Base",
        "detection": false,
        "justification": "The class has 0 incoming dependencies and 0 outgoing dependencies (incoming_dependencies: [], outgoing_dependencies: []). Hub-like Modularization requires an abstraction to have dependencies with a large number of other abstractions; with both dependency lists empty, the smell is not present."
    },
    {
        "identifier": "com.github.javaparser.Problem",
        "detection": false,
        "justification": "The class has only 2 outgoing dependencies (com.github.javaparser.TokenRange, com.github.javaparser.utils.LineSeparator) and 1 incoming dependency (com.github.javaparser.ParseResult), for a total of 3 distinct collaborating abstractions. This small number of incoming and outgoing connections does not indicate a hub-like modularization."
    },
    {
        "identifier": "main.Parent.MyEnum",
        "detection": false,
        "justification": "The class has 0 incoming dependencies and 0 outgoing dependencies (both lists are empty). Hub-like Modularization requires an abstraction to have dependencies with a large number of other abstractions; this class has none, so it is not a hub."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.cache.DefaultCacheStats",
        "detection": false,
        "justification": "Hub-like Modularization requires an abstraction to have many incoming and outgoing dependencies. This class has only one outgoing dependency (com.github.javaparser.resolution.cache.CacheStats) and no incoming dependencies, so it does not meet the 'hub-like' criteria."
    },
    {
        "identifier": "com.github.javaparser.printer.concretesyntaxmodel.CsmComment",
        "detection": false,
        "justification": "CsmComment has only 3 outgoing dependencies (com.github.javaparser.ast.comments.Comment, com.github.javaparser.printer.SourcePrinter, com.github.javaparser.ast.Node) and a single incoming dependency (com.github.javaparser.printer.concretesyntaxmodel.CsmOrphanCommentsEnding). Hub-like Modularization requires an abstraction to have dependencies (both incoming and outgoing) with a large number of other abstractions; the provided counts are low, so the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.generator.Generator",
        "detection": false,
        "justification": "Generator has only outgoing dependencies (6: com.github.javaparser.ast.body.ClassOrInterfaceDeclaration, com.github.javaparser.ast.body.CallableDeclaration, com.github.javaparser.ast.expr.Expression, com.github.javaparser.ast.body.MethodDeclaration, com.github.javaparser.ast.NodeList, com.github.javaparser.utils.SourceRoot) and zero incoming dependencies. Hub-like Modularization requires an abstraction to have dependencies both incoming and outgoing with many other abstractions; the absence of incoming dependencies prevents this class from being a hub."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.resolution.typeinference.InferenceVariable",
        "detection": false,
        "justification": "InferenceVariable has many incoming dependencies (10 distinct clients: Bound, TypeInference, Instantiation, BoundSet, BoundSet.VariableDependency, InferenceVariableSubstitution, ProperLowerBound, ProperUpperBound, ExpressionCompatibleWithType, ThrowsBound) but only 2 outgoing dependencies (com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration and com.github.javaparser.resolution.types.ResolvedType). Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; here the outgoing fan-out is very small, so the class is not a hub."
    },
    {
        "identifier": "com.github.javaparser.printer.YamlPrinter",
        "detection": false,
        "justification": "YamlPrinter has 0 incoming dependencies (incoming_dependencies is empty) and 3 direct outgoing dependencies: com.github.javaparser.ast.NodeList, com.github.javaparser.metamodel.NodeMetaModel, com.github.javaparser.ast.Node. Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies. Although one outgoing target (com.github.javaparser.ast.Node) itself lists many dependencies (e.g., PrinterConfiguration, Range, Comment, TokenRange, visitors, metamodel classes, etc.), the analyzed class lacks incoming links and has only three direct outgoing links, so it does not qualify as a hub."
    },
    {
        "identifier": "com.github.javaparser.utils.VisitorList.EqualsHashcodeOverridingFacade",
        "detection": false,
        "justification": "Not a hub: the class has 0 incoming dependencies and only 1 outgoing dependency (to com.github.javaparser.utils.VisitorList). Hub-like modularization requires dependencies both incoming and outgoing with a large number of other abstractions, which is not met here."
    },
    {
        "identifier": "com.github.javaparser.ast.visitor.GenericVisitor",
        "detection": true,
        "justification": "GenericVisitor has hub-like coupling: it depends on a very large number of distinct abstractions (outgoing dependencies) across many packages — e.g. com.github.javaparser.ast.expr.UnaryExpr, TextBlockLiteralExpr, MethodCallExpr, ClassExpr, NameExpr; com.github.javaparser.ast.stmt.ReturnStmt, IfStmt, ForStmt, SwitchStmt, TryStmt; com.github.javaparser.ast.body.MethodDeclaration, VariableDeclarator, ClassOrInterfaceDeclaration, RecordDeclaration, EnumDeclaration; com.github.javaparser.ast.type.ClassOrInterfaceType, ArrayType, WildcardType, PrimitiveType, UnionType; and many comment/module/utility types — demonstrating broad outgoing reach. At the same time many other abstractions depend on GenericVisitor (incoming dependencies) — e.g. many AST node classes (CompilationUnit, Node, MethodDeclaration, VariableDeclarator, ExpressionStmt, ReturnStmt, IfStmt, ForStmt, TryStmt, many literal/expr/node types), tooling classes (com.github.javaparser.symbolsolver.resolution.typeinference.ControlFlowLogic, VisitorMap/VisitorList/VisitorSet), and numerous comment/module classes all list GenericVisitor as a dependency. The presence of numerous incoming and outgoing links to a wide variety of unrelated classes and packages indicates GenericVisitor functions as a central hub and therefore exhibits the Hub-like Modularization smell."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.utils.FileUtils",
        "detection": false,
        "justification": "FileUtils has 0 outgoing dependencies and only 1 incoming dependency (from com.github.javaparser.symbolsolver.resolution.typesolvers.JavaParserTypeSolver). Hub-like Modularization requires an abstraction to have dependencies with a large number of other abstractions (many incoming and/or outgoing links); these counts do not meet that criterion."
    },
    {
        "identifier": "com.github.javaparser.metamodel.BinaryExprMetaModel",
        "detection": false,
        "justification": "BinaryExprMetaModel has only 1 outgoing dependency (com.github.javaparser.metamodel.PropertyMetaModel) and only 2 incoming dependencies (com.github.javaparser.ast.expr.BinaryExpr and com.github.javaparser.metamodel.JavaParserMetaModel). Hub-like Modularization is characterized by an abstraction having many incoming and many outgoing connections; the provided data shows small counts on both sides, so this class does not exhibit a hub-like modularization smell."
    },
    {
        "identifier": "com.github.javaparser.StringProvider",
        "detection": false,
        "justification": "No hub-like modularization: the class has 0 outgoing dependencies and 0 incoming dependencies (both dependency lists are empty), so it does not have dependencies with a large number of other abstractions."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.contexts.AbstractMethodLikeDeclarationContext",
        "detection": false,
        "justification": "This class has 0 incoming dependencies and 6 outgoing dependencies. Outgoing dependencies: com.github.javaparser.resolution.model.SymbolReference, com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade, com.github.javaparser.resolution.TypeSolver, com.github.javaparser.symbolsolver.javaparsermodel.contexts.AbstractJavaParserContext, com.github.javaparser.resolution.SymbolDeclarator, com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFactory. Hub-like Modularization requires an abstraction to have dependencies both incoming and outgoing with a large number of other abstractions; because there are no incoming dependencies (0), this class does not meet the hub-like criterion."
    },
    {
        "identifier": "com.github.javaparser.metamodel.NullLiteralExprMetaModel",
        "detection": false,
        "justification": "NullLiteralExprMetaModel has 0 outgoing dependencies (no listed outgoing_dependencies) and only 2 incoming dependents: com.github.javaparser.ast.expr.NullLiteralExpr and com.github.javaparser.metamodel.JavaParserMetaModel. Hub-like Modularization requires an abstraction to have many incoming and outgoing connections; the provided data shows neither a large number of incoming dependents nor any outgoing dependencies for this class."
    },
    {
        "identifier": "com.github.javaparser.resolution.model.typesystem.LazyType",
        "detection": false,
        "justification": "LazyType has a limited set of outgoing dependencies (7 distinct abstractions: ResolvedReferenceType, ResolvedTypeVariable, ResolvedTypeParameterDeclaration, ResolvedType, ResolvedPrimitiveType, ResolvedWildcard, ResolvedArrayType) and only 2 incoming dependents are shown (TypeExtractor and ResolvedReferenceType). Although there is a two-way link with ResolvedReferenceType, the overall number of incoming and outgoing connections is not large enough to qualify as a hub-like module under the provided data."
    },
    {
        "identifier": "com.github.javaparser.ast.validator.ProblemReporter",
        "detection": false,
        "justification": "ProblemReporter has many incoming dependencies (15 distinct classes depend on it: Validator, TreeVisitorValidator, RecordAsTypeIdentifierNotAllowed, SingleNodeTypeValidator, TypedValidator, VisitorValidator, ReservedKeywordValidator, Validators, Java22Validator, ModifierValidator, RecordDeclarationValidator, VarValidator, NoUnderscoresInIntegerLiteralsValidator, NoBinaryIntegerLiteralsValidator, UnderscoreKeywordValidator) but only 3 outgoing dependencies (UpgradeJavaMessage, NodeWithTokenRange, TokenRange). Hub-like Modularization requires a large number of both incoming and outgoing dependencies; here the outgoing fan-out is small, so the class is not a hub-like abstraction."
    },
    {
        "identifier": "com.github.javaparser.resolution.model.SymbolReference",
        "detection": false,
        "justification": "SymbolReference has a very large number of incoming dependencies (69 distinct classes in the provided list, e.g. com.github.javaparser.symbolsolver.JavaSymbolSolver, com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade, com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserClassDeclaration, com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver, com.github.javaparser.symbolsolver.javaparsermodel.contexts.MethodCallExprContext, com.github.javaparser.symbolsolver.resolution.typeinference.TypeHelper, com.github.javaparser.symbolsolver.javassistmodel.JavassistClassDeclaration, com.github.javaparser.symbolsolver.resolution.SymbolSolver, com.github.javaparser.resolution.TypeSolver), but it has zero outgoing dependencies in the provided data. The definition of Hub-like Modularization requires an abstraction to have dependencies both incoming and outgoing with a large number of other abstractions. Because SymbolReference lacks outgoing dependencies (outgoing = 0), it does not meet the definition and therefore is not detected as Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.printer.concretesyntaxmodel.CsmOrphanCommentsEnding",
        "detection": false,
        "justification": "The class has 0 incoming dependencies and 4 outgoing dependencies (com.github.javaparser.ast.comments.Comment, com.github.javaparser.printer.concretesyntaxmodel.CsmComment, com.github.javaparser.printer.SourcePrinter, com.github.javaparser.ast.Node). Hub-like Modularization requires an abstraction to have both a large number of incoming and outgoing dependencies; here incoming dependencies are absent and the direct outgoing set is small, so the hub-like smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.ast.expr.TypePatternExpr",
        "detection": true,
        "justification": "TypePatternExpr exhibits hub-like modularization: it has a large number of incoming dependents (26 distinct classes reference it, e.g. com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.printer.PrettyPrintVisitor, com.github.javaparser.GeneratedJavaParser, com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserSymbolDeclaration, com.github.javaparser.symbolsolver.javaparsermodel.declarators.TypePatternSymbolDeclarator, com.github.javaparser.symbolsolver.javaparsermodel.contexts.AbstractJavaParserContext) and multiple outgoing dependencies (10 distinct abstractions: com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.NodeList, com.github.javaparser.ast.expr.SimpleName, com.github.javaparser.TokenRange, com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.ast.type.Type, com.github.javaparser.ast.Node, com.github.javaparser.metamodel.TypePatternExprMetaModel, com.github.javaparser.ast.visitor.GenericVisitor). The combination of high fan-in (many modules rely on TypePatternExpr) together with non-trivial fan-out (it depends on multiple core AST/meta/visitor types) indicates it functions as a central hub connecting many other abstractions."
    },
    {
        "identifier": "foo.IB",
        "detection": false,
        "justification": "The class foo.IB has 0 incoming dependencies and 0 outgoing dependencies (incoming_dependencies, outgoing_dependencies, and analyzed_package.dependencies are all empty). Hub-like Modularization requires an abstraction to have many incoming and outgoing dependencies, so the smell is not present."
    },
    {
        "identifier": "com.github.javaparser.TokenRange",
        "detection": false,
        "justification": "TokenRange has very high fan-in (referenced by 127 different classes in the provided data — examples include com.github.javaparser.JavaToken, com.github.javaparser.ast.Node, com.github.javaparser.ast.expr.Expression, com.github.javaparser.ast.stmt.Statement, com.github.javaparser.ast.body.MethodDeclaration, com.github.javaparser.ast.type.Type, com.github.javaparser.ast.CompilationUnit, etc.). However, its fan-out is minimal: it only depends on one abstraction (com.github.javaparser.JavaToken). Hub-like Modularization requires an abstraction to have dependencies with a large number of other abstractions in both directions (many incoming and many outgoing). Because TokenRange's outgoing dependencies are not large, the hub-like modularization smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserEnumDeclaration.ValueOfMethod",
        "detection": false,
        "justification": "Not a hub: incoming_dependencies is empty (no classes depend on this class). Outgoing dependencies are limited to 3 distinct abstractions: com.github.javaparser.ast.AccessSpecifier, com.github.javaparser.resolution.TypeSolver, and com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserEnumDeclaration. Hub-like Modularization requires an abstraction to have dependencies (both incoming and outgoing) with a large number of other abstractions; this class has zero incoming and only three outgoing, so it does not meet the smell criteria."
    },
    {
        "identifier": "com.github.javaparser.resolution.model.Value",
        "detection": false,
        "justification": "Value has only 2 direct outgoing dependencies (com.github.javaparser.resolution.declarations.ResolvedValueDeclaration, com.github.javaparser.resolution.types.ResolvedType) while it has 6 incoming dependents (StatementContext, LambdaExprContext, ClassOrInterfaceDeclarationContext, TryWithResourceContext, RecordDeclarationContext, Context). Hub-like modularization requires an abstraction to have a large number of both incoming and outgoing dependencies. Here the incoming set is moderate but the outgoing set is small (2), so Value does not meet the \"hub\" criterion. (Note: ResolvedType—one of the two outgoing dependencies—itself lists many dependent types in the provided data, but Value's direct outgoing fan-out remains low.)"
    },
    {
        "identifier": "com.github.javaparser.Token",
        "detection": false,
        "justification": "Token has 0 outgoing dependencies (no outgoing edges) and 7 incoming dependencies (referenced by: JavaToken, GeneratedJavaParserBase, GeneratedJavaParserTokenManagerBase, GeneratedJavaParser, GeneratedJavaParser.JJCalls, GeneratedJavaParserTokenManager, ParseException). Hub-like Modularization requires an abstraction to have dependencies with a large number of other abstractions both incoming and outgoing; because Token has no outgoing dependencies, the criterion is not met."
    },
    {
        "identifier": "com.github.javaparser.ast.NodeList.NodeListIterator",
        "detection": false,
        "justification": "The class has 0 incoming dependencies and 0 outgoing dependencies (both dependency lists are empty). Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; this class does not meet that condition."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.contexts.CatchClauseContext",
        "detection": false,
        "justification": "Hub-like Modularization not detected because there are no incoming dependencies (incoming_dependencies is empty), so the class does not have both many incoming and outgoing ties. Although CatchClauseContext has multiple outgoing dependencies (7 distinct targets: com.github.javaparser.resolution.model.SymbolReference, com.github.javaparser.resolution.TypeSolver, com.github.javaparser.resolution.SymbolDeclarator, com.github.javaparser.symbolsolver.javaparsermodel.contexts.AbstractJavaParserContext, com.github.javaparser.ast.Node, com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFactory, com.github.javaparser.ast.stmt.CatchClause), the absence of incoming dependencies means it is not a hub as defined."
    },
    {
        "identifier": "com.github.javaparser.metamodel.FieldAccessExprMetaModel",
        "detection": false,
        "justification": "The class has only 2 incoming dependencies (com.github.javaparser.ast.expr.FieldAccessExpr and com.github.javaparser.metamodel.JavaParserMetaModel) and a single outgoing dependency (com.github.javaparser.metamodel.PropertyMetaModel). Although JavaParserMetaModel itself references many meta-model classes, it constitutes one incoming dependency to FieldAccessExprMetaModel. The direct incoming/outgoing counts are low, so it does not meet the 'large number of other abstractions' criterion for Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.ast.body.EnumDeclaration",
        "detection": true,
        "justification": "EnumDeclaration has a high number of incoming and outgoing dependencies. Incoming: ~31 distinct clients depend on it (examples: many visitor implementations and adapters such as com.github.javaparser.ast.visitor.VoidVisitor, GenericVisitor, VoidVisitorAdapter, ModifierVisitor, EqualsVisitor, HashCodeVisitor, PrettyPrintVisitor/DefaultPrettyPrinterVisitor, GeneratedJavaParser, Navigator, AbstractGenerator, PropertyGenerator, TokenKindGenerator, symbol-solver adapters like JavaParserEnumDeclaration, JavaParserFieldDeclaration, EnumDeclarationContext, ModifierValidator, NodeFinderVisitor, CloneVisitor, etc.), indicating broad usage across parsing, visiting, printing, generation and resolution. Outgoing: it directly depends on ~15 abstractions (examples: com.github.javaparser.ast.Node, com.github.javaparser.ast.NodeList, com.github.javaparser.ast.body.EnumConstantDeclaration, com.github.javaparser.ast.comments.JavadocComment, com.github.javaparser.ast.expr.SimpleName, com.github.javaparser.Range, com.github.javaparser.TokenRange, com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.resolution.declarations.ResolvedEnumDeclaration, com.github.javaparser.metamodel.EnumDeclarationMetaModel, com.github.javaparser.ast.visitor.VoidVisitor/GenericVisitor, com.github.javaparser.utils.Utils). The combination of many incoming clients (cross-cutting visitors, printers, generators, solvers) plus many outgoing references to core AST, meta-model and utility types shows EnumDeclaration functions as a central hub, meeting the Hub-like Modularization smell criteria."
    },
    {
        "identifier": "(default package).BaseClass",
        "detection": false,
        "justification": "Hub-like Modularization not detected: incoming_dependencies = 0 and outgoing_dependencies = 0 (no incoming or outgoing links to other abstractions), so the class does not have dependencies with a large number of other abstractions."
    },
    {
        "identifier": "implements_duplicate.DuplicateTypeName",
        "detection": false,
        "justification": "Both incoming and outgoing dependency lists are empty (incoming_dependencies = 0, outgoing_dependencies = 0). Hub-like Modularization requires an abstraction to have many incoming and outgoing dependencies; this class has none, so it is not a hub."
    },
    {
        "identifier": "com.github.javaparser.ParseException",
        "detection": false,
        "justification": "ParseException has multiple incoming dependencies (6): com.github.javaparser.symbolsolver.SourceFileInfoExtractor, com.github.javaparser.JavaParser, com.github.javaparser.ParseStart, com.github.javaparser.GeneratedJavaParserBase, com.github.javaparser.GeneratedJavaParser, com.foo.Widget. However it has only a single outgoing dependency (1): com.github.javaparser.Token. Hub-like Modularization requires an abstraction to have many incoming and many outgoing dependencies; here outgoing dependencies are minimal, so ParseException is not a hub."
    },
    {
        "identifier": "com.github.javaparser.javadoc.description.JavadocDescriptionElement",
        "detection": false,
        "justification": "The class has 0 outgoing dependencies and only 2 incoming dependencies (from com.github.javaparser.javadoc.description.JavadocInlineTag and com.github.javaparser.javadoc.description.JavadocDescription). Hub-like Modularization requires an abstraction to have dependencies (both incoming and outgoing) with a large number of other abstractions; this class lacks outgoing dependencies and has only a small number of incoming dependents, so it does not meet the hub-like criteria."
    },
    {
        "identifier": "com.github.javaparser.metamodel.EnumConstantDeclarationMetaModel",
        "detection": false,
        "justification": "The class has only 1 outgoing dependency (com.github.javaparser.metamodel.PropertyMetaModel) and only 2 incoming references in the provided data (com.github.javaparser.ast.body.EnumConstantDeclaration and com.github.javaparser.metamodel.JavaParserMetaModel). Although JavaParserMetaModel itself lists many dependencies, the analyzed class does not show a large number of direct incoming or outgoing relationships in the provided data, so it does not meet the hub-like modularization smell."
    },
    {
        "identifier": "com.github.javaparser.metamodel.MethodDeclarationMetaModel",
        "detection": false,
        "justification": "MethodDeclarationMetaModel has only 1 outgoing dependency (com.github.javaparser.metamodel.PropertyMetaModel) and only 2 incoming dependencies (com.github.javaparser.ast.body.MethodDeclaration and com.github.javaparser.metamodel.JavaParserMetaModel). Although JavaParserMetaModel references many meta-model classes and PropertyMetaModel has its own dependencies, MethodDeclarationMetaModel itself does not have a large number of direct incoming and outgoing relationships required to qualify as a hub."
    },
    {
        "identifier": "com.github.javaparser.printer.concretesyntaxmodel.CsmSingleReference",
        "detection": false,
        "justification": "CsmSingleReference has a small number of outgoing dependencies (4: com.github.javaparser.printer.ConcreteSyntaxModel, com.github.javaparser.printer.SourcePrinter, com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.ast.Node) and only a single incoming dependency entry (1: com.github.javaparser.printer.lexicalpreservation.LexicalDifferenceCalculator). Because it does not have dependencies (both incoming and outgoing) with a large number of other abstractions, it does not exhibit Hub-like Modularization."
    },
    {
        "identifier": "issue1945.interfaces.HairType",
        "detection": false,
        "justification": "HairType has 3 incoming dependencies (issue1945.main.MainIssue1945, issue1945.interfaces.HairyAnimal, issue1945.interfaces.HairTypeRenderer) and 0 outgoing dependencies. Hub-like Modularization requires an abstraction to have many both incoming and outgoing dependencies; because outgoing dependencies are absent, the smell is not detected when the class is considered in isolation."
    },
    {
        "identifier": "com.github.javaparser.utils.StringEscapeUtils.AggregateTranslator",
        "detection": false,
        "justification": "Both incoming and outgoing dependency lists are empty (0 incoming, 0 outgoing). Hub-like Modularization requires an abstraction to have dependencies with a large number of other abstractions; this class has none, so the smell is not present."
    },
    {
        "identifier": "com.github.javaparser.metamodel.ExplicitConstructorInvocationStmtMetaModel",
        "detection": false,
        "justification": "Incoming dependencies: 2 (com.github.javaparser.ast.stmt.ExplicitConstructorInvocationStmt, com.github.javaparser.metamodel.JavaParserMetaModel). Outgoing dependencies: 1 (com.github.javaparser.metamodel.PropertyMetaModel). Hub-like Modularization requires an abstraction to have dependencies (both incoming and outgoing) with a large number of other abstractions; this class shows low fan-in (2) and low fan-out (1), so it is not a hub."
    },
    {
        "identifier": "com.github.javaparser.printer.ConfigurablePrinter",
        "detection": false,
        "justification": "ConfigurablePrinter has only two outgoing dependencies (com.github.javaparser.printer.Printer and com.github.javaparser.printer.configuration.PrinterConfiguration) and a single incoming dependency from com.github.javaparser.ast.Node. The total number of distinct incoming/outgoing connected abstractions is small (3), so it does not exhibit the many-to-many dependency pattern characteristic of Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.ast.type.UnionType",
        "detection": true,
        "justification": "UnionType has a non-trivial set of outgoing dependencies (13 distinct dependencies including com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.resolution.Context, com.github.javaparser.resolution.types.ResolvedType, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.ast.NodeList, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.TokenRange, com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.ast.Node, com.github.javaparser.metamodel.UnionTypeMetaModel, com.github.javaparser.resolution.types.ResolvedUnionType, com.github.javaparser.Range), while also receiving incoming dependencies from a large number of other abstractions (at least 21 distinct clients in the provided data), notably many visitor and utility classes (e.g. DefaultVisitorAdapter, VoidVisitor, GenericVisitor, HashCodeVisitor, EqualsVisitor, ModifierVisitor, VoidVisitorAdapter, GenericVisitorAdapter, CloneVisitor, NodeFinderVisitor) as well as printers and parser generators (PrettyPrintVisitor, DefaultPrettyPrinterVisitor, GeneratedJavaParser) and the symbol solver adapter. The combination of many incoming dependents across diverse roles (visitors, printers, parser, symbol solver) and multiple outgoing ties to core/meta/resolution types indicates UnionType functions as a hub-like module connecting many unrelated abstractions, satisfying the Hub-like Modularization smell."
    },
    {
        "identifier": "com.github.javaparser.ast.type.ClassOrInterfaceType",
        "detection": true,
        "justification": "ClassOrInterfaceType has a large number of incoming and outgoing dependencies. Outgoing: it directly depends on ~15 other abstractions (examples: com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.resolution.Context, com.github.javaparser.resolution.types.ResolvedType, com.github.javaparser.ast.Node, com.github.javaparser.ast.NodeList, com.github.javaparser.Range, com.github.javaparser.ast.expr.SimpleName, com.github.javaparser.TokenRange, com.github.javaparser.ast.type.PrimitiveType, com.github.javaparser.metamodel.ClassOrInterfaceTypeMetaModel). Incoming: ~43 other abstractions depend on ClassOrInterfaceType (examples include many visitor and utility classes such as DefaultVisitorAdapter, VoidVisitor, GenericVisitor, ModifierVisitor, HashCodeVisitor, EqualsVisitor, GenericVisitorAdapter, numerous symbol-solver/declaration classes like JavaParserFacade, JavaParserClassDeclaration, JavaParserEnumDeclaration, JavaParserTypeParameter, parser/adapter classes such as GeneratedJavaParser, StaticJavaParser, JavaParserAdapter, printer classes like PrettyPrintVisitor and DefaultPrettyPrinterVisitor, and many AST node types such as ObjectCreationExpr, CatchClause, NodeWithImplements/Extends/Type). The class therefore acts as a hub with many incoming and outgoing ties, meeting the Hub-like Modularization smell criteria."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.resolution.typeinference.bounds.FalseBound",
        "detection": false,
        "justification": "FalseBound has only one outgoing dependency (InferenceVariableSubstitution) and only one incoming dependent class (Bound). The total number of distinct incoming and outgoing abstraction dependencies is very small (1 outgoing, 1 incoming), so it does not exhibit hub-like modularization."
    },
    {
        "identifier": "com.github.javaparser.ast.validator.postprocessors.Java18PostProcessor",
        "detection": false,
        "justification": "The class has 0 incoming dependencies and 0 outgoing dependencies (both dependency lists are empty). Hub-like Modularization requires many incoming and outgoing connections; with no dependencies, this class is not a hub."
    },
    {
        "identifier": "com.github.javaparser.ast.CompilationUnit.Storage",
        "detection": false,
        "justification": "The class has a very small set of dependencies: incoming dependencies from 1 abstraction (com.github.javaparser.ast.CompilationUnit) and outgoing dependencies to 2 abstractions (com.github.javaparser.ast.CompilationUnit and com.github.javaparser.ParseStart). Total distinct connected abstractions = 2. Although there is a bidirectional relationship with com.github.javaparser.ast.CompilationUnit, the number of incoming and outgoing links is not large, so it does not exhibit Hub-like Modularization."
    },
    {
        "identifier": "com.example.Beta.CustomInterface",
        "detection": false,
        "justification": "Not detected: com.example.Beta.CustomInterface has 0 outgoing dependencies and only 1 incoming dependency (from com.example.Beta, which lists dependencies [com.example.Beta.CustomInterface, com.example.Alpha]). Hub-like modularization requires a large number of both incoming and outgoing dependencies; these metrics do not meet that condition."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javassistmodel.JavassistFieldDeclaration",
        "detection": false,
        "justification": "Not a hub: JavassistFieldDeclaration has outgoing dependencies to 5 abstractions (com.github.javaparser.ast.AccessSpecifier, com.github.javaparser.resolution.types.ResolvedType, com.github.javaparser.resolution.TypeSolver, com.github.javaparser.symbolsolver.javassistmodel.JavassistFactory, com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration) but has 0 incoming dependencies. Hub-like Modularization requires an abstraction to have many incoming and outgoing dependencies; here incoming dependencies are absent, so the hub smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.metamodel.ClassOrInterfaceDeclarationMetaModel",
        "detection": false,
        "justification": "Although ClassOrInterfaceDeclarationMetaModel has multiple incoming references (notably com.github.javaparser.metamodel.JavaParserMetaModel, which lists ClassOrInterfaceDeclarationMetaModel among a very large set of meta-models, and com.github.javaparser.ast.body.ClassOrInterfaceDeclaration which depends on it), its direct outgoing dependencies are minimal: only com.github.javaparser.metamodel.PropertyMetaModel is listed as an outgoing dependency. Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; here the incoming side is large but the outgoing side is not, so the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.metamodel.YieldStmtMetaModel",
        "detection": false,
        "justification": "YieldStmtMetaModel has only 1 outgoing dependency (com.github.javaparser.metamodel.PropertyMetaModel) and only 2 incoming dependents (com.github.javaparser.ast.stmt.YieldStmt and com.github.javaparser.metamodel.JavaParserMetaModel). A hub-like modularization would show dependencies to/from a large number of distinct abstractions. Although JavaParserMetaModel itself lists many dependencies, those are JavaParserMetaModel's relationships, not additional distinct incoming/outgoing links for YieldStmtMetaModel. Therefore YieldStmtMetaModel is not a hub."
    },
    {
        "identifier": "(default package).DerivedClass",
        "detection": false,
        "justification": "No hub-like modularization: incoming_dependencies = [], outgoing_dependencies = [], dependencies = []. There are zero incoming and zero outgoing connections, so the class does not exhibit the many-to-many dependency pattern required for a hub."
    },
    {
        "identifier": "main.GrandParent",
        "detection": false,
        "justification": "No incoming or outgoing dependencies: incoming_dependencies is empty and outgoing_dependencies is empty; analyzed_package.dependencies is also empty. With no dependencies to or from other abstractions, it cannot be a hub-like module."
    },
    {
        "identifier": "com.github.javaparser.printer.ConcreteSyntaxModel",
        "detection": true,
        "justification": "ConcreteSyntaxModel has multiple outgoing dependencies (6): com.github.javaparser.GeneratedJavaParserConstants, com.github.javaparser.ast.Node, com.github.javaparser.printer.concretesyntaxmodel.CsmElement, com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.printer.concretesyntaxmodel.CsmConditional, com.github.javaparser.printer.SourcePrinter. It also has multiple incoming dependencies (4 distinct clients) from different modules: com.github.javaparser.printer.concretesyntaxmodel.CsmSingleReference, com.github.javaparser.printer.concretesyntaxmodel.CsmList, com.github.javaparser.printer.lexicalpreservation.LexicalDifferenceCalculator, and com.github.javaparser.printer.lexicalpreservation.LexicalPreservingPrinter. The class thus both depends on and is depended upon by a large set of other abstractions across printer, concretesyntaxmodel and lexicalpreservation areas, matching the Hub-like Modularization smell (multiple incoming and outgoing ties)."
    },
    {
        "identifier": "com.github.javaparser.metamodel.ModifierMetaModel",
        "detection": false,
        "justification": "ModifierMetaModel has only 1 outgoing dependency (com.github.javaparser.metamodel.PropertyMetaModel) and 2 incoming dependencies (com.github.javaparser.ast.Modifier and com.github.javaparser.metamodel.JavaParserMetaModel). A hub-like modularization requires an abstraction to have incoming and outgoing dependencies with a large number of other abstractions; the provided data shows limited connectivity, so this is not a hub."
    },
    {
        "identifier": "com.github.javaparser.metamodel.UnionTypeMetaModel",
        "detection": false,
        "justification": "UnionTypeMetaModel has only 1 outgoing dependency (com.github.javaparser.metamodel.PropertyMetaModel) and only 2 incoming dependents (com.github.javaparser.ast.type.UnionType and com.github.javaparser.metamodel.JavaParserMetaModel). The counts of incoming and outgoing connections are low and do not indicate dependencies with a large number of other abstractions, so Hub-like Modularization is not detected."
    },
    {
        "identifier": "com.github.javaparser.ast.expr.BooleanLiteralExpr",
        "detection": true,
        "justification": "BooleanLiteralExpr has a high-degree of both incoming and outgoing connections. Incoming: it is referenced by ~21 distinct abstractions (examples: com.github.javaparser.ast.visitor.VoidVisitor, GenericVisitor and many of their concrete visitors such as VoidVisitorAdapter, EqualsVisitor, HashCodeVisitor, CloneVisitor, ModifierVisitor, GenericVisitorAdapter, DefaultVisitorAdapter, TypeExtractor, GeneratedJavaParser, PrettyPrintVisitor, DefaultPrettyPrinterVisitor, NodeFinderVisitor, etc.), showing many other modules depend on it. Outgoing: it depends on 7 abstractions (com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.TokenRange, com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.Range, com.github.javaparser.metamodel.BooleanLiteralExprMetaModel), including central visitor interfaces and metamodel/types. The combination of many incoming references from numerous visitors/utilities and multiple outgoing links to core infrastructure (visitors, meta-model, token/range/observer types) matches the Hub-like Modularization smell."
    },
    {
        "identifier": "com.github.javaparser.ast.modules.ModuleOpensDirective",
        "detection": true,
        "justification": "ModuleOpensDirective has a large number of both outgoing and incoming connections: it directly depends on 9 distinct abstractions (examples: com.github.javaparser.ast.Node, com.github.javaparser.ast.expr.Name, com.github.javaparser.ast.NodeList, com.github.javaparser.TokenRange, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.metamodel.ModuleOpensDirectiveMetaModel) and is depended on by at least 21 other abstractions (notably many visitor and tooling classes such as com.github.javaparser.ast.visitor.VoidVisitor, GenericVisitor, HashCodeVisitor, EqualsVisitor, ModifierVisitor, PrettyPrintVisitor, DefaultPrettyPrinterVisitor, GeneratedJavaParser, and numerous visitor adapters). This bidirectional connectivity to a large set of unrelated components (core AST node types, visitors, meta-models, parser/printer classes and observers) fits the Hub-like Modularization smell."
    },
    {
        "identifier": "com.github.javaparser.printer.configuration.DefaultPrinterConfiguration.ConfigOption",
        "detection": false,
        "justification": "Hub-like Modularization not detected: the class has only 1 outgoing dependency (com.github.javaparser.utils.LineSeparator) and only 1 incoming dependency (com.github.javaparser.printer.configuration.DefaultPrinterConfiguration). A hub requires a large number of both incoming and outgoing dependencies, which is not the case here."
    },
    {
        "identifier": "(default package).Test",
        "detection": false,
        "justification": "The class has 0 outgoing dependencies and 0 incoming dependencies (both empty). Hub-like Modularization requires an abstraction to have dependencies both incoming and outgoing with a large number of other abstractions; with zero incoming and zero outgoing dependencies this class does not meet that criterion."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.resolution.typeinference.bounds.ThrowsBound",
        "detection": false,
        "justification": "ThrowsBound has outgoing dependencies to 2 abstractions (com.github.javaparser.symbolsolver.resolution.typeinference.InferenceVariableSubstitution, com.github.javaparser.symbolsolver.resolution.typeinference.InferenceVariable) and only 1 incoming dependency from a single abstraction (com.github.javaparser.symbolsolver.resolution.typeinference.TypeInference). Although TypeInference has many dependencies overall, ThrowsBound itself does not have a large number of distinct incoming and outgoing relationships, so it does not exhibit Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserEnumConstantDeclaration",
        "detection": false,
        "justification": "Not detected: the class has 0 incoming dependencies and only 4 outgoing dependencies (com.github.javaparser.ast.body.EnumConstantDeclaration, com.github.javaparser.resolution.types.ResolvedType, com.github.javaparser.resolution.TypeSolver, com.github.javaparser.resolution.Navigator). Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing connections; the provided data shows no incoming links and a small number of outgoing links, so the smell is not present."
    },
    {
        "identifier": "com.github.javaparser.metamodel.ArrayTypeMetaModel",
        "detection": false,
        "justification": "ArrayTypeMetaModel has only 1 outgoing dependency (com.github.javaparser.metamodel.PropertyMetaModel) and is directly referenced by 2 incoming classes (com.github.javaparser.ast.type.ArrayType and com.github.javaparser.metamodel.JavaParserMetaModel). Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; the provided data shows low fan-in (2) and low fan-out (1). Note that the long dependency list under JavaParserMetaModel are dependencies of that incoming class, not direct additional incoming/outgoing links of ArrayTypeMetaModel."
    },
    {
        "identifier": "com.github.javaparser.metamodel.AssertStmtMetaModel",
        "detection": false,
        "justification": "AssertStmtMetaModel has a small number of incoming and outgoing relations: incoming from com.github.javaparser.ast.stmt.AssertStmt and com.github.javaparser.metamodel.JavaParserMetaModel (2 incoming abstractions) and a single outgoing dependency to com.github.javaparser.metamodel.PropertyMetaModel (1 outgoing abstraction). Hub-like Modularization requires an abstraction to have dependencies with a large number of other abstractions on both incoming and outgoing sides; these counts are low, so the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.resolution.promotion.NumericConditionalExprHandler",
        "detection": false,
        "justification": "NumericConditionalExprHandler has only two outgoing dependencies (com.github.javaparser.resolution.types.ResolvedPrimitiveType, com.github.javaparser.resolution.types.ResolvedType) and zero incoming dependencies. Although ResolvedType itself depends on many other abstractions, the analyzed class does not exhibit both widespread incoming and outgoing connections required for Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.generator.core.visitor.GenericVisitorGenerator",
        "detection": false,
        "justification": "GenericVisitorGenerator has 0 incoming dependencies and only 4 outgoing dependencies (com.github.javaparser.ast.CompilationUnit, com.github.javaparser.ast.body.MethodDeclaration, com.github.javaparser.utils.SourceRoot, com.github.javaparser.metamodel.BaseNodeMetaModel). Hub-like Modularization requires an abstraction to have both many incoming and many outgoing connections to other abstractions. The absence of incoming dependencies (and a small number of outgoing dependencies) means this class does not exhibit the hub-like modularization smell in isolation."
    },
    {
        "identifier": "(default package).Issue300.B",
        "detection": false,
        "justification": "incoming_dependencies = [], outgoing_dependencies = [] (total connections = 0). The class has no incoming or outgoing dependencies, so it does not have dependencies with a large number of other abstractions and is not a hub."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javassistmodel.JavassistEnumDeclaration",
        "detection": false,
        "justification": "Hub-like Modularization requires an abstraction to have dependencies both incoming and outgoing with a large number of other abstractions. JavassistEnumDeclaration has 0 incoming dependencies (incoming_dependencies: []), so it is not a hub. Although it has multiple outgoing dependencies (11 distinct dependencies including AccessSpecifier, SymbolReference, Context, ResolvedType, ResolvedFieldDeclaration, TypeSolver, JavassistFactory, ResolvedReferenceTypeDeclaration, JavassistUtils, JavassistClassDeclaration, JavassistTypeDeclarationAdapter), the absence of incoming links prevents classification as hub-like."
    },
    {
        "identifier": "com.github.javaparser.ast.expr.MethodReferenceExpr",
        "detection": true,
        "justification": "MethodReferenceExpr participates in many incoming and outgoing relationships: outgoing dependencies include core AST and support abstractions (Expression, Node, NodeList, TokenRange, Range, JavaParserMetaModel, MethodReferenceExprMetaModel, ObservableProperty, ResolvedMethodDeclaration, Utils), showing it depends on multiple subsystems. It is referenced by a large and diverse set of incoming classes across visitors, symbol resolution, parsing and printing (for example: many ast.visitor classes such as VoidVisitor, GenericVisitor, EqualsVisitor, HashCodeVisitor, ModifierVisitor, CloneVisitor, VoidVisitorAdapter, GenericVisitorAdapter, PrettyPrintVisitor, DefaultPrettyPrinterVisitor, NodeFinderVisitor; parser/runtime classes such as GeneratedJavaParser; and symbol-solver classes such as JavaParserFacade, TypeExtractor, TypeInference, MethodReferenceExprContext, MethodReferenceThrowsCompatibleWithType, DefaultVisitorAdapter). The multiplicity and diversity of both incoming (numerous visitors, symbol-solver, parser and printer clients) and outgoing dependencies indicate MethodReferenceExpr acts as a hub linking many abstractions, matching the Hub-like Modularization smell."
    },
    {
        "identifier": "com.github.javaparser.generator.core.other.BndGenerator",
        "detection": false,
        "justification": "BndGenerator has only one outgoing dependency: com.github.javaparser.utils.SourceRoot, and it has zero incoming dependencies. Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies. Although the referenced SourceRoot (the single outgoing target) itself lists many dependencies, BndGenerator itself does not exhibit many incoming or outgoing relations, so it is not a hub."
    },
    {
        "identifier": "com.github.javaparser.metamodel.VoidTypeMetaModel",
        "detection": false,
        "justification": "VoidTypeMetaModel has 0 outgoing dependencies and only 2 incoming dependencies (from com.github.javaparser.ast.type.VoidType and com.github.javaparser.metamodel.JavaParserMetaModel). The JavaParserMetaModel entry shows many outgoing dependencies from that class, but those are not outgoing dependencies of VoidTypeMetaModel. Hub-like Modularization requires an abstraction to have many incoming and outgoing connections; VoidTypeMetaModel lacks outgoing links and does not exhibit a large number of incoming links, so the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.printer.lexicalpreservation.ReshuffledDiffElementExtractor",
        "detection": false,
        "justification": "ReshuffledDiffElementExtractor has outgoing dependencies to 9 distinct abstractions (PeekingIterator, NodeText, DifferenceElementCalculator, CsmMix, CsmElement, Reshuffled, ReshuffledDiffElementExtractor.MatchClassification, DifferenceElement, TextElement) but only a single incoming dependency from com.github.javaparser.printer.lexicalpreservation.Difference. Because hub-like modularization requires an abstraction to have both a large number of incoming and outgoing dependency relationships, the class does not meet the criterion (many outgoing but not many incoming)."
    },
    {
        "identifier": "com.github.javaparser.ParseResult",
        "detection": false,
        "justification": "ParseResult has many incoming dependencies (12 distinct classes reference it: com.github.javaparser.ast.validator.TypedValidator, com.github.javaparser.ast.validator.postprocessors.PostProcessors, com.github.javaparser.ast.validator.postprocessors.Java10PostProcessor, com.github.javaparser.JavaParser, com.github.javaparser.StaticJavaParser, com.github.javaparser.Processor, com.github.javaparser.JavaParserAdapter, com.github.javaparser.ParserConfiguration, com.github.javaparser.utils.SourceRoot, com.github.javaparser.utils.CollectionStrategy, com.github.javaparser.utils.SourceZip, com.github.javaparser.generator.AbstractGenerator), but it has only 3 direct outgoing dependencies (com.github.javaparser.utils.LineSeparator, com.github.javaparser.Problem, com.github.javaparser.ast.comments.CommentsCollection). The hub-like modularization smell requires an abstraction to have dependencies with a large number of other abstractions on both incoming and outgoing sides; here the incoming side is large while the outgoing side is small, so ParseResult does not meet the criterion for a hub-like module."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.reflectionmodel.ReflectionRecordDeclaration",
        "detection": false,
        "justification": "ReflectionRecordDeclaration has many outgoing dependencies (19) including com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration, com.github.javaparser.resolution.TypeSolver, com.github.javaparser.symbolsolver.reflectionmodel.ReflectionMethodDeclaration, com.github.javaparser.symbolsolver.reflectionmodel.comparators.MethodComparator, com.github.javaparser.resolution.logic.MethodResolutionLogic, com.github.javaparser.resolution.types.ResolvedReferenceType, com.github.javaparser.resolution.model.SymbolReference, com.github.javaparser.resolution.types.ResolvedType, com.github.javaparser.resolution.declarations.ResolvedFieldDeclaration, com.github.javaparser.symbolsolver.javaparsermodel.contexts.ContextHelper, com.github.javaparser.resolution.Context, com.github.javaparser.symbolsolver.logic.AbstractTypeDeclaration, com.github.javaparser.symbolsolver.reflectionmodel.ReflectionFactory, com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassAdapter, com.github.javaparser.ast.Node, com.github.javaparser.resolution.MethodUsage, com.github.javaparser.ast.AccessSpecifier, com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration, and com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration. However, it has 0 incoming dependencies. The Hub-like Modularization smell requires an abstraction to have both a large number of incoming and outgoing dependencies; because incoming dependencies are absent, this class is not a hub."
    },
    {
        "identifier": "com.github.javaparser.ast.nodeTypes.NodeWithVariables",
        "detection": false,
        "justification": "NodeWithVariables has a small number of outgoing dependencies (4: com.github.javaparser.ast.body.VariableDeclarator, com.github.javaparser.ast.nodeTypes.NodeWithVariables.Helper, com.github.javaparser.ast.NodeList, com.github.javaparser.ast.type.Type) and only 2 distinct incoming dependents (com.github.javaparser.ast.body.VariableDeclarator and com.github.javaparser.printer.PrettyPrintVisitor). Hub-like Modularization requires an abstraction to have incoming and outgoing ties with a large number of other abstractions; the observed counts (outgoing=4, incoming=2) are low, so this is not a hub."
    },
    {
        "identifier": "com.github.javaparser.metamodel.UnknownTypeMetaModel",
        "detection": false,
        "justification": "Outgoing dependencies for this class are empty. Incoming dependencies list only two classes: com.github.javaparser.ast.type.UnknownType and com.github.javaparser.metamodel.JavaParserMetaModel. Hub-like Modularization requires an abstraction to have many incoming and outgoing dependencies; here outgoing = 0 and incoming = 2, so the class is not a hub. (Although JavaParserMetaModel itself lists many dependencies, those are its outgoing links and do not make UnknownTypeMetaModel have many incoming/outgoing dependencies in the provided, class-isolated data.)"
    },
    {
        "identifier": "com.github.javaparser.GeneratedJavaParserTokenManagerBase",
        "detection": false,
        "justification": "The class has outgoing dependencies to 6 distinct abstractions: TokenTypes, TokenRange, Comment, Token, MarkdownComment, JavaToken. It has only 1 incoming dependency (GeneratedJavaParserTokenManager). Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; here outgoing dependencies are moderate but incoming dependencies are minimal, so this class does not meet the hub-like pattern."
    },
    {
        "identifier": "com.github.javaparser.ast.expr.SimpleName",
        "detection": false,
        "justification": "SimpleName has a large number of incoming dependencies (53 distinct incoming callers such as com.github.javaparser.ast.visitor.VoidVisitor, DefaultVisitorAdapter, JavaParserFacade, many AST node and visitor classes), but a small set of outgoing dependencies (7: com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.TokenRange, com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.metamodel.SimpleNameMetaModel, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.utils.Utils). The Hub-like Modularization smell requires having both many incoming and many outgoing connections; here SimpleName is widely referenced (high incoming) but does not depend on a large number of other abstractions (low outgoing), so the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.serialization.JavaParserJsonSerializer.JsonNode",
        "detection": false,
        "justification": "JsonNode has only one outgoing dependency (com.github.javaparser.metamodel.JavaParserMetaModel) and only one incoming depender (com.github.javaparser.serialization.JavaParserJsonSerializer). Although JavaParserMetaModel itself lists many dependent meta-model classes, those are indirect and not direct incoming/outgoing dependencies of JsonNode. With only a single direct incoming and a single direct outgoing link, JsonNode does not meet the criterion of having dependencies with a large number of other abstractions and therefore is not a hub-like module."
    },
    {
        "identifier": "com.github.javaparser.ast.visitor.CloneVisitor",
        "detection": false,
        "justification": "The class has a large number of outgoing dependencies to many AST node and support types (examples: com.github.javaparser.ast.body.TypeDeclaration, com.github.javaparser.ast.type.WildcardType, com.github.javaparser.ast.comments.TraditionalJavadocComment, com.github.javaparser.ast.expr.Expression, com.github.javaparser.ast.Node, com.github.javaparser.ast.CompilationUnit, com.github.javaparser.ast.body.MethodDeclaration, com.github.javaparser.ast.expr.SimpleName, com.github.javaparser.ast.type.Type, etc.). However, the provided incoming_dependencies list is empty (no incoming dependencies). Hub-like Modularization requires an abstraction to have both a large number of incoming and outgoing dependencies (high fan-in and high fan-out). Because CloneVisitor has many outgoing dependencies but no incoming dependencies in the supplied data, it does not meet the definition of a hub-like modularization."
    },
    {
        "identifier": "com.github.javaparser.serialization.JavaParserJsonSerializer.JsonTokenRange",
        "detection": false,
        "justification": "The class has 0 outgoing dependencies and only 1 incoming dependency (from com.github.javaparser.serialization.JavaParserJsonSerializer). Hub-like Modularization requires an abstraction to have dependencies (incoming and outgoing) with a large number of other abstractions. Here the analyzed class is connected to a single other class and has no outgoing links, so the hub condition is not met. Note: the incoming class's own many dependencies do not make this class a hub in isolation."
    },
    {
        "identifier": "com.github.javaparser.resolution.declarations.ResolvedInterfaceDeclaration",
        "detection": false,
        "justification": "ResolvedInterfaceDeclaration has 0 outgoing dependencies (outgoing_dependencies is empty) and only 5 incoming dependencies (ReflectionInterfaceDeclaration, JavaParserInterfaceDeclaration, TypeInference, JavassistInterfaceDeclaration, ResolvedTypeDeclaration). Hub-like Modularization requires an abstraction to have dependencies both incoming and outgoing with a large number of other abstractions; here the lack of outgoing dependencies and the small number of incoming dependents means the class is not a hub."
    },
    {
        "identifier": "(default package).Complex",
        "detection": false,
        "justification": "Class has 0 incoming dependencies and 0 outgoing dependencies (both dependency lists are empty). Hub-like Modularization requires many incoming and outgoing connections; with zero dependencies this class is not a hub."
    },
    {
        "identifier": "com.github.javaparser.ast.nodeTypes.modifiers.NodeWithProtectedModifier",
        "detection": false,
        "justification": "Not detected: incoming_dependencies = 0 and outgoing_dependencies = 0 (both dependency lists are empty), so the class has no large number of incoming or outgoing dependencies required for Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.metamodel.VariableDeclarationExprMetaModel",
        "detection": false,
        "justification": "VariableDeclarationExprMetaModel has a low number of outgoing and incoming connections: it depends on only one abstraction (com.github.javaparser.metamodel.PropertyMetaModel) and is referenced by two classes (com.github.javaparser.ast.expr.VariableDeclarationExpr and com.github.javaparser.metamodel.JavaParserMetaModel). Although JavaParserMetaModel lists many meta-models, that makes JavaParserMetaModel a hub, not VariableDeclarationExprMetaModel. Therefore this class does not exhibit hub-like modularization."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javassistmodel.JavassistMethodDeclaration",
        "detection": false,
        "justification": "Outgoing dependencies count = 10: [com.github.javaparser.resolution.MethodUsage, com.github.javaparser.resolution.Context, com.github.javaparser.ast.AccessSpecifier, com.github.javaparser.resolution.declarations.ResolvedParameterDeclaration, com.github.javaparser.resolution.types.ResolvedType, com.github.javaparser.symbolsolver.javassistmodel.JavassistMethodLikeDeclarationAdapter, com.github.javaparser.resolution.TypeSolver, com.github.javaparser.symbolsolver.javassistmodel.JavassistFactory, com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration, com.github.javaparser.ast.Node]. Incoming dependencies count = 1: [com.github.javaparser.symbolsolver.javassistmodel.JavassistUtils]. Hub-like modularization requires an abstraction to have a large number of both incoming and outgoing links. While JavassistMethodDeclaration has multiple outgoing dependencies, it has only a single incoming dependency in the provided data, so it does not meet the definition of a hub-like module when considered in isolation."
    },
    {
        "identifier": "com.github.javaparser.ast.expr.RecordPatternExpr",
        "detection": true,
        "justification": "RecordPatternExpr has a substantial number of both outgoing and incoming dependencies. Outgoing: 10 direct dependencies (Node, Type, NodeList, VoidVisitor, GenericVisitor, JavaParserMetaModel, TokenRange, ReferenceType, ObservableProperty, RecordPatternExprMetaModel). Incoming: at least 20 distinct abstractions depend on it (numerous visitor and core classes such as VoidVisitor, GenericVisitor, HashCodeVisitor, EqualsVisitor, CloneVisitor, PrettyPrintVisitor, DefaultPrettyPrinterVisitor, GeneratedJavaParser, Expression, and many Void/Generic visitor adapters). The presence of many incoming edges (widely referenced by visitors/parsers) combined with multiple outgoing edges to core AST/meta-model types shows the class acts as a hub linking many abstractions, meeting the Hub-like Modularization smell criteria."
    },
    {
        "identifier": "com.github.javaparser.UnicodeEscapeProcessingProvider.LineCounter",
        "detection": false,
        "justification": "Not a hub: LineCounter has 0 outgoing dependencies (outgoing_dependencies is empty) and only 1 incoming dependency (from com.github.javaparser.UnicodeEscapeProcessingProvider). Hub-like modularization requires an abstraction to have many incoming and outgoing ties; LineCounter does not meet that condition."
    },
    {
        "identifier": "(default package).InnerClassContainer.InnerInnerInnerClass",
        "detection": false,
        "justification": "The class has zero incoming dependencies and zero outgoing dependencies (incoming_dependencies: [], outgoing_dependencies: []), so it does not have a large number of both incoming and outgoing connections required for Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.ast.visitor.ObjectIdentityHashCodeVisitor",
        "detection": false,
        "justification": "The class has a very large number of outgoing dependencies (references to many distinct AST types such as TraditionalJavadocComment, WildcardType, UnaryExpr, MethodDeclaration, Node, CompilationUnit, ClassOrInterfaceDeclaration, etc.), but there are no incoming dependencies (incoming_dependencies is empty). Hub-like Modularization requires an abstraction to have both many incoming and many outgoing couplings. Because this class lacks incoming dependencies, it does not satisfy the hub-like modularization smell."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserClassDeclaration",
        "detection": false,
        "justification": "The class has a large number of outgoing dependencies (19 distinct abstractions, e.g. com.github.javaparser.resolution.TypeSolver, com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade, com.github.javaparser.ast.Node, com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration, com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFactory), but the provided data shows 0 incoming dependencies. Hub-like Modularization requires an abstraction to have both high incoming and high outgoing coupling; because incoming degree is zero, this smell is not detected for this class."
    },
    {
        "identifier": "com.github.javaparser.utils.CollectionStrategy",
        "detection": false,
        "justification": "Incoming dependencies: 0 (no incoming_dependencies). Outgoing dependencies: 5 (com.github.javaparser.ParserConfiguration, com.github.javaparser.ast.CompilationUnit, com.github.javaparser.JavaParser, com.github.javaparser.utils.ProjectRoot, com.github.javaparser.ParseResult). Hub-like Modularization requires an abstraction to have many incoming and many outgoing dependencies; since CollectionStrategy has no incoming dependencies (only outgoing to 5 classes), it does not meet the hub-like criterion."
    },
    {
        "identifier": "com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration",
        "detection": false,
        "justification": "ResolvedMethodDeclaration has many incoming dependencies (referenced by 16 distinct classes: com.github.javaparser.symbolsolver.declarations.common.MethodDeclarationCommonLogic; com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassDeclaration; com.github.javaparser.symbolsolver.reflectionmodel.ReflectionRecordDeclaration; com.github.javaparser.symbolsolver.reflectionmodel.ReflectionMethodResolutionLogic; com.github.javaparser.symbolsolver.javaparsermodel.TypeExtractor; com.github.javaparser.symbolsolver.javaparsermodel.contexts.MethodReferenceExprContext; com.github.javaparser.symbolsolver.javaparsermodel.contexts.RecordDeclarationContext; com.github.javaparser.symbolsolver.javaparsermodel.contexts.AbstractJavaParserContext; com.github.javaparser.symbolsolver.resolution.typeinference.TypeInference; com.github.javaparser.symbolsolver.javassistmodel.JavassistUtils; com.github.javaparser.ast.body.MethodDeclaration; com.github.javaparser.ast.expr.MethodReferenceExpr; com.github.javaparser.ast.expr.MethodCallExpr; com.github.javaparser.resolution.MethodUsage; com.github.javaparser.resolution.declarations.ResolvedDeclaration; com.github.javaparser.resolution.logic.MethodResolutionLogic), but its direct outgoing dependencies are minimal: only 1 direct dependency is listed (com.github.javaparser.resolution.types.ResolvedType). Hub-like Modularization requires an abstraction to have many dependencies both incoming and outgoing; here the outgoing set size (1) is too small to classify ResolvedMethodDeclaration as a hub. (Note: the single outgoing target ResolvedType has many dependencies itself, but those are indirect/transitive from ResolvedMethodDeclaration and do not change the fact that ResolvedMethodDeclaration's direct outgoing degree is 1.)"
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.contexts.ForStatementContext",
        "detection": false,
        "justification": "ForStatementContext has a large number of outgoing dependencies (12), e.g. SymbolReference, ForStmt, PatternVariableResult, TypeSolver, Expression, PatternVariableVisitor, StatementContext, Node, NormalCompletionVisitor, VariableDeclarationExpr, JavaParserSymbolDeclaration, Navigator, but it has zero incoming dependencies. Hub-like Modularization requires an abstraction to have many incoming and outgoing dependencies; the absence of incoming dependencies means this class is not a hub."
    },
    {
        "identifier": "com.github.javaparser.metamodel.ParameterMetaModel",
        "detection": false,
        "justification": "ParameterMetaModel has only 1 outgoing dependency (com.github.javaparser.metamodel.PropertyMetaModel) and only 2 incoming dependents (com.github.javaparser.ast.body.Parameter and com.github.javaparser.metamodel.JavaParserMetaModel). It does not have incoming and outgoing connections to a large number of other abstractions, so it is not a hub."
    },
    {
        "identifier": "com.github.javaparser.ast.stmt.LocalClassDeclarationStmt",
        "detection": false,
        "justification": "Incoming dependencies are numerous (22 distinct classes reference LocalClassDeclarationStmt, e.g., com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.printer.PrettyPrintVisitor, com.github.javaparser.GeneratedJavaParser). Outgoing dependencies are limited (8 entries: com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.body.ClassOrInterfaceDeclaration, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.TokenRange, com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.ast.Node, com.github.javaparser.metamodel.LocalClassDeclarationStmtMetaModel, com.github.javaparser.ast.visitor.GenericVisitor). The Hub-like Modularization smell requires an abstraction to have a large number of both incoming and outgoing dependencies; here only incoming dependencies are large while outgoing dependencies are relatively small, so the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.resolution.declarations.ResolvedValueDeclaration",
        "detection": false,
        "justification": "ResolvedValueDeclaration has a single outgoing dependency (com.github.javaparser.resolution.types.ResolvedType) and a modest number of incoming dependents (6 distinct classes: com.github.javaparser.symbolsolver.JavaSymbolSolver; com.github.javaparser.symbolsolver.javaparsermodel.contexts.TryWithResourceContext; com.github.javaparser.ast.body.VariableDeclarator; com.github.javaparser.ast.expr.NameExpr; com.github.javaparser.ast.expr.FieldAccessExpr; com.github.javaparser.resolution.model.Value). The Hub-like Modularization smell requires an abstraction to have both many incoming and many outgoing dependencies; here outgoing degree = 1 and incoming degree = 6, which does not constitute a large number of both incoming and outgoing dependencies, so the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.printer.lexicalpreservation.DifferenceElement",
        "detection": false,
        "justification": "DifferenceElement has multiple incoming dependencies (5 distinct classes depend on it: LexicalDifferenceCalculator, Difference, ReshuffledDiffElementExtractor, Reshuffled, Added) but only a small number of outgoing dependencies (2 distinct abstractions referenced: LexicalDifferenceCalculator, CsmElement). Hub-like Modularization requires an abstraction to have dependencies with a large number of other abstractions both incoming and outgoing. The provided data shows high incoming fan-in but low outgoing fan-out, so it does not meet the symmetric 'hub-like' criterion."
    },
    {
        "identifier": "com.github.javaparser.generator.core.visitor.GenericVisitorWithDefaultsGenerator",
        "detection": false,
        "justification": "Not detected: the class has no incoming dependencies (incoming_dependencies is empty) and only outgoing dependencies to five distinct abstractions (BaseNodeMetaModel, BlockStmt, CompilationUnit, MethodDeclaration, SourceRoot). Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; this class lacks incoming couplings and does not show a large number of outgoing couplings."
    },
    {
        "identifier": "com.github.javaparser.ast.type.ArrayType",
        "detection": true,
        "justification": "ArrayType exhibits Hub-like Modularization: it has a large number of incoming dependents (≈28 distinct incoming classes such as many visitor/utility classes — DefaultVisitorAdapter, JavaParserFacade, VoidVisitor, GenericVisitor, HashCodeVisitor, PrettyPrintVisitor, DefaultPrettyPrinterVisitor, CloneVisitor, NodeFinderVisitor, ArrayCreationExpr, JavaParserMetaModel, GeneratedJavaParserBase, etc.) and a substantial set of outgoing dependencies (18 listed direct dependencies including com.github.javaparser.ast.visitor.VoidVisitor, GenericVisitor, com.github.javaparser.ast.type.Type, com.github.javaparser.ast.Node, com.github.javaparser.ast.NodeList, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.resolution.types.ResolvedType / ResolvedArrayType, AnnotationExpr, TokenRange, ObservableProperty, ArrayType.ArrayBracketPair, ArrayType.Origin, ArrayTypeMetaModel, Pair, Range). The combination of many incoming references from diverse AST/visitor/printer/resolution classes and multiple outgoing ties to core abstractions and meta-model/resolution types indicates ArrayType functions as a hub with widespread coupling, satisfying the Hub-like Modularization smell."
    },
    {
        "identifier": "com.github.javaparser.ast.observer.PropagatingAstObserver",
        "detection": false,
        "justification": "PropagatingAstObserver has outgoing dependencies to 4 abstractions: com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.ast.Node, com.github.javaparser.ast.observer.AstObserver, and com.github.javaparser.ast.NodeList. It has a single incoming dependency shown: com.github.javaparser.ast.Node depends on PropagatingAstObserver. The Hub-like Modularization smell requires an abstraction to have dependencies (both incoming and outgoing) with a large number of other abstractions; here the incoming count is 1 and the outgoing count is 4, which does not constitute a large number of bidirectional connections, so the smell is not detected."
    },
    {
        "identifier": "foo.OtherClass",
        "detection": false,
        "justification": "Both incoming_dependencies and outgoing_dependencies are empty (0 incoming, 0 outgoing). Hub-like Modularization requires an abstraction to have dependencies with a large number of other abstractions; here there are no dependencies, so the smell is not present."
    },
    {
        "identifier": "com.github.javaparser.ast.validator.postprocessors.Java12PostProcessor",
        "detection": false,
        "justification": "Incoming dependencies: 0 (incoming_dependencies is empty). Outgoing dependencies: 0 (outgoing_dependencies is empty). Hub-like Modularization requires many incoming and outgoing dependencies; this class has none, so the smell is not present."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.contexts.WhileStatementContext",
        "detection": false,
        "justification": "WhileStatementContext has multiple outgoing dependencies (7): com.github.javaparser.ast.stmt.WhileStmt, com.github.javaparser.symbolsolver.javaparsermodel.PatternVariableResult, com.github.javaparser.resolution.TypeSolver, com.github.javaparser.ast.expr.Expression, com.github.javaparser.symbolsolver.javaparsermodel.PatternVariableVisitor, com.github.javaparser.ast.Node, com.github.javaparser.symbolsolver.javaparsermodel.NormalCompletionVisitor. However, it has zero incoming dependencies (no other abstractions depend on it). Hub-like Modularization requires an abstraction to have both a large number of incoming and outgoing dependencies; the absence of any incoming dependencies prevents classifying WhileStatementContext as a hub."
    },
    {
        "identifier": "foo.OtherClass.InnerClass",
        "detection": false,
        "justification": "The class has no incoming or outgoing dependencies (incoming_dependencies: [], outgoing_dependencies: []), so it does not depend on or is depended on by many other abstractions and therefore is not hub-like."
    },
    {
        "identifier": "com.github.javaparser.metamodel.LocalClassDeclarationStmtMetaModel",
        "detection": false,
        "justification": "Hub-like modularization is not detected: the class has only 1 outgoing dependency (com.github.javaparser.metamodel.PropertyMetaModel) and only 2 incoming dependencies (com.github.javaparser.ast.stmt.LocalClassDeclarationStmt and com.github.javaparser.metamodel.JavaParserMetaModel). Although JavaParserMetaModel lists many dependencies, LocalClassDeclarationStmtMetaModel itself is referenced by only two abstractions and depends on only one, which does not constitute a hub with large numbers of incoming and outgoing relationships."
    },
    {
        "identifier": "com.github.javaparser.serialization.JavaParserJsonDeserializer",
        "detection": false,
        "justification": "Hub-like Modularization requires an abstraction to have dependencies (both incoming and outgoing) with a large number of other abstractions. The analyzed class has 0 incoming dependencies (incoming_dependencies is empty) and 9 outgoing dependencies: StaticJavaParser, BaseNodeMetaModel, CompilationUnit, Node, JavaParserMetaModel, PropertyMetaModel, NodeList, Position, JavaToken. Because there are no incoming dependencies and the outgoing dependency set is limited in size, the class does not meet the criteria for a hub-like module."
    },
    {
        "identifier": "a.RefCycleClassFailure",
        "detection": false,
        "justification": "The class has 0 outgoing dependencies and 0 incoming dependencies (both lists are empty). Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; this class has none, so the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.metamodel.SwitchExprMetaModel",
        "detection": false,
        "justification": "SwitchExprMetaModel has only 1 outgoing dependency (com.github.javaparser.metamodel.PropertyMetaModel) and only 2 incoming dependencies (com.github.javaparser.ast.expr.SwitchExpr and com.github.javaparser.metamodel.JavaParserMetaModel). Hub-like Modularization requires an abstraction to have incoming and outgoing dependencies with a large number of other abstractions; the provided data does not show a large number of connections for SwitchExprMetaModel. (Although JavaParserMetaModel lists many dependencies, those are outgoing from JavaParserMetaModel and do not increase the incoming/outgoing degree of SwitchExprMetaModel beyond the two incoming edges shown.)"
    },
    {
        "identifier": "com.github.javaparser.ast.visitor.GenericVisitorAdapter",
        "detection": false,
        "justification": "The class has a large number of outgoing dependencies (107 distinct outgoing types listed, e.g. com.github.javaparser.ast.Node, com.github.javaparser.ast.CompilationUnit, com.github.javaparser.ast.body.MethodDeclaration, com.github.javaparser.ast.expr.MethodCallExpr, com.github.javaparser.ast.body.ClassOrInterfaceDeclaration), but only a single incoming dependency is shown (com.github.javaparser.symbolsolver.resolution.typeinference.ControlFlowLogic). Hub-like modularization requires an abstraction to have many dependencies both incoming and outgoing; here the incoming dependency count is not large, so the hub-like smell is not present."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.resolution.typesolvers.ClassLoaderTypeSolver",
        "detection": false,
        "justification": "ClassLoaderTypeSolver has 4 outgoing dependencies (com.github.javaparser.resolution.model.SymbolReference, com.github.javaparser.resolution.TypeSolver, com.github.javaparser.symbolsolver.utils.ModuleLayerHelper, com.github.javaparser.symbolsolver.reflectionmodel.ReflectionFactory) and only 1 incoming dependency (from com.github.javaparser.symbolsolver.resolution.typesolvers.TypeSolverBuilder). Both the number of incoming (1) and outgoing (4) relationships are low and do not indicate an abstraction acting as a hub with many incoming and outgoing connections, so Hub-like Modularization is not detected."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.resolution.typeinference.constraintformulas.ExpressionCompatibleWithType",
        "detection": false,
        "justification": "ExpressionCompatibleWithType has a high number of outgoing dependencies (examples: FunctionalInterfaceLogic, Pair, InferenceVariable, JavaParserFacade, ResolvedType, Statement, TypeSolver, Expression, TypeInferenceCache, ControlFlowLogic, TypeInference, BoundSet, LambdaExpr, MethodType, EnclosedExpr, BlockStmt, TypeHelper, ConditionalExpr), indicating substantial fan-out across many packages. However, it has only a single incoming dependency in the provided data (referenced by com.github.javaparser.symbolsolver.resolution.typeinference.TypeInference). The Hub-like Modularization smell requires having dependencies (both incoming and outgoing) with a large number of other abstractions; here fan-out is large but fan-in is minimal, so the class does not meet the definition of a hub."
    },
    {
        "identifier": "com.github.javaparser.ast.expr.BinaryExpr.Operator",
        "detection": false,
        "justification": "The class has only one incoming dependency (from com.github.javaparser.ast.expr.BinaryExpr) and one outgoing dependency (to com.github.javaparser.ast.expr.AssignExpr). Hub-like Modularization requires an abstraction to have dependencies with a large number of other abstractions; the provided data shows low incoming and outgoing dependency counts, so the smell is not present."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javassistmodel.JavassistMethodLikeDeclarationAdapter",
        "detection": false,
        "justification": "The class has a relatively small number of dependencies: 6 outgoing dependencies (ResolvedParameterDeclaration, ResolvedType, TypeSolver, ResolvedMethodLikeDeclaration, JavassistUtils, ResolvedReferenceTypeDeclaration) and 2 incoming dependencies (JavassistMethodDeclaration, JavassistConstructorDeclaration). Hub-like Modularization requires an abstraction to have incoming and outgoing relationships with a large number of other abstractions. The incoming set is limited to two closely related classes and the outgoing set is modest, so this class does not exhibit hub-like modularization."
    },
    {
        "identifier": "com.github.javaparser.generator.core.visitor.EqualsVisitorGenerator",
        "detection": false,
        "justification": "Not detected: Hub-like Modularization requires the class to have both many incoming and many outgoing dependencies. The provided data shows zero incoming dependencies (incoming_dependencies is empty) and only five outgoing dependencies (com.github.javaparser.metamodel.BaseNodeMetaModel, com.github.javaparser.ast.stmt.BlockStmt, com.github.javaparser.ast.CompilationUnit, com.github.javaparser.ast.body.MethodDeclaration, com.github.javaparser.utils.SourceRoot). Because there are no incoming links and the number of outgoing links is small, this class does not exhibit a hub-like dependency pattern."
    },
    {
        "identifier": "com.github.javaparser.ast.validator.postprocessors.Java11PostProcessor",
        "detection": false,
        "justification": "The class has 0 incoming dependencies and 0 outgoing dependencies. Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; with zero in both directions, this class is not a hub."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver",
        "detection": false,
        "justification": "Incoming dependencies: 2 (com.github.javaparser.symbolsolver.utils.SymbolSolverCollectionStrategy, com.foo.Widget). Outgoing dependencies: 7 (SymbolReference; InMemoryCache; TypeSolver; CombinedTypeSolver.ExceptionHandlers; UnsolvedSymbolException; ResolvedReferenceTypeDeclaration; Cache). Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing relationships. Although CombinedTypeSolver has multiple outgoing dependencies across packages, it has only 2 incoming dependents in the provided data, so it does not meet the 'hub-like' criterion in isolation."
    },
    {
        "identifier": "com.github.javaparser.printer.configuration.Indentation.IndentType",
        "detection": false,
        "justification": "The class has 0 outgoing dependencies and only 1 incoming dependency (from com.github.javaparser.printer.configuration.Indentation). Hub-like Modularization requires many incoming and outgoing relationships with other abstractions; this class does not meet that criterion."
    },
    {
        "identifier": "com.github.javaparser.metamodel.AssignExprMetaModel",
        "detection": false,
        "justification": "AssignExprMetaModel has 1 outgoing dependency (com.github.javaparser.metamodel.PropertyMetaModel) and 2 incoming dependencies (com.github.javaparser.ast.expr.AssignExpr and com.github.javaparser.metamodel.JavaParserMetaModel). This is not a large number of both incoming and outgoing relationships, so it does not meet the criteria for Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.metamodel.LabeledStmtMetaModel",
        "detection": false,
        "justification": "LabeledStmtMetaModel has only one direct outgoing dependency: com.github.javaparser.metamodel.PropertyMetaModel. It has two incoming dependents in the provided data: com.github.javaparser.ast.stmt.LabeledStmt and com.github.javaparser.metamodel.JavaParserMetaModel. Although JavaParserMetaModel itself lists many dependencies, it is a single incoming abstraction. Because the analyzed class does not have a large number of distinct incoming and outgoing abstraction dependencies, it does not meet the Hub-like Modularization smell criteria."
    },
    {
        "identifier": "com.github.javaparser.UnicodeEscapeProcessingProvider.PositionUpdate",
        "detection": false,
        "justification": "The class has 0 outgoing dependencies and only 1 incoming dependency (from com.github.javaparser.UnicodeEscapeProcessingProvider). Hub-like Modularization requires an abstraction to have large numbers of both incoming and outgoing dependencies; this class does not meet those criteria."
    },
    {
        "identifier": "com.github.javaparser.ast.expr.AssignExpr.Operator",
        "detection": false,
        "justification": "AssignExpr.Operator has only 1 outgoing dependency (com.github.javaparser.ast.expr.BinaryExpr) and 1 incoming dependency (com.github.javaparser.ast.expr.AssignExpr). The total number of distinct connected abstractions is 2, which is not a large number of both incoming and outgoing dependencies required to qualify as Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.metamodel.BaseNodeMetaModel",
        "detection": false,
        "justification": "BaseNodeMetaModel has a large number of incoming dependencies (≈29 distinct classes such as com.github.javaparser.metamodel.PropertyMetaModel, com.github.javaparser.serialization.JavaParserJsonDeserializer, many generator and visitor generator classes) but only a small number of outgoing dependencies (3: com.github.javaparser.ast.Node, com.github.javaparser.ast.NodeList, com.github.javaparser.utils.Utils). The hub-like modularization smell requires the abstraction to have many both incoming and outgoing connections; here the outgoing fan-out is low, so the condition is not met."
    },
    {
        "identifier": "(default package).InnerClassFieldContainer",
        "detection": false,
        "justification": "Class has 0 outgoing dependencies (outgoing_dependencies is empty) and only 1 incoming dependency ((default package).FieldDotExpressions). Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; these counts are too low, so the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.javasymbolsolver.javassist_symbols.main_jar.SubClassIncludedJar",
        "detection": false,
        "justification": "incoming_dependencies: 0, outgoing_dependencies: 0. Hub-like Modularization requires many incoming and outgoing dependencies; this class has none, so it is not a hub."
    },
    {
        "identifier": "com.github.javaparser.metamodel.StatementMetaModel",
        "detection": false,
        "justification": "StatementMetaModel has no outgoing dependencies (outgoing_dependencies = []). It has only two incoming dependents: com.github.javaparser.ast.stmt.Statement and com.github.javaparser.metamodel.JavaParserMetaModel (incoming count = 2). The Hub-like Modularization smell requires an abstraction to have dependencies (both incoming and outgoing) with a large number of other abstractions; StatementMetaModel lacks outgoing links and has only two incoming links, so it is not a hub."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.contexts.ContextHelper",
        "detection": false,
        "justification": "ContextHelper has a small set of direct outgoing dependencies (2: com.github.javaparser.resolution.Context, com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration) and a limited number of incoming dependents (4 distinct classes: com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassDeclaration, com.github.javaparser.symbolsolver.reflectionmodel.ReflectionRecordDeclaration, com.github.javaparser.symbolsolver.javaparsermodel.contexts.MethodCallExprContext, com.github.javaparser.symbolsolver.javassistmodel.JavassistUtils). The total number of direct incoming+outgoing relationships (6) is low and does not exhibit the large, widespread coupling characteristic of a hub-like module."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.contexts.EnumDeclarationContext",
        "detection": false,
        "justification": "Hub-like Modularization requires an abstraction to have dependencies both incoming and outgoing with a large number of other abstractions. In isolation, EnumDeclarationContext has 5 outgoing dependencies: com.github.javaparser.resolution.model.SymbolReference, com.github.javaparser.symbolsolver.javaparsermodel.contexts.JavaParserTypeDeclarationAdapter, com.github.javaparser.resolution.TypeSolver, com.github.javaparser.ast.body.EnumDeclaration, com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration, and 0 incoming dependencies. Because there are no incoming dependencies (and thus it does not exhibit the required many-to-many coupling), the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.contexts.ConstructorContext",
        "detection": false,
        "justification": "ConstructorContext has outgoing dependencies to 3 abstractions: com.github.javaparser.resolution.TypeSolver, com.github.javaparser.ast.body.ConstructorDeclaration, and com.github.javaparser.ast.Node, but has 0 incoming dependencies. Hub-like Modularization requires an abstraction to have many both incoming and outgoing dependencies. Although the outgoing targets themselves have many dependencies (e.g., ConstructorDeclaration -> 17 deps, Node -> 24 deps, TypeSolver -> 3 deps), the analyzed class lacks incoming connections, so it does not meet the definition of a hub."
    },
    {
        "identifier": "com.github.javaparser.ast.nodeTypes.modifiers.NodeWithStaticModifier",
        "detection": false,
        "justification": "Both incoming and outgoing dependency lists are empty (incoming_dependencies = [], outgoing_dependencies = []). Hub-like Modularization requires an abstraction to have many incoming and outgoing dependencies; this class has none, so the smell is not present."
    },
    {
        "identifier": "com.github.javaparser.ast.validator.language_level_validations.Java1_1Validator",
        "detection": false,
        "justification": "Not a hub: the class has no incoming dependencies (incoming_dependencies is empty) and only two direct outgoing dependencies (com.github.javaparser.ast.validator.Validator and com.github.javaparser.ParserConfiguration). Considering the class in isolation, it does not have both many incoming and many outgoing dependency relationships required to qualify as Hub-like Modularization."
    },
    {
        "identifier": "(default package).InnerClassDotExpressions.InnerInnerInnerClass",
        "detection": false,
        "justification": "Incoming dependencies = 0 and outgoing dependencies = 0. The class has no dependency links with other abstractions, so it does not exhibit hub-like modularization."
    },
    {
        "identifier": "com.github.javaparser.ast.expr.UnaryExpr",
        "detection": true,
        "justification": "UnaryExpr has a large number of incoming and a non-trivial number of outgoing dependencies. Outgoing dependencies (10) include core AST abstractions and meta/utility types: com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.Range, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.ast.expr.Expression, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.TokenRange, com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.metamodel.UnaryExprMetaModel, com.github.javaparser.ast.Node, and com.github.javaparser.ast.expr.UnaryExpr.Operator. Incoming dependencies are numerous (26+) — many visitor and tooling classes reference UnaryExpr (examples: com.github.javaparser.symbolsolver.javaparsermodel.DefaultVisitorAdapter, com.github.javaparser.symbolsolver.javaparsermodel.TypeExtractor, com.github.javaparser.ast.visitor.VoidVisitor, HashCodeVisitor, EqualsVisitor, CloneVisitor, PrettyPrintVisitor, DefaultPrettyPrinterVisitor, GeneratedJavaParser, utils.Utils, and various Generic/Void visitor variants). The combination of many incoming references from diverse visitors/tools and multiple outgoing links to core AST and meta-model classes indicates a hub-like modularization smell."
    },
    {
        "identifier": "com.github.javaparser.resolution.model.typesystem.NullType",
        "detection": false,
        "justification": "NullType has very few direct dependencies: outgoing = 1 (com.github.javaparser.resolution.types.ResolvedType) and incoming = 1 (com.github.javaparser.symbolsolver.javaparsermodel.TypeExtractor). Hub-like Modularization requires an abstraction to have many incoming and outgoing dependency relations with a large number of other abstractions. The provided data shows NullType is only directly connected to ResolvedType (outgoing) and referenced by TypeExtractor (incoming), so it does not exhibit hub-like characteristics."
    },
    {
        "identifier": "com.github.javaparser.ast.body.Parameter",
        "detection": true,
        "justification": "The class has a large number of incoming dependencies (35 distinct clients depend on it, e.g. com.github.javaparser.symbolsolver.JavaSymbolSolver, many visitor implementations such as com.github.javaparser.ast.visitor.VoidVisitor, GenericVisitor, ModifierVisitor, numerous visitor adapters and utilities like PrettyPrintVisitor and GeneratedJavaParser) while also depending on many other abstractions itself (14 outgoing dependencies, e.g. com.github.javaparser.ast.Node, com.github.javaparser.ast.type.Type, com.github.javaparser.ast.type.ArrayType, com.github.javaparser.ast.NodeList, com.github.javaparser.ast.expr.SimpleName, com.github.javaparser.TokenRange, com.github.javaparser.Range, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.resolution.declarations.ResolvedParameterDeclaration). Because it both uses many abstractions and is used by many unrelated components across visitors, parsers, printers and the symbol solver, it functions as a hub-like module (high fan-in and high fan-out) and thus exhibits the Hub-like Modularization smell."
    },
    {
        "identifier": "com.github.javaparser.ast.expr.BinaryExpr",
        "detection": true,
        "justification": "BinaryExpr has many incoming and outgoing dependencies: outgoing dependencies include ~11 direct collaborators (e.g. com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.expr.AssignExpr, com.github.javaparser.ast.expr.BinaryExpr.Operator, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.ast.expr.Expression, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.TokenRange, com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.ast.Node, com.github.javaparser.metamodel.BinaryExprMetaModel, com.github.javaparser.Range). It also has a large number of incoming dependencies from many other abstractions (numerous visitor implementations and utilities such as DefaultVisitorAdapter, JavaParserFacade, TypeExtractor, many ast.visitor.* classes like VoidVisitor, GenericVisitor, HashCodeVisitor, EqualsVisitor, CloneVisitor, PrettyPrintVisitor, DefaultPrettyPrinterVisitor, GeneratedJavaParser, etc.). Because BinaryExpr both depends on many other classes and is depended upon by a large set of unrelated modules (visitors, symbol solver, parser, printers, meta-model), it functions as a hub-like abstraction and meets the Hub-like Modularization smell criteria."
    },
    {
        "identifier": "com.github.javaparser.resolution.types.ResolvedArrayType",
        "detection": false,
        "justification": "ResolvedArrayType has a small number of outgoing dependencies (2): com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration and com.github.javaparser.resolution.types.ResolvedType. It has incoming references from 6 other abstractions (com.github.javaparser.symbolsolver.javaparsermodel.TypeExtractor, com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserParameterDeclaration, com.github.javaparser.ast.type.ArrayType, com.github.javaparser.resolution.model.typesystem.LazyType, com.github.javaparser.resolution.types.ResolvedType, com.github.javaparser.resolution.logic.MethodResolutionLogic). Because hub-like modularization requires many dependencies on both sides (large number of incoming and outgoing), and ResolvedArrayType has few outgoing dependencies, the smell is not detected."
    },
    {
        "identifier": "japa.parser.comments.ClassWithOrphanComments",
        "detection": false,
        "justification": "The class has 0 outgoing dependencies and 0 incoming dependencies (both outgoing_dependencies and incoming_dependencies are empty). Hub-like Modularization requires an abstraction to have dependencies with a large number of other abstractions; this class has none, so the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.ParserConfiguration.UnicodeEscapeProcessor",
        "detection": false,
        "justification": "The class has only one outgoing dependency (com.github.javaparser.UnicodeEscapeProcessingProvider) and zero incoming dependencies. Hub-like modularization requires an abstraction to have many incoming and outgoing connections; here incoming_dependencies: [] and outgoing count = 1, so it does not qualify."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.utils.JavassistModuleHelper",
        "detection": false,
        "justification": "The class has 0 outgoing dependencies and only 1 incoming dependency (com.github.javaparser.symbolsolver.resolution.typesolvers.JarTypeSolver). Hub-like Modularization requires an abstraction to have dependencies (both incoming and outgoing) with a large number of other abstractions; the provided data shows low fan-in/fan-out, so the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.ParseProblemException",
        "detection": false,
        "justification": "Hub-like Modularization requires an abstraction to have many incoming and outgoing dependencies. The analyzed class has 1 outgoing dependency (com.github.javaparser.utils.LineSeparator) and 0 incoming dependencies. These counts are minimal and do not indicate a hub-like module."
    },
    {
        "identifier": "(default package).FieldContainer",
        "detection": false,
        "justification": "Incoming dependencies: 0 (incoming_dependencies is empty). Outgoing dependencies: 0 (outgoing_dependencies is empty). Hub-like Modularization requires an abstraction to have dependencies (both incoming and outgoing) with a large number of other abstractions; FieldContainer has none, so the smell is not detected."
    },
    {
        "identifier": "package_c.c",
        "detection": false,
        "justification": "The class has 0 outgoing dependencies and 0 incoming dependencies (both dependency lists are empty). Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; since neither is present, the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.printer.concretesyntaxmodel.CsmConditional",
        "detection": false,
        "justification": "CsmConditional has a small set of direct outgoing dependencies (5): com.github.javaparser.ast.Node, com.github.javaparser.printer.concretesyntaxmodel.CsmElement, com.github.javaparser.printer.concretesyntaxmodel.CsmConditional.Condition, com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.printer.SourcePrinter. It is referenced by a modest number of incoming dependencies (4): com.github.javaparser.printer.ConcreteSyntaxModel, com.github.javaparser.printer.concretesyntaxmodel.CsmElement, com.github.javaparser.printer.lexicalpreservation.LexicalDifferenceCalculator, com.github.javaparser.printer.lexicalpreservation.changes.Change. Hub-like Modularization requires an abstraction to have dependencies (both incoming and outgoing) with a large number of other abstractions; the counts here are small. Note that some outgoing targets (e.g. Node) have many transitive dependencies, but considering the class in isolation and its direct relations, CsmConditional does not exhibit hub-like coupling."
    },
    {
        "identifier": "com.github.javaparser.resolution.types.ResolvedVoidType",
        "detection": false,
        "justification": "ResolvedVoidType has multiple incoming dependencies (used by ReflectionFactory, TypeExtractor, JavassistFactory, JavassistUtils, and VoidType) but only a single outgoing dependency (depends on com.github.javaparser.resolution.types.ResolvedType). Hub-like modularization requires an abstraction to have many both incoming and outgoing ties; here the outgoing dependencies are minimal (one), so ResolvedVoidType is not a hub."
    },
    {
        "identifier": "(default package).C",
        "detection": false,
        "justification": "Class (default package).C has only 1 incoming dependency (from (default package).StackOverflowTestCase) and 1 outgoing dependency (to (default package).D). These low counts of both incoming and outgoing dependencies do not constitute a hub-like modularization."
    },
    {
        "identifier": "com.github.javaparser.generator.core.visitor.HashCodeVisitorGenerator",
        "detection": false,
        "justification": "Not detected: The class has no incoming dependencies (incoming_dependencies is empty) and only seven direct outgoing dependencies: com.github.javaparser.StaticJavaParser, com.github.javaparser.metamodel.BaseNodeMetaModel, com.github.javaparser.ast.stmt.BlockStmt, com.github.javaparser.ast.CompilationUnit, com.github.javaparser.utils.SeparatedItemStringBuilder, com.github.javaparser.ast.body.MethodDeclaration, com.github.javaparser.utils.SourceRoot. Hub-like Modularization requires an abstraction to have both many incoming and many outgoing dependencies; the provided data shows zero incoming and a moderate number of outgoing, so the smell is not present."
    },
    {
        "identifier": "another.A",
        "detection": false,
        "justification": "Incoming and outgoing dependencies are both empty (incoming_dependencies = 0, outgoing_dependencies = 0). The class has no widespread incoming or outgoing connections, so it does not exhibit Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.utils.StringEscapeUtils.UnicodeUnescaper",
        "detection": false,
        "justification": "The class is not a hub: incoming_dependencies = 0 and outgoing_dependencies = 0 (both empty). Hub-like Modularization requires an abstraction to have many incoming and outgoing dependencies, which is not the case here."
    },
    {
        "identifier": "com.github.javaparser.printer.concretesyntaxmodel.CsmTextBlock",
        "detection": false,
        "justification": "Hub-like Modularization requires an abstraction to have both many incoming and many outgoing dependencies. CsmTextBlock has outgoing dependencies to three abstractions: com.github.javaparser.printer.SourcePrinter, com.github.javaparser.ast.observer.ObservableProperty, and com.github.javaparser.ast.Node, but it has zero incoming dependencies (incoming_dependencies is empty). With only 3 outgoing and 0 incoming relationships, it does not meet the 'hub' condition of having a large number of both incoming and outgoing dependencies."
    },
    {
        "identifier": "com.github.javaparser.printer.concretesyntaxmodel.CsmIndent",
        "detection": false,
        "justification": "CsmIndent has 3 outgoing dependencies (com.github.javaparser.printer.lexicalpreservation.TextElement, com.github.javaparser.printer.SourcePrinter, com.github.javaparser.ast.Node) and 0 incoming dependencies. Hub-like Modularization requires an abstraction to have many incoming and outgoing dependencies. Because there are no incoming dependencies (incoming_dependencies is empty), CsmIndent does not qualify as a hub. Note: although the outgoing targets themselves depend on many other types, the class is analyzed in isolation and still lacks the required high number of incoming couplings."
    },
    {
        "identifier": "com.packageName.InnerStaticClassFieldContainer",
        "detection": false,
        "justification": "Not detected: the class has 0 outgoing dependencies and 1 incoming dependency (from (default package).InnerStaticClassFieldDotExpressions -> com.packageName.InnerStaticClassFieldContainer). With only one incoming and no outgoing relations, it does not exhibit the many-to-many coupling characteristic of a hub."
    },
    {
        "identifier": "com.github.javaparser.ast.body.CompactConstructorDeclaration",
        "detection": true,
        "justification": "The class has a large number of both outgoing and incoming dependencies. Outgoing: it depends on at least 13 distinct abstractions (examples: com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.ast.NodeList, com.github.javaparser.ast.expr.SimpleName, com.github.javaparser.TokenRange, com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.resolution.declarations.ResolvedConstructorDeclaration, com.github.javaparser.ast.Node, com.github.javaparser.metamodel.CompactConstructorDeclarationMetaModel, com.github.javaparser.ast.stmt.BlockStmt, com.github.javaparser.ast.AccessSpecifier). Incoming: it is referenced by a large set of distinct visitors and tools (at least 21 incoming abstractions), e.g. many com.github.javaparser.ast.visitor.* classes (VoidVisitor, GenericVisitor, HashCodeVisitor, EqualsVisitor, ModifierVisitor, CloneVisitor, various VisitorAdapters), printers (PrettyPrintVisitor, DefaultPrettyPrinterVisitor), parser/generator (GeneratedJavaParser), and other AST types (BodyDeclaration, NodeFinderVisitor). Because it both depends on many core/metamodel/observer/resolution types and is depended-on by many visitor/printer/parser classes, it functions as a central hub connecting many unrelated abstractions — matching the Hub-like Modularization smell."
    },
    {
        "identifier": "com.github.javaparser.ast.visitor.ObjectIdentityEqualsVisitor",
        "detection": false,
        "justification": "Although the class has a large number of outgoing dependencies (105 distinct other abstractions, e.g. com.github.javaparser.ast.expr.UnaryExpr, com.github.javaparser.ast.Node, com.github.javaparser.ast.CompilationUnit), it has zero incoming dependencies in the provided data. The Hub-like Modularization smell requires both many incoming and many outgoing connections; here incoming dependencies = 0, so the smell is not detected."
    },
    {
        "identifier": "(default package).FieldDotExpressions.InnerInnerClass",
        "detection": false,
        "justification": "The class has 0 incoming dependencies and 0 outgoing dependencies (incoming_dependencies and outgoing_dependencies arrays are empty). Therefore it does not have dependencies with a large number of other abstractions and does not exhibit Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.ast.body.RecordDeclaration",
        "detection": true,
        "justification": "RecordDeclaration has a high number of both outgoing and incoming dependencies. Outgoing: it depends on 11 distinct abstractions (examples: com.github.javaparser.ast.Node, com.github.javaparser.ast.NodeList, com.github.javaparser.ast.expr.SimpleName, com.github.javaparser.TokenRange, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.ast.body.ReceiverParameter, com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration, com.github.javaparser.metamodel.RecordDeclarationMetaModel). Incoming: at least 28 different clients depend on RecordDeclaration (examples: many visitor implementations such as com.github.javaparser.ast.visitor.VoidVisitor, GenericVisitor, HashCodeVisitor, EqualsVisitor, ModifierVisitor and adapters like VoidVisitorAdapter; symbol-solver classes such as com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserRecordDeclaration and related adapters/contexts; printers and validators such as PrettyPrintVisitor, DefaultPrettyPrinterVisitor, RecordDeclarationValidator; plus parser/generator classes). Because RecordDeclaration exhibits large in-degree (many callers across visitors, symbol solver, printers, validators) and substantial out-degree (ties into core AST/node/metamodel/resolution types), it functions as a hub-like abstraction and meets the Hub-like Modularization smell criteria."
    },
    {
        "identifier": "japa.bdd.samples.JavaConcepts.Y",
        "detection": false,
        "justification": "The class has 0 incoming dependencies and 0 outgoing dependencies. Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies, which is not the case here."
    },
    {
        "identifier": "com.github.javaparser.GeneratedJavaParser.JJCalls",
        "detection": false,
        "justification": "Outgoing dependencies: 1 (com.github.javaparser.Token). Incoming dependencies: 1 (from com.github.javaparser.GeneratedJavaParser). Hub-like Modularization requires an abstraction to have dependencies (both incoming and outgoing) with a large number of other abstractions; the provided data shows only a single incoming and a single outgoing dependency for JJCalls, so it does not meet the hub-like criterion."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.declarators.TypePatternSymbolDeclarator",
        "detection": false,
        "justification": "Incoming dependencies are empty (no other abstractions depend on this class). Outgoing dependencies are limited to three abstractions: com.github.javaparser.resolution.TypeSolver, com.github.javaparser.ast.expr.TypePatternExpr, and com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserSymbolDeclaration. Although those target classes list multiple dependencies of their own, the analyzed class does not exhibit a large number of both incoming and outgoing ties required for Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration",
        "detection": false,
        "justification": "Although ResolvedTypeParameterDeclaration has a very large number of incoming dependencies (31 distinct classes in the provided data — e.g. MethodDeclarationCommonLogic, ReflectionClassDeclaration, JavaParserTypeParameter, MethodUsage, LazyType, ReferenceTypeImpl, TypeInference, InferenceContext, MethodResolutionLogic), its outgoing dependency set is small (3 classes: com.github.javaparser.resolution.types.ResolvedReferenceType, com.github.javaparser.resolution.declarations.ResolvedTypeParametrizable, com.github.javaparser.resolution.types.ResolvedType). Hub-like Modularization requires an abstraction to have dependencies with a large number of other abstractions in both directions; here the fan-in is large but the fan-out is limited, so the smell is not detected."
    },
    {
        "identifier": "(default package).b",
        "detection": false,
        "justification": "The class has no incoming or outgoing dependencies: incoming_dependencies = [], outgoing_dependencies = []. The analyzed_package.dependencies = []. Total external dependencies = 0. Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; since this class has none, the smell is not present."
    },
    {
        "identifier": "com.github.javaparser.resolution.types.ResolvedWildcard",
        "detection": false,
        "justification": "Incoming dependencies are numerous (examples: com.github.javaparser.symbolsolver.reflectionmodel.ReflectionFactory, com.github.javaparser.symbolsolver.javaparsermodel.contexts.MethodCallExprContext, com.github.javaparser.symbolsolver.resolution.typeinference.LeastUpperBoundLogic, com.github.javaparser.symbolsolver.resolution.typeinference.TypeHelper, com.github.javaparser.symbolsolver.javassistmodel.JavassistUtils, com.github.javaparser.ast.type.WildcardType, com.github.javaparser.resolution.model.typesystem.LazyType, com.github.javaparser.resolution.types.ResolvedType, com.github.javaparser.resolution.types.ResolvedReferenceType, com.github.javaparser.resolution.types.parametrization.ResolvedTypeParameterValueProvider, com.github.javaparser.resolution.logic.InferenceContext, com.github.javaparser.resolution.logic.InferenceVariableType, com.github.javaparser.resolution.logic.MethodResolutionLogic), indicating many modules depend on ResolvedWildcard. However, the outgoing dependency set for ResolvedWildcard is small (only: com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration, com.github.javaparser.resolution.Context, com.github.javaparser.resolution.types.ResolvedType, and its inner BoundType). Hub-like Modularization requires an abstraction to have both large incoming and large outgoing coupling; here outgoing coupling is minimal, so the class is not a hub by this definition."
    },
    {
        "identifier": "com.github.javaparser.printer.Printer",
        "detection": false,
        "justification": "Printer has many incoming dependencies (referenced by: com.github.javaparser.ast.CompilationUnit, com.github.javaparser.ast.Node, com.github.javaparser.printer.ConfigurablePrinter, com.github.javaparser.printer.DefaultPrettyPrinter, com.github.javaparser.printer.PrettyPrinter, com.github.javaparser.printer.lexicalpreservation.LexicalPreservingPrinter, com.github.javaparser.generator.metamodel.MetaModelGenerator) but only a single outgoing dependency (com.github.javaparser.ast.Node). Hub-like Modularization requires an abstraction to have dependencies with a large number of other abstractions in both directions; Printer lacks a correspondingly large outgoing dependency set, so it is not a hub."
    },
    {
        "identifier": "com.github.javaparser.metamodel.CatchClauseMetaModel",
        "detection": false,
        "justification": "CatchClauseMetaModel has only 1 outgoing dependency (com.github.javaparser.metamodel.PropertyMetaModel) and only 2 incoming dependencies (com.github.javaparser.ast.stmt.CatchClause and com.github.javaparser.metamodel.JavaParserMetaModel). Hub-like Modularization requires an abstraction to have many incoming and many outgoing dependencies; the provided data shows limited incoming/outgoing links for CatchClauseMetaModel. (Note: PropertyMetaModel and JavaParserMetaModel themselves reference many other types, but that does not make CatchClauseMetaModel a hub given its own low degree of incoming/outgoing dependencies.)"
    },
    {
        "identifier": "(default package).D",
        "detection": false,
        "justification": "Class (default package).D has 0 outgoing dependencies and only 1 incoming dependency (from (default package).C). It does not have both incoming and outgoing dependencies with a large number of other abstractions, so it is not a hub-like module."
    },
    {
        "identifier": "com.github.javaparser.resolution.declarations.ResolvedParameterDeclaration",
        "detection": false,
        "justification": "Hub-like Modularization requires an abstraction to have dependencies both incoming and outgoing with a large number of other abstractions. ResolvedParameterDeclaration has many incoming dependencies (15 distinct callers shown, e.g. com.github.javaparser.symbolsolver.JavaSymbolSolver, com.github.javaparser.symbolsolver.declarations.common.MethodDeclarationCommonLogic, com.github.javaparser.symbolsolver.reflectionmodel.ReflectionMethodDeclaration, com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserMethodDeclaration, com.github.javaparser.ast.body.Parameter, com.github.javaparser.resolution.logic.MethodResolutionLogic), but its outgoing_dependencies list is empty. Because it lacks outgoing dependencies, it does not meet the definition requirement of having both extensive incoming and outgoing dependency ties and therefore is not detected as Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.printer.lexicalpreservation.TextElementIteratorsFactory.CascadingIterator",
        "detection": false,
        "justification": "No incoming or outgoing dependencies were reported (incoming_dependencies: 0, outgoing_dependencies: 0). The class does not have dependencies with a large number of other abstractions, so it does not exhibit Hub-like Modularization."
    },
    {
        "identifier": "foo.bar.differentpackage.AClass",
        "detection": false,
        "justification": "Not detected: hub-like modularization requires an abstraction to have many incoming and outgoing dependencies. AClass has 0 incoming dependencies and only 2 outgoing dependencies (foo.bar.AnInterface, foo.bar.BinaryExpr), so it does not exhibit a hub-like dependency pattern."
    },
    {
        "identifier": "(default package).Test1.Test3",
        "detection": false,
        "justification": "Class (default package).Test1.Test3 has 0 outgoing dependencies and 0 incoming dependencies. Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; since both counts are zero, the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.printer.lexicalpreservation.ChildTextElement",
        "detection": false,
        "justification": "ChildTextElement has 4 outgoing dependencies: LexicalPreservingVisitor, NodeText, LexicalPreservingPrinter, and Node, and 4 incoming dependents: DifferenceElementCalculator, Difference, TextElementIteratorsFactory, and LexicalPreservingVisitor. The dependency graph is small and concentrated within the lexicalpreservation printing subsystem (same package area) rather than spanning a large number of distinct abstractions. Because the number and scope of both incoming and outgoing connections are limited, it does not meet the criterion for Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.metamodel.TypeDeclarationMetaModel",
        "detection": false,
        "justification": "TypeDeclarationMetaModel has a single outgoing dependency: com.github.javaparser.metamodel.PropertyMetaModel, and only two incoming dependents: com.github.javaparser.ast.body.TypeDeclaration and com.github.javaparser.metamodel.JavaParserMetaModel. Hub-like Modularization requires an abstraction to have dependencies (both incoming and outgoing) with a large number of other abstractions. The provided data shows few incoming classes and only one outgoing class (even though JavaParserMetaModel references many meta-models, it is a single incoming dependent), so this class does not meet the criterion for a hub."
    },
    {
        "identifier": "com.github.javaparser.ast.observer.AstObserver.ListChangeType",
        "detection": false,
        "justification": "The class has 0 outgoing dependencies and only 1 incoming dependency (from com.github.javaparser.ast.observer.AstObserver). Hub-like Modularization requires an abstraction to have both many incoming and outgoing dependencies with numerous other abstractions; here the dependency counts are minimal, so the smell is not present."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.reflectionmodel.comparators.ParameterComparator",
        "detection": false,
        "justification": "ParameterComparator has 1 outgoing dependency (com.github.javaparser.symbolsolver.reflectionmodel.comparators.ClassComparator) and 1 incoming dependency (from com.github.javaparser.symbolsolver.reflectionmodel.comparators.MethodComparator). Hub-like Modularization requires an abstraction to have dependencies with a large number of other abstractions; here both incoming and outgoing dependency counts are minimal (1 each), so the smell is not present."
    },
    {
        "identifier": "com.github.javaparser.printer.lexicalpreservation.DifferenceElementCalculator.ChildPositionInfo",
        "detection": false,
        "justification": "The class has only one incoming dependency (referenced by com.github.javaparser.printer.lexicalpreservation.DifferenceElementCalculator) and one outgoing dependency (depends on com.github.javaparser.ast.Node). Both incoming and outgoing dependency counts are low (1 each), so it does not exhibit Hub-like Modularization. Note: com.github.javaparser.ast.Node's many dependencies are not direct dependencies of this class and are not considered here (analysis is class-local)."
    },
    {
        "identifier": "com.github.javaparser.JavaToken.Kind",
        "detection": false,
        "justification": "The class has 0 incoming dependencies and 0 outgoing dependencies (both dependency lists are empty). Hub-like Modularization requires many incoming and outgoing dependencies with other abstractions; this class has none, so it is not a hub."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.contexts.DoStatementContext",
        "detection": false,
        "justification": "DoStatementContext has 0 incoming dependencies and 6 outgoing direct dependencies (PatternVariableResult, TypeSolver, Expression, PatternVariableVisitor, NormalCompletionVisitor, DoStmt). Hub-like Modularization requires a large number of both incoming and outgoing dependencies; this class lacks incoming dependencies and only has a small set of outgoing dependencies. Transitive/deeper dependency lists of the outgoing targets are not counted when analyzing the class in isolation."
    },
    {
        "identifier": "main.GrandParent.MyEnum",
        "detection": false,
        "justification": "The class has 0 incoming dependencies and 0 outgoing dependencies (incoming_dependencies and outgoing_dependencies are empty). Hub-like Modularization requires an abstraction to have dependencies with a large number of other abstractions; this class does not meet that criterion."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.contexts.ForEachStatementContext",
        "detection": false,
        "justification": "ForEachStatementContext has multiple outgoing dependencies (8: com.github.javaparser.resolution.model.SymbolReference, com.github.javaparser.ast.body.VariableDeclarator, com.github.javaparser.resolution.TypeSolver, com.github.javaparser.symbolsolver.javaparsermodel.contexts.StatementContext, com.github.javaparser.ast.stmt.ForEachStmt, com.github.javaparser.ast.Node, com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserSymbolDeclaration, com.github.javaparser.resolution.Navigator) but has zero incoming dependencies in the provided data. Hub-like Modularization requires an abstraction to have both a large number of incoming and outgoing dependencies; because incoming_dependencies is empty, this class does not meet the hub criterion."
    },
    {
        "identifier": "com.github.javaparser.printer.lexicalpreservation.TextElementIteratorsFactory.Provider",
        "detection": false,
        "justification": "The class has 0 outgoing dependencies (empty dependency list) and only 1 incoming dependency: com.github.javaparser.printer.lexicalpreservation.TextElementIteratorsFactory. That single incoming reference (among the factory's dependencies: TextElement, NodeText, ChildTextElement, TextElementIteratorsFactory.Provider) does not constitute the large number of incoming/outgoing connections required for Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.metamodel.BreakStmtMetaModel",
        "detection": false,
        "justification": "BreakStmtMetaModel has only 1 outgoing dependency (com.github.javaparser.metamodel.PropertyMetaModel) and 2 incoming dependencies (com.github.javaparser.ast.stmt.BreakStmt and com.github.javaparser.metamodel.JavaParserMetaModel). Hub-like Modularization requires an abstraction to have many incoming and many outgoing dependencies. The provided data shows low counts of distinct incoming/outgoing relationships, so this class is not a hub."
    },
    {
        "identifier": "main.Child",
        "detection": false,
        "justification": "Not detected: the class has 0 outgoing dependencies and only 1 incoming dependency (from main.Main). Hub-like Modularization requires an abstraction to have incoming and outgoing connections with a large number of other abstractions; here only main.Main references main.Child (incoming), and outgoing_dependencies is empty."
    },
    {
        "identifier": "com.github.javaparser.printer.lexicalpreservation.LexicalPreservingPrinter",
        "detection": false,
        "justification": "Although LexicalPreservingPrinter has a large number of outgoing dependencies (≈23 distinct external classes such as com.github.javaparser.Range, com.github.javaparser.ast.Node, com.github.javaparser.JavaToken, com.github.javaparser.printer.ConcreteSyntaxModel, com.github.javaparser.printer.lexicalpreservation.NodeText, com.github.javaparser.printer.lexicalpreservation.LexicalDifferenceCalculator, com.github.javaparser.utils.Utils, com.github.javaparser.printer.printer.TokenTypes, etc.), it has a small number of incoming dependencies (only 4 classes depend on it: DifferenceElementCalculator, Difference, DefaultLexicalPreservingPrinter, ChildTextElement). Hub-like Modularization requires an abstraction to have both many incoming and many outgoing dependencies. Because the incoming dependency count is low, the class does not meet the definition of a hub."
    },
    {
        "identifier": "com.github.javaparser.utils.StringEscapeUtils.OctalUnescaper",
        "detection": false,
        "justification": "The class has 0 incoming dependencies and 0 outgoing dependencies (both dependency lists are empty). Hub-like Modularization requires an abstraction to have dependencies with a large number of other abstractions; with zero incoming and zero outgoing dependencies, this class does not exhibit the smell."
    },
    {
        "identifier": "com.github.javaparser.ast.type.Type",
        "detection": true,
        "justification": "The class has a large number of both incoming and outgoing dependencies. Outgoing: 21 direct dependencies (examples: com.github.javaparser.ast.type.VoidType, WildcardType, ArrayType, ClassOrInterfaceType, PrimitiveType, com.github.javaparser.ast.Node, com.github.javaparser.ast.NodeList, com.github.javaparser.TokenRange, com.github.javaparser.Range, com.github.javaparser.resolution.types.ResolvedType, com.github.javaparser.metamodel.TypeMetaModel, com.github.javaparser.ast.observer.ObservableProperty). Incoming: ~47 distinct classes depend on it across many modules (examples: com.github.javaparser.symbolsolver.JavaSymbolSolver, com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade, symbolsolver.TypeExtractor, many AST visitors and printers such as ModifierVisitor, PrettyPrintVisitor, CloneVisitor, parser components like GeneratedJavaParser/GeneratedJavaParserBase/StaticJavaParser, resolution components like Solver and SymbolResolver, and numerous AST node and body classes such as MethodDeclaration, FieldDeclaration, Parameter, VariableDeclarator, ArrayType). Because it is referenced by a very large set of unrelated abstractions and itself references many type- and AST-related abstractions, it functions as a central hub and therefore exhibits the Hub-like Modularization smell."
    },
    {
        "identifier": "com.github.javaparser.printer.concretesyntaxmodel.CsmElement",
        "detection": true,
        "justification": "CsmElement has many outgoing dependencies (8): com.github.javaparser.TokenTypes, com.github.javaparser.GeneratedJavaParserConstants, com.github.javaparser.ast.Node, com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.utils.LineSeparator, com.github.javaparser.printer.concretesyntaxmodel.CsmConditional, com.github.javaparser.printer.SourcePrinter, com.github.javaparser.printer.lexicalpreservation.TextElement. It also has many incoming dependencies (13) from diverse classes that depend on it: com.github.javaparser.printer.ConcreteSyntaxModel, com.github.javaparser.printer.concretesyntaxmodel.CsmList, com.github.javaparser.printer.concretesyntaxmodel.CsmConditional, com.github.javaparser.printer.lexicalpreservation.LexicalDifferenceCalculator, com.github.javaparser.printer.lexicalpreservation.Kept, com.github.javaparser.printer.lexicalpreservation.DifferenceElementCalculator, com.github.javaparser.printer.lexicalpreservation.LexicalPreservingPrinter, com.github.javaparser.printer.lexicalpreservation.Removed, com.github.javaparser.printer.lexicalpreservation.Difference, com.github.javaparser.printer.lexicalpreservation.ReshuffledDiffElementExtractor, com.github.javaparser.printer.lexicalpreservation.DifferenceElement, com.github.javaparser.printer.lexicalpreservation.Reshuffled, com.github.javaparser.printer.lexicalpreservation.Added. Because it has numerous incoming and outgoing ties across many other abstractions (acting as a central connector for concrete syntax model and lexical-preservation components), it exhibits the Hub-like Modularization smell."
    },
    {
        "identifier": "issue1945.implementations.WoolRenderer",
        "detection": false,
        "justification": "WoolRenderer has outgoing dependencies to 2 classes (issue1945.interfaces.HairyAnimal and issue1945.implementations.HairTypeWool) and a single incoming dependency from issue1945.implementations.HairTypeWool. It interacts with only two other abstractions (one of them in a circular relationship), which is not a large number of incoming and outgoing dependencies required to classify it as Hub-like Modularization."
    },
    {
        "identifier": "(default package).InnerStaticClassFieldDotExpressions",
        "detection": false,
        "justification": "Hub-like Modularization requires an abstraction to have many incoming and outgoing dependencies. This class has 1 outgoing dependency (com.packageName.InnerStaticClassFieldContainer) and 0 incoming dependencies, so it does not exhibit hub-like coupling."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.reflectionmodel.ReflectionFieldDeclaration",
        "detection": false,
        "justification": "Outgoing dependencies (6): com.github.javaparser.ast.AccessSpecifier, com.github.javaparser.resolution.types.ResolvedType, com.github.javaparser.resolution.declarations.ResolvedFieldDeclaration, com.github.javaparser.resolution.TypeSolver, com.github.javaparser.symbolsolver.reflectionmodel.ReflectionFactory, com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration. Incoming dependencies (1): com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassAdapter. Because the class has a relatively small number of outgoing dependencies (6) and only a single incoming dependency, it does not exhibit the hallmark of Hub-like Modularization (widespread incoming and outgoing coupling with many other abstractions)."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.declarators.FieldSymbolDeclarator",
        "detection": false,
        "justification": "Not detected: the class has 0 incoming dependencies (no other abstractions depend on it) and only 3 direct outgoing dependencies: com.github.javaparser.resolution.TypeSolver, com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserSymbolDeclaration, com.github.javaparser.ast.body.FieldDeclaration. Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; the provided data shows no incoming edges and a small number of outgoing edges, so the smell is not present."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserParameterDeclaration",
        "detection": false,
        "justification": "Outgoing dependencies are limited (6): JavaParserFacade, ResolvedType, TypeSolver, Parameter, JavaParserFactory, ResolvedArrayType. Incoming dependencies are minimal (1): referenced by com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserSymbolDeclaration. A hub-like modularization requires a large number of both incoming and outgoing connections; this class shows only a small set of outgoing dependencies and a single incoming dependency, so it is not a hub."
    },
    {
        "identifier": "com.github.javaparser.ast.validator.TreeVisitorValidator",
        "detection": false,
        "justification": "TreeVisitorValidator has 0 incoming dependencies (no classes depend on it) and only 3 outgoing dependencies: com.github.javaparser.ast.validator.ProblemReporter, com.github.javaparser.ast.validator.Validator, and com.github.javaparser.ast.Node. Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing connections; the provided data shows neither many incoming nor many outgoing relationships for this class, so the smell is not present."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.resolution.typeinference.constraintformulas.TypeSubtypeOfType",
        "detection": false,
        "justification": "TypeSubtypeOfType has a small set of outgoing dependencies (4): com.github.javaparser.resolution.TypeSolver, com.github.javaparser.symbolsolver.resolution.typeinference.TypeHelper, com.github.javaparser.symbolsolver.resolution.typeinference.BoundSet, com.github.javaparser.resolution.types.ResolvedType. It has a single incoming dependency listed (1): com.github.javaparser.symbolsolver.resolution.typeinference.BoundSet (which references TypeSubtypeOfType). Although some of its neighbor classes (e.g., TypeHelper, BoundSet) have many dependencies, the class itself shows low fan-out (4) and low fan-in (1). Under the provided, isolated data this does not meet the criterion of having large numbers of both incoming and outgoing dependencies, so it is not a hub-like modularization."
    },
    {
        "identifier": "com.github.javaparser.ast.validator.language_level_validations.Java10Validator",
        "detection": false,
        "justification": "No hub-like modularization: the class has 0 incoming dependencies and only 1 outgoing dependency (to com.github.javaparser.ast.validator.Validator). A hub requires many incoming and outgoing relationships; these counts do not meet that criterion. Note: Validator's own dependencies (ProblemReporter, Node) do not create additional incoming edges to Java10Validator."
    },
    {
        "identifier": "com.github.javaparser.javasymbolsolver.javassist_symbols.included_jar.SuperClassIncludedJar",
        "detection": false,
        "justification": "The class has 0 incoming dependencies and 0 outgoing dependencies (incoming_dependencies: [], outgoing_dependencies: []). Hub-like Modularization requires an abstraction to have many incoming and outgoing relationships with other abstractions; this class shows no such coupling, so it is not a hub."
    },
    {
        "identifier": "com.github.javaparser.metamodel.ThisExprMetaModel",
        "detection": false,
        "justification": "ThisExprMetaModel has a single outgoing dependency (PropertyMetaModel) and only two incoming dependents (com.github.javaparser.ast.expr.ThisExpr and com.github.javaparser.metamodel.JavaParserMetaModel). Outgoing dependencies: [PropertyMetaModel]. Incoming dependents: [com.github.javaparser.ast.expr.ThisExpr, com.github.javaparser.metamodel.JavaParserMetaModel]. The counts of incoming (2) and outgoing (1) dependencies are low and do not constitute a hub-like abstraction, so Hub-like Modularization is not detected."
    },
    {
        "identifier": "com.github.javaparser.metamodel.BlockCommentMetaModel",
        "detection": false,
        "justification": "BlockCommentMetaModel has no outgoing dependencies (outgoing_dependencies = []). It has only two incoming dependents (BlockComment and JavaParserMetaModel). Although JavaParserMetaModel itself references many meta-model classes, BlockCommentMetaModel does not exhibit a large number of both incoming and outgoing connections required for Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.ast.nodeTypes.NodeWithImplements",
        "detection": false,
        "justification": "Hub-like Modularization not detected: NodeWithImplements has a small number of outgoing dependencies (3: com.github.javaparser.ast.type.ClassOrInterfaceType, com.github.javaparser.StaticJavaParser, com.github.javaparser.ast.NodeList) and only one recorded incoming dependency (com.github.javaparser.symbolsolver.javaparsermodel.contexts.JavaParserTypeDeclarationAdapter). Hub-like smell requires many incoming and many outgoing connections; here outgoing=3 and incoming=1, so it does not qualify."
    },
    {
        "identifier": "com.github.javaparser.javadoc.JavadocBlockTag",
        "detection": false,
        "justification": "Not detected: JavadocBlockTag has a small number of connections. Outgoing dependencies: 3 (com.github.javaparser.javadoc.description.JavadocDescription, com.github.javaparser.utils.Utils, com.github.javaparser.javadoc.JavadocBlockTag.Type). Incoming dependents: 2 (com.github.javaparser.JavadocParser, com.github.javaparser.javadoc.Javadoc). Hub-like Modularization requires an abstraction to have many incoming and many outgoing dependencies; here both counts are low when the class is considered in isolation."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.resolution.typeinference.BoundSet.VariableDependency",
        "detection": false,
        "justification": "The class has only one incoming dependency (from com.github.javaparser.symbolsolver.resolution.typeinference.BoundSet) and one outgoing dependency (to com.github.javaparser.symbolsolver.resolution.typeinference.InferenceVariable). Incoming: BoundSet -> BoundSet.VariableDependency. Outgoing: VariableDependency -> InferenceVariable (which itself depends on ResolvedTypeParameterDeclaration and ResolvedType). Since the analyzed class connects to only a single other abstraction in each direction, it does not exhibit a hub-like modularization (which requires many incoming and outgoing dependency relations)."
    },
    {
        "identifier": "com.github.javaparser.ast.nodeTypes.NodeWithOptionalLabel",
        "detection": false,
        "justification": "Not detected: the class has 0 incoming dependencies and only 2 outgoing dependencies (com.github.javaparser.ast.expr.SimpleName, com.github.javaparser.utils.Utils). Hub-like Modularization requires an abstraction to have many incoming and outgoing dependency relationships; this class's dependency counts are low."
    },
    {
        "identifier": "com.github.javaparser.generator.core.visitor.VoidVisitorGenerator",
        "detection": false,
        "justification": "VoidVisitorGenerator has outgoing dependencies to 4 abstractions: com.github.javaparser.ast.CompilationUnit, com.github.javaparser.ast.body.MethodDeclaration, com.github.javaparser.utils.SourceRoot, com.github.javaparser.metamodel.BaseNodeMetaModel. It has zero incoming dependencies (incoming_dependencies is empty). Hub-like Modularization requires an abstraction to have both a large number of incoming and outgoing dependencies; here the outgoing set is small and there are no incoming dependencies, so the class does not exhibit a hub-like modularization smell."
    },
    {
        "identifier": "com.github.javaparser.ast.comments.CommentsCollection",
        "detection": true,
        "justification": "CommentsCollection has high fan-out (5 outgoing dependencies: com.github.javaparser.ast.comments.JavadocComment, com.github.javaparser.ast.comments.BlockComment, com.github.javaparser.ast.comments.LineComment, com.github.javaparser.Range, com.github.javaparser.ast.comments.Comment) and high fan-in (4 incoming dependencies: com.github.javaparser.ParseResult, com.github.javaparser.JavaParser, com.github.javaparser.GeneratedJavaParserBase, com.github.javaparser.GeneratedJavaParserTokenManager). It therefore serves as a central connector between core parser components and multiple comment abstractions, matching the Hub-like Modularization smell."
    },
    {
        "identifier": "com.github.javaparser.resolution.declarations.ResolvedConstructorDeclaration",
        "detection": false,
        "justification": "ResolvedConstructorDeclaration has numerous incoming dependencies (referenced by: com.github.javaparser.symbolsolver.JavaSymbolSolver; com.github.javaparser.symbolsolver.javaparsermodel.contexts.MethodReferenceExprContext; com.github.javaparser.ast.body.ConstructorDeclaration; com.github.javaparser.ast.body.CompactConstructorDeclaration; com.github.javaparser.ast.stmt.ExplicitConstructorInvocationStmt; com.github.javaparser.ast.expr.ObjectCreationExpr; com.github.javaparser.resolution.logic.ConstructorResolutionLogic), but only a single outgoing dependency (com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration). Hub-like Modularization requires an abstraction to have many incoming and many outgoing dependencies; here the outgoing side is minimal, so the class does not exhibit a hub-like modularization smell."
    },
    {
        "identifier": "com.github.javaparser.utils.SourceZip.Callback",
        "detection": false,
        "justification": "Not detected: the class has 0 outgoing dependencies and only 1 incoming dependency (from com.github.javaparser.utils.SourceZip). Hub-like modularization requires an abstraction to have a large number of both incoming and outgoing relations; this class does not exhibit that pattern."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.utils.ModuleLayerHelper",
        "detection": false,
        "justification": "ModuleLayerHelper is referenced by 2 other classes (com.github.javaparser.symbolsolver.resolution.typesolvers.ClassLoaderTypeSolver and com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver) but has 0 outgoing dependencies and no declared dependencies itself. Hub-like Modularization requires an abstraction to have many incoming and outgoing dependencies; here the incoming count is small and there are no outgoing dependencies, so the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.printer.lexicalpreservation.Added",
        "detection": false,
        "justification": "Not detected: the class Added has a small set of outgoing dependencies (TextElement, DifferenceElement, LexicalDifferenceCalculator, CsmElement) and only a single incoming dependency (Difference). Hub-like Modularization requires an abstraction to have many incoming and many outgoing connections; Added does not exhibit a large number of incoming dependents despite one outgoing dependency (LexicalDifferenceCalculator) itself being highly connected."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javassistmodel.JavassistAnnotationMemberDeclaration",
        "detection": false,
        "justification": "Not detected: the class has 0 incoming dependencies and 4 outgoing dependencies (com.github.javaparser.resolution.model.SymbolReference, com.github.javaparser.resolution.TypeSolver, com.github.javaparser.ast.expr.Expression, com.github.javaparser.resolution.types.ResolvedType). Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; the absence of incoming dependencies and a small set of outgoing dependencies indicates this is not a hub."
    },
    {
        "identifier": "(default package).Ops",
        "detection": false,
        "justification": "The class '(default package).Ops' has 0 incoming dependencies and 0 outgoing dependencies (both dependency lists are empty). Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; with zero dependencies on both sides, the smell is not present."
    },
    {
        "identifier": "com.github.javaparser.ast.expr.StringLiteralExpr",
        "detection": false,
        "justification": "StringLiteralExpr has a large number of incoming dependencies (≈22 distinct clients in the provided data — e.g. DefaultVisitorAdapter, VoidVisitor, GenericVisitor, VoidVisitorAdapter, NodeFinderVisitor, Expression, GeneratedJavaParser, PrettyPrintVisitor, DefaultPrettyPrinterVisitor), but only 8 outgoing dependencies listed (com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.Range, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.TokenRange, com.github.javaparser.metamodel.StringLiteralExprMetaModel, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.utils.StringEscapeUtils, com.github.javaparser.utils.Utils). Because Hub-like Modularization requires an abstraction to have both many incoming and many outgoing dependency links, StringLiteralExpr does not qualify here: incoming is large while outgoing is relatively small."
    },
    {
        "identifier": "com.github.javaparser.utils.Pair",
        "detection": false,
        "justification": "Hub-like Modularization requires an abstraction to have both a large number of incoming and outgoing dependencies. com.github.javaparser.utils.Pair has many incoming dependencies (referenced by at least 12 classes such as com.github.javaparser.symbolsolver.resolution.typeinference.BoundSet, com.github.javaparser.symbolsolver.resolution.typeinference.TypeHelper, com.github.javaparser.symbolsolver.resolution.typeinference.constraintformulas.ExpressionCompatibleWithType, com.github.javaparser.ast.type.ArrayType, com.github.javaparser.ast.body.Parameter, com.github.javaparser.ast.body.VariableDeclarator, com.github.javaparser.ast.body.MethodDeclaration, com.github.javaparser.GeneratedJavaParser, com.github.javaparser.GeneratedJavaParserBase, com.github.javaparser.javadoc.description.JavadocDescription, com.github.javaparser.generator.NodeGenerator, com.github.javaparser.generator.core.node.TypeCastingGenerator), but it has no outgoing dependencies (outgoing_dependencies is empty). Because it lacks outgoing couplings, it does not satisfy the 'both incoming and outgoing with a large number' requirement and therefore is not detected as hub-like modularization."
    },
    {
        "identifier": "com.github.javaparser.metamodel.TypeMetaModel",
        "detection": false,
        "justification": "TypeMetaModel has only 1 outgoing dependency (com.github.javaparser.metamodel.PropertyMetaModel) and only 2 incoming dependencies (com.github.javaparser.ast.type.Type and com.github.javaparser.metamodel.JavaParserMetaModel). A hub-like modularization requires dependencies (both incoming and outgoing) with a large number of other abstractions; the provided data shows few incoming/outgoing relations, so it is not a hub."
    },
    {
        "identifier": "com.github.javaparser.ast.nodeTypes.NodeWithTokenRange",
        "detection": false,
        "justification": "NodeWithTokenRange has a single outgoing dependency (com.github.javaparser.TokenRange) and a single incoming dependency (com.github.javaparser.ast.validator.ProblemReporter). The outgoing TokenRange further depends on JavaToken, but NodeWithTokenRange itself does not show many direct incoming or outgoing relationships. Because both incoming and outgoing dependency counts are low (one each), this does not meet the 'large number of other abstractions' criterion for Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.metamodel.JavaParserMetaModel",
        "detection": true,
        "justification": "The class has a large number of outgoing dependencies to many metamodel and AST-related classes (e.g. ConditionalExprMetaModel, NameMetaModel, UnaryExprMetaModel, UnionTypeMetaModel, CallableDeclarationMetaModel, SwitchEntryMetaModel, PropertyMetaModel, ArrayTypeMetaModel, PrimitiveTypeMetaModel, etc.), and it is referenced by a wide range of incoming clients across AST nodes, types, statements, expressions, serialization and generator code (e.g. UnionType, ArrayType, PrimitiveType, CompilationUnit, Node, MethodDeclaration, FieldDeclaration, many Expr/Stmt classes, JavaParserJsonSerializer/Deserializer, NodeGenerator, VisitorGenerator, PropertyGenerator, etc.). This combination of extensive incoming and outgoing connections identifies the class as a central hub-like abstraction with high coupling to many other abstractions, matching the Hub-like Modularization smell."
    },
    {
        "identifier": "com.github.javaparser.javasymbolsolver.javassist_symbols.main_jar.EnumInterfaceUserExcludedJar",
        "detection": false,
        "justification": "Hub-like Modularization is not detected: the class has 0 incoming dependencies and 0 outgoing dependencies. The smell requires an abstraction to have a large number of both incoming and outgoing dependencies, which is not the case here."
    },
    {
        "identifier": "com.github.javaparser.ast.ImportDeclaration",
        "detection": true,
        "justification": "ImportDeclaration has many outgoing dependencies (10), including com.github.javaparser.ast.expr.NameExpr, com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.expr.Name, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.metamodel.ImportDeclarationMetaModel, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.TokenRange, com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.ast.Node, and com.github.javaparser.Range. It also has a large number of incoming dependencies (24) from widely used components such as numerous visitor implementations (VoidVisitor, GenericVisitor, EqualsVisitor, HashCodeVisitor, PrettyPrintVisitor, DefaultPrettyPrinterVisitor, ModifierVisitor, CloneVisitor, etc.), core parser classes (JavaParser, StaticJavaParser, GeneratedJavaParser, JavaParserAdapter), and compilation/unit classes (CompilationUnit, NodeFinderVisitor). The class therefore has both many incoming and many outgoing links to many different abstractions, making it a hub-like module."
    },
    {
        "identifier": "com.github.javaparser.ParserConfiguration.LineEndingProcessor",
        "detection": false,
        "justification": "Not a hub-like module: the class has 0 incoming dependencies and only 2 outgoing dependencies (com.github.javaparser.LineEndingProcessingProvider, com.github.javaparser.ast.Node). Hub-like modularization requires numerous incoming and outgoing links; this class does not meet that condition."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.PatternVariableVisitor",
        "detection": true,
        "justification": "PatternVariableVisitor has a large number of both outgoing and incoming dependencies. Outgoing: 7 distinct dependencies (PatternVariableResult, UnaryExpr, ComponentPatternExpr, Node, EnclosedExpr, BinaryExpr, InstanceOfExpr). Incoming: 7 distinct context classes depend on it (ConditionalExprContext, WhileStatementContext, BinaryExprContext, IfStatementContext, ForStatementContext, AbstractJavaParserContext, DoStatementContext). The class therefore acts as a central connector between many AST element types (Node, various Expr classes) and multiple context classes (the callers), which matches the Hub-like Modularization smell (many incoming and many outgoing dependencies)."
    },
    {
        "identifier": "com.github.javaparser.metamodel.AnnotationDeclarationMetaModel",
        "detection": false,
        "justification": "The class has no outgoing dependencies (empty outgoing_dependencies) and only two incoming dependencies (com.github.javaparser.ast.body.AnnotationDeclaration and com.github.javaparser.metamodel.JavaParserMetaModel). Hub-like Modularization requires an abstraction to have many incoming and outgoing relationships; this class lacks outgoing links and has a very small number of incoming links, so it is not a hub."
    },
    {
        "identifier": "issue1945.interfaces.HairTypeRenderer",
        "detection": false,
        "justification": "HairTypeRenderer has only 1 incoming dependency (issue1945.main.MainIssue1945) and 2 outgoing dependencies (issue1945.interfaces.HairyAnimal, issue1945.interfaces.HairType). The class interacts with a small, fixed set of other abstractions rather than a large number of incoming and outgoing connections, so it does not exhibit Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.metamodel.LocalRecordDeclarationStmtMetaModel",
        "detection": false,
        "justification": "LocalRecordDeclarationStmtMetaModel has only 1 outgoing dependency (com.github.javaparser.metamodel.PropertyMetaModel) and 2 incoming dependents (com.github.javaparser.ast.stmt.LocalRecordDeclarationStmt and com.github.javaparser.metamodel.JavaParserMetaModel). Although JavaParserMetaModel references many meta-model classes, the analyzed class itself is directly connected to only these two callers and one callee, so it does not exhibit hub-like modularization (no large number of incoming and outgoing dependencies)."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.contexts.ClassOrInterfaceDeclarationExtendsContext",
        "detection": false,
        "justification": "Not a hub: the analyzed class has no incoming dependencies (incoming_dependencies is empty) and only three outgoing dependencies (SymbolReference, TypeSolver, ClassOrInterfaceDeclaration). Hub-like modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; this class lacks incoming dependencies and therefore does not meet the criterion."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.resolution.promotion.ConditionalExprResolver",
        "detection": false,
        "justification": "ConditionalExprResolver has a small number of direct relationships: 3 outgoing dependencies (com.github.javaparser.resolution.types.ResolvedType, com.github.javaparser.resolution.promotion.ConditionalExprHandler, com.github.javaparser.resolution.types.ResolvedPrimitiveType) and a single incoming dependency (referenced by com.github.javaparser.symbolsolver.javaparsermodel.TypeExtractor). Although one of its outgoing types (ResolvedType) itself lists many dependencies, ConditionalExprResolver directly depends on only three abstractions and is referenced by only one abstraction in the provided data. Therefore it does not meet the criterion of having a large number of both incoming and outgoing dependencies required for hub-like modularization."
    },
    {
        "identifier": "com.github.javaparser.resolution.types.ResolvedType",
        "detection": true,
        "justification": "ResolvedType has a very large number of incoming dependencies (132 distinct classes in the provided data) from many packages and subsystems (examples: com.github.javaparser.symbolsolver.JavaSymbolSolver, com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade, com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassDeclaration, numerous symbolsolver.resolution.typeinference classes, many AST node types such as MethodCallExpr/Expression/Type, and many resolution/model types). It also has multiple outgoing dependencies (9 distinct types listed: ResolvedReferenceType, ResolvedTypeVariable, ResolvedTypeParameterDeclaration, Context, ResolvedPrimitiveType, ResolvedWildcard, ResolvedUnionType, ResolvedLambdaConstraintType, ResolvedArrayType). The combination of very high incoming coupling (many clients) and several outgoing dependencies indicates ResolvedType acts as a central/hub abstraction connecting a large number of other abstractions, matching the Hub-like Modularization smell."
    },
    {
        "identifier": "com.github.javaparser.generator.core.visitor.NoCommentHashCodeVisitorGenerator",
        "detection": false,
        "justification": "Incoming dependencies: 0 (no incoming dependencies). Outgoing dependencies: 9 (com.github.javaparser.StaticJavaParser, com.github.javaparser.metamodel.BaseNodeMetaModel, com.github.javaparser.ast.stmt.BlockStmt, com.github.javaparser.ast.CompilationUnit, com.github.javaparser.utils.SeparatedItemStringBuilder, com.github.javaparser.ast.body.MethodDeclaration, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.utils.SourceRoot). Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; this class has outgoing dependencies but no incoming dependencies, so the smell is not present."
    },
    {
        "identifier": "com.github.javaparser.generator.core.node.NodeModifierGenerator",
        "detection": false,
        "justification": "NodeModifierGenerator has no incoming dependencies (incoming_dependencies is empty) and only a small number of direct outgoing dependencies (4 listed: CompilationUnit, SourceRoot, BaseNodeMetaModel, ClassOrInterfaceDeclaration). The Hub-like Modularization smell requires an abstraction to have both many incoming and many outgoing connections; since there are zero incoming and only a few outgoing, the smell is not present when the class is considered in isolation."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.resolution.typeinference.Bound",
        "detection": false,
        "justification": "Bound has 3 outgoing dependencies (FalseBound, InferenceVariableSubstitution, InferenceVariable) and only 1 incoming dependency (BoundSet). The number of distinct incoming and outgoing connections is small, so it does not constitute a hub-like modularization."
    },
    {
        "identifier": "com.github.javaparser.metamodel.DoubleLiteralExprMetaModel",
        "detection": false,
        "justification": "Not a hub: the class has 0 outgoing dependencies (outgoing_dependencies empty) and only 2 incoming dependents (com.github.javaparser.ast.expr.DoubleLiteralExpr and com.github.javaparser.metamodel.JavaParserMetaModel). Hub-like Modularization requires many incoming and outgoing connections; this class lacks outgoing links and has only a small number of incoming links, so the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.javasymbolsolver.javassist_symbols.main_jar.SubClassExcludedJar",
        "detection": false,
        "justification": "The class has 0 incoming dependencies and 0 outgoing dependencies (incoming_dependencies = [], outgoing_dependencies = []). Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; this class does not meet that criterion."
    },
    {
        "identifier": "com.github.javaparser.metamodel.ReferenceTypeMetaModel",
        "detection": false,
        "justification": "ReferenceTypeMetaModel has 0 outgoing dependencies and only 2 incoming dependencies (from com.github.javaparser.ast.type.ReferenceType and com.github.javaparser.metamodel.JavaParserMetaModel). Hub-like Modularization requires an abstraction to have both many incoming and many outgoing dependencies; here outgoing = 0 and incoming is small, so it is not a hub."
    },
    {
        "identifier": "com.github.javaparser.printer.lexicalpreservation.TokenTextElement",
        "detection": false,
        "justification": "TokenTextElement has a small number of outgoing dependencies (3: com.github.javaparser.printer.lexicalpreservation.LexicalPreservingVisitor, com.github.javaparser.JavaToken, com.github.javaparser.ast.Node) and a small number of distinct incoming dependents (4: DifferenceElementCalculator, LexicalPreservingPrinter, Difference, LexicalPreservingVisitor). The class does not exhibit a large number of both incoming and outgoing connections to other abstractions, so it does not meet the Hub-like Modularization smell criteria."
    },
    {
        "identifier": "com.github.javaparser.resolution.logic.MethodResolutionCapability",
        "detection": false,
        "justification": "Not detected: the class has only 1 outgoing dependency (com.github.javaparser.resolution.model.SymbolReference) and 0 incoming dependencies. Hub-like Modularization requires many incoming and outgoing dependencies; these counts (outgoing=1, incoming=0) do not indicate a hub."
    },
    {
        "identifier": "foo.JavaTest",
        "detection": false,
        "justification": "The class has 0 incoming dependencies and 0 outgoing dependencies (no listed dependencies). Since it has no incoming or outgoing links to many other abstractions, it does not exhibit Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.ast.Node.Parsedness",
        "detection": false,
        "justification": "Hub-like Modularization requires an abstraction to have dependencies (incoming and outgoing) with a large number of other abstractions. Here, Parsedness has 0 outgoing dependencies and only 1 incoming dependency (from com.github.javaparser.ast.Node). Although Node's dependency list includes Node.Parsedness among many entries, Parsedness itself is referenced by a single class and does not depend on other abstractions. Counts: incoming clients = 1, outgoing dependencies = 0. Therefore it is not a hub."
    },
    {
        "identifier": "com.github.javaparser.ast.validator.language_level_validations.Java24Validator",
        "detection": false,
        "justification": "Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies. This class has 0 incoming dependencies and 0 outgoing dependencies (incoming_dependencies: [], outgoing_dependencies: []), so it does not meet the criteria for a hub-like module."
    },
    {
        "identifier": "foo.B",
        "detection": false,
        "justification": "No hub-like modularization: incoming_dependencies = 0 and outgoing_dependencies = 0 (both arrays are empty), so the class has no large number of incoming or outgoing dependencies."
    },
    {
        "identifier": "japa.bdd.samples.JavaConcepts.Ugly",
        "detection": false,
        "justification": "The class has no incoming or outgoing dependencies (incoming_dependencies = 0, outgoing_dependencies = 0; analyzed_package.dependencies is empty), so it does not have dependencies with a large number of other abstractions and therefore is not a hub-like modularization."
    },
    {
        "identifier": "com.github.javaparser.metamodel.TypeExprMetaModel",
        "detection": false,
        "justification": "TypeExprMetaModel has only one outgoing dependency (com.github.javaparser.metamodel.PropertyMetaModel) and only two incoming dependents (com.github.javaparser.ast.expr.TypeExpr and com.github.javaparser.metamodel.JavaParserMetaModel). Although JavaParserMetaModel itself lists many dependencies, the analyzed class in isolation connects directly to only a small number of other abstractions (1 outgoing, 2 incoming), so it does not meet the criteria of having a large number of incoming and outgoing dependencies required for Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.printer.PrettyPrinter",
        "detection": false,
        "justification": "PrettyPrinter has no incoming dependencies (incoming_dependencies = 0) and only five direct outgoing dependencies (Printer, VoidVisitor, Node, PrettyPrinterConfiguration, PrinterConfiguration). Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing relationships. Although some of the outgoing targets (e.g. VoidVisitor, Node) themselves reference many types, the PrettyPrinter class itself does not show a large number of direct incoming or outgoing dependencies, so it does not qualify as a hub."
    },
    {
        "identifier": "com.github.javaparser.ast.comments.LineComment",
        "detection": false,
        "justification": "LineComment has many incoming dependencies (23 distinct classes in the provided data depend on it, e.g. com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.ast.visitor.ModifierVisitor, com.github.javaparser.JavaParser, com.github.javaparser.printer.PrettyPrintVisitor, com.github.javaparser.ast.comments.Comment, com.github.javaparser.ast.comments.CommentsCollection, com.github.javaparser.ast.visitor.NodeFinderVisitor, etc.). However, its outgoing dependencies are limited (6 listed: com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.TokenRange, com.github.javaparser.metamodel.LineCommentMetaModel, com.github.javaparser.Range). Because Hub-like Modularization requires an abstraction to have both a large number of incoming and outgoing dependencies, and LineComment exhibits many incoming but only a small number of outgoing dependencies, it does not qualify as a hub-like module."
    },
    {
        "identifier": "com.github.javaparser.ast.expr.InstanceOfExpr",
        "detection": true,
        "justification": "InstanceOfExpr has a large number of both incoming and outgoing dependencies. Outgoing: 12 direct dependencies to many core abstractions (examples: com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.ast.expr.Expression, com.github.javaparser.ast.type.Type, com.github.javaparser.ast.Node, com.github.javaparser.TokenRange, com.github.javaparser.Range, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.ast.expr.PatternExpr). Incoming: 24 distinct clients depend on InstanceOfExpr, including numerous visitor and utility classes (examples: DefaultVisitorAdapter, TypeExtractor, PatternVariableVisitor, InstanceOfExprContext, VoidVisitor, GenericVisitor, ModifierVisitor, many Visitor variants, PrettyPrintVisitor, DefaultPrettyPrinterVisitor, GeneratedJavaParser, NodeFinderVisitor, CloneVisitor). The class thus sits at a center with many incoming references from diverse modules and many outgoing references to core AST/meta/type abstractions, matching the Hub-like Modularization smell."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserRecordDeclaration",
        "detection": false,
        "justification": "Outgoing degree: 16 distinct abstractions (examples: com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade, com.github.javaparser.ast.Node, com.github.javaparser.ast.body.RecordDeclaration, com.github.javaparser.resolution.types.ResolvedType, com.github.javaparser.resolution.TypeSolver, com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFactory, com.github.javaparser.symbolsolver.javaparsermodel.declarations.AstResolutionUtils, com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserTypeAdapter, com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration, com.github.javaparser.ast.type.ClassOrInterfaceType, etc.). Incoming degree: 1 (referenced by com.github.javaparser.symbolsolver.javaparsermodel.contexts.RecordDeclarationContext). Hub-like Modularization requires many dependencies both incoming and outgoing; here the incoming coupling is low (1), so the class does not meet the hub-like smell criteria."
    },
    {
        "identifier": "com.github.javaparser.ast.stmt.ExplicitConstructorInvocationStmt",
        "detection": true,
        "justification": "ExplicitConstructorInvocationStmt has a large number of incoming and outgoing dependencies: outgoing dependencies (11) include com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.ast.expr.Expression, com.github.javaparser.ast.NodeList, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.TokenRange, com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.metamodel.ExplicitConstructorInvocationStmtMetaModel, com.github.javaparser.ast.Node, com.github.javaparser.resolution.declarations.ResolvedConstructorDeclaration, com.github.javaparser.Range. It also has many incoming dependents (24+) such as symbolsolver.DefaultVisitorAdapter, JavaParserFacade, Statement, numerous visitor implementations (VoidVisitor, GenericVisitor, HashCodeVisitor, EqualsVisitor, ModifierVisitor, CloneVisitor, various VisitorAdapters), parser/adapter classes (StaticJavaParser, JavaParserAdapter, GeneratedJavaParser) and printer visitors (PrettyPrintVisitor, DefaultPrettyPrinterVisitor). The combination of many different clients depending on this class and its direct dependencies on many core AST/meta types indicates a hub-like modularization smell."
    },
    {
        "identifier": "com.github.javaparser.javasymbolsolver.javassist_symbols.main_jar.EnumInterfaceUserOwnJar",
        "detection": false,
        "justification": "Hub-like Modularization requires an abstraction to have many incoming and outgoing dependencies. This class has 0 outgoing dependencies and 0 incoming dependencies (both dependency lists are empty), so it does not exhibit hub-like characteristics."
    },
    {
        "identifier": "com.github.javaparser.ast.validator.language_level_validations.Java11PreviewValidator",
        "detection": false,
        "justification": "The class has 0 incoming dependencies and 0 outgoing dependencies (both dependency lists are empty). Hub-like Modularization requires an abstraction to have many incoming and outgoing dependencies; this class has none, so it cannot be a hub."
    },
    {
        "identifier": "com.github.javaparser.printer.XmlPrinter",
        "detection": false,
        "justification": "Not detected. Hub-like Modularization requires an abstraction to have dependencies (both incoming and outgoing) with a large number of other abstractions. XmlPrinter has 0 incoming dependencies and only 4 direct outgoing dependencies: com.github.javaparser.ast.NodeList, com.github.javaparser.metamodel.NodeMetaModel, com.github.javaparser.utils.Utils, com.github.javaparser.ast.Node. Although com.github.javaparser.ast.Node (one of the outgoing dependencies) itself references many other types, those are transitive relationships; per the constraint to analyze the class in isolation, only XmlPrinter's direct incoming/outgoing counts are considered (incoming=0, outgoing=4), which does not constitute a hub."
    },
    {
        "identifier": "com.github.javaparser.resolution.types.ResolvedPrimitiveType",
        "detection": false,
        "justification": "ResolvedPrimitiveType has a large number of incoming dependencies (17 distinct classes reference it, e.g. com.github.javaparser.symbolsolver.JavaSymbolSolver, com.github.javaparser.symbolsolver.javaparsermodel.TypeExtractor, com.github.javaparser.resolution.types.ResolvedType, com.github.javaparser.resolution.types.ResolvedReferenceType, com.github.javaparser.symbolsolver.reflectionmodel.ReflectionFactory, com.github.javaparser.resolution.model.typesystem.LazyType, etc.), but only 2 outgoing dependencies (com.github.javaparser.utils.TypeUtils and com.github.javaparser.resolution.types.ResolvedType). The Hub-like Modularization smell requires an abstraction to have dependencies with a large number of other abstractions in both directions; here the incoming side is broad while the outgoing side is minimal, so the class does not meet the bidirectional 'hub' criterion."
    },
    {
        "identifier": "com.github.javaparser.generator.core.visitor.VoidVisitorAdapterGenerator",
        "detection": false,
        "justification": "Hub-like Modularization not detected because the class has outgoing dependencies to 5 other abstractions (BaseNodeMetaModel, BlockStmt, CompilationUnit, MethodDeclaration, SourceRoot) but has 0 incoming dependencies. The smell requires an abstraction to have a large number of both incoming and outgoing dependencies; here the incoming dependency set is empty, so the hub condition is not met."
    },
    {
        "identifier": "(default package).MyEnum",
        "detection": false,
        "justification": "No hub-like modularization: the class has 0 incoming dependencies and 0 outgoing dependencies (analyzed_package.dependencies: [], outgoing_dependencies: [], incoming_dependencies: []). A hub requires many incoming and outgoing connections, which are absent here."
    },
    {
        "identifier": "com.github.javaparser.utils.SourceRoot",
        "detection": true,
        "justification": [
            "High incoming fan-in: 38 distinct classes depend on SourceRoot (many from com.github.javaparser.generator.* and various generator.core.* and generator.core.visitor.* classes, plus demo.Main and others), showing a large number of incoming dependencies.",
            "Non-trivial outgoing fan-out: SourceRoot depends on 9 distinct abstractions (examples: com.github.javaparser.ParserConfiguration, com.github.javaparser.JavaParser, com.github.javaparser.ast.CompilationUnit, com.github.javaparser.ParseResult, com.github.javaparser.utils.CodeGenerationUtils, com.github.javaparser.utils.Log, plus its inner types SourceRoot.ParallelParse and callback types), spanning multiple packages and concerns.",
            "Because the class has a large number of incoming connections combined with multiple outgoing connections across different modules, it acts as a central hub linking many abstractions and therefore exhibits the Hub-like Modularization smell."
        ]
    },
    {
        "identifier": "com.github.javaparser.ast.observer.ObservableProperty.Type",
        "detection": false,
        "justification": "ObservableProperty.Type has 0 outgoing dependencies and only 1 incoming dependency (from com.github.javaparser.ast.observer.ObservableProperty). It does not have dependencies (both incoming and outgoing) with a large number of other abstractions, so it is not a hub."
    },
    {
        "identifier": "com.github.javaparser.ast.stmt.UnparsableStmt",
        "detection": true,
        "justification": "UnparsableStmt has a large number of incoming dependencies (20 distinct classes depend on it) including many visitor and utility classes (examples: com.github.javaparser.ast.visitor.VoidVisitor, GenericVisitor, PrettyPrintVisitor, DefaultPrettyPrinterVisitor, CloneVisitor, EqualsVisitor, HashCodeVisitor, NodeFinderVisitor, VoidVisitorAdapter, DefaultVisitorAdapter, Statement). It also has multiple outgoing dependencies (5) to core abstractions (com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.metamodel.UnparsableStmtMetaModel, com.github.javaparser.TokenRange). The class therefore participates in many incoming relations while depending on several core components, forming a hub-like connection pattern consistent with Hub-like Modularization."
    },
    {
        "identifier": "foo.A.FindMeIfYouCan",
        "detection": false,
        "justification": "Not detected: the class has 1 incoming dependency (foo.A -> foo.A.FindMeIfYouCan) and 0 outgoing dependencies. Hub-like Modularization requires many incoming and outgoing dependencies; this class shows minimal incoming coupling and no outgoing coupling."
    },
    {
        "identifier": "com.github.javaparser.printer.configuration.Indentation",
        "detection": false,
        "justification": "Hub-like Modularization is not detected: the class has only 2 incoming dependencies (com.github.javaparser.printer.SourcePrinter, com.github.javaparser.printer.configuration.PrettyPrinterConfiguration) and 1 outgoing dependency (com.github.javaparser.printer.configuration.Indentation.IndentType). Both incoming and outgoing connection counts are small and do not constitute a hub."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.reflectionmodel.ReflectionAnnotationDeclaration",
        "detection": false,
        "justification": "Outgoing dependencies: 10 distinct abstractions (Context, MethodUsage, SymbolReference, ReflectionMethodResolutionLogic, ResolvedType, TypeSolver, ReflectionFactory, ResolvedReferenceTypeDeclaration, ReflectionClassAdapter, InferenceContext) — showing moderate outward connectivity. Incoming dependencies: only 1 abstraction (com.github.javaparser.symbolsolver.resolution.SymbolSolver) depends on this class. Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; here the incoming coupling is minimal while outgoing is the primary contributor. Therefore this class does not qualify as a hub (many incoming and outgoing) based on the provided data."
    },
    {
        "identifier": "com.example.Beta",
        "detection": false,
        "justification": "Not detected: Beta has outgoing dependencies to com.example.Beta.CustomInterface and com.example.Alpha (2 outgoing) and has no incoming dependencies. Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies, which is not the case here."
    },
    {
        "identifier": "com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration",
        "detection": false,
        "justification": "Incoming dependencies: 68 distinct other abstractions (examples: com.github.javaparser.symbolsolver.JavaSymbolSolver, com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassDeclaration, com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade, com.github.javaparser.resolution.TypeSolver, com.github.javaparser.symbolsolver.resolution.SymbolSolver, com.github.javaparser.symbolsolver.javassistmodel.JavassistFactory, com.github.javaparser.resolution.logic.MethodResolutionLogic). Outgoing dependencies: only 3 direct abstractions (com.github.javaparser.resolution.declarations.ResolvedFieldDeclaration, com.github.javaparser.ast.AccessSpecifier, com.github.javaparser.resolution.types.ResolvedType). The Hub-like Modularization smell requires an abstraction to have dependencies with a large number of other abstractions in both incoming and outgoing directions. In the provided data, ResolvedReferenceTypeDeclaration has a very large number of incoming dependents but a small number of outgoing dependencies (3), so it does not meet the definition (large in both directions). Detection: false."
    },
    {
        "identifier": "com.github.javaparser.printer.lexicalpreservation.TextElement",
        "detection": false,
        "justification": "Incoming dependencies: 10 distinct classes depend on TextElement (CsmIndent, CsmToken, CsmElement, NodeText, Difference, TextElementMatcher, TextElementIteratorsFactory, ReshuffledDiffElementExtractor, TextElementMatchers, Added). Outgoing dependencies: TextElement depends on only 3 other abstractions (com.github.javaparser.GeneratedJavaParserConstants, com.github.javaparser.printer.lexicalpreservation.TextElementMatcher, com.github.javaparser.ast.Node). Hub-like modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; here incoming is relatively high but outgoing is small (and one dependency, TextElementMatcher, is bidirectional). Therefore this class does not meet the criteria for a hub-like module."
    },
    {
        "identifier": "japa.bdd.samples.Base",
        "detection": false,
        "justification": "Both incoming and outgoing dependency lists are empty (incoming_dependencies: [] count=0; outgoing_dependencies: [] count=0). Hub-like Modularization requires an abstraction to have dependencies with a large number of other abstractions in both directions; with zero incoming and zero outgoing dependencies, this class cannot be considered a hub."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.contexts.MethodContext",
        "detection": false,
        "justification": "MethodContext has outgoing dependencies to three abstractions (com.github.javaparser.ast.body.MethodDeclaration, com.github.javaparser.resolution.TypeSolver, com.github.javaparser.ast.Node) but has no incoming dependencies. Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies. Because incoming dependencies = 0, MethodContext does not meet the definition of a hub."
    },
    {
        "identifier": "com.github.javaparser.ast.validator.Validators",
        "detection": false,
        "justification": "Validators has 3 outgoing dependencies (com.github.javaparser.ast.validator.ProblemReporter, com.github.javaparser.ast.validator.Validator, com.github.javaparser.ast.Node) and 0 incoming dependencies. Hub-like Modularization requires an abstraction to have many incoming and outgoing relationships; this class lacks incoming dependencies and has a small number of outgoing dependencies, so the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.ast.type.PrimitiveType.Primitive",
        "detection": false,
        "justification": "The class has no outgoing dependencies (outgoing_dependencies is empty) and only a single incoming dependency entry (from com.github.javaparser.ast.type.Primitive, which lists PrimitiveType.Primitive among its dependencies). Hub-like modularization requires many incoming and outgoing connections; here incoming count = 1 and outgoing count = 0, so it is not a hub."
    },
    {
        "identifier": "(default package).COLOR",
        "detection": false,
        "justification": "The class has 0 incoming dependencies and 0 outgoing dependencies (both dependency lists are empty). Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies, which is not the case here."
    },
    {
        "identifier": "com.github.javaparser.metamodel.TypeParameterMetaModel",
        "detection": false,
        "justification": "Hub-like modularization requires the class to have dependencies (both incoming and outgoing) with a large number of other abstractions. In the provided data, TypeParameterMetaModel has a single outgoing dependency: com.github.javaparser.metamodel.PropertyMetaModel. It has incoming references from two classes: com.github.javaparser.ast.type.TypeParameter and com.github.javaparser.metamodel.JavaParserMetaModel. The counts of incoming (2) and outgoing (1) dependencies are low and do not constitute a hub connecting a large number of other abstractions, so the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.javasymbolsolver.javassist_symbols.main_jar.SubInterfaceIncludedJar",
        "detection": false,
        "justification": "incoming_dependencies count = 0 and outgoing_dependencies count = 0 (both lists are empty). The class has no incoming or outgoing dependency relationships with other abstractions, so it does not exhibit Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.PatternVariableResult",
        "detection": false,
        "justification": "PatternVariableResult has 0 outgoing dependencies (no outgoing edges) but 7 incoming dependencies from: com.github.javaparser.symbolsolver.javaparsermodel.PatternVariableVisitor, com.github.javaparser.symbolsolver.javaparsermodel.contexts.ConditionalExprContext, com.github.javaparser.symbolsolver.javaparsermodel.contexts.WhileStatementContext, com.github.javaparser.symbolsolver.javaparsermodel.contexts.BinaryExprContext, com.github.javaparser.symbolsolver.javaparsermodel.contexts.IfStatementContext, com.github.javaparser.symbolsolver.javaparsermodel.contexts.ForStatementContext, com.github.javaparser.symbolsolver.javaparsermodel.contexts.DoStatementContext. Hub-like modularization requires having a large number of both incoming and outgoing dependencies; here outgoing dependencies are absent, so the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.resolution.Solver",
        "detection": false,
        "justification": "Hub-like modularization requires the abstraction to have dependencies (both incoming and outgoing) with a large number of other abstractions. Solver has 7 outgoing dependencies: com.github.javaparser.resolution.model.SymbolReference, com.github.javaparser.ast.Node, com.github.javaparser.resolution.types.ResolvedType, com.github.javaparser.resolution.Context, com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration, com.github.javaparser.resolution.MethodUsage, and com.github.javaparser.ast.type.Type. It has only 2 incoming dependents in the provided data: com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade and com.github.javaparser.symbolsolver.javaparsermodel.TypeExtractor. Because the number of distinct incoming dependents is low (2) and the outgoing dependency set is modest (7), the class does not meet the criterion of having both many incoming and many outgoing connections and therefore is not detected as a hub-like modularization."
    },
    {
        "identifier": "com.github.javaparser.ast.nodeTypes.NodeWithScope",
        "detection": false,
        "justification": "NodeWithScope has only one direct outgoing dependency (com.github.javaparser.ast.expr.Expression) and no incoming dependencies (incoming_dependencies is empty). Hub-like Modularization requires an abstraction to have many incoming and outgoing dependencies; the provided data does not show multiple direct incoming/outgoing relations for this class. (Note: Expression itself lists many dependencies, but those are not direct dependencies of NodeWithScope in the given data.)"
    },
    {
        "identifier": "com.github.javaparser.resolution.model.LambdaArgumentTypePlaceholder",
        "detection": false,
        "justification": "LambdaArgumentTypePlaceholder has only 2 outgoing dependencies (com.github.javaparser.resolution.model.SymbolReference, com.github.javaparser.resolution.types.ResolvedType) and 2 incoming dependents (com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade, com.github.javaparser.resolution.logic.MethodResolutionLogic). These direct incoming/outgoing counts are small, so it does not exhibit Hub-like Modularization. (While one outgoing dependency, ResolvedType, itself references many types, LambdaArgumentTypePlaceholder does not directly depend on or is depended on by a large number of distinct abstractions.)"
    },
    {
        "identifier": "com.github.javaparser.printer.PrettyPrintVisitor",
        "detection": false,
        "justification": "The class has a large set of outgoing dependencies (examples include com.github.javaparser.ast.stmt.IfStmt, com.github.javaparser.ast.type.ReferenceType, com.github.javaparser.ast.body.FieldDeclaration, com.github.javaparser.ast.expr.MethodCallExpr, com.github.javaparser.printer.SourcePrinter, com.github.javaparser.printer.configuration.PrettyPrinterConfiguration, com.github.javaparser.utils.Utils, etc.), but the provided data shows no incoming dependencies (incoming_dependencies is an empty list). The Hub-like Modularization smell requires an abstraction to have many both incoming and outgoing dependencies; because incoming dependencies are absent, the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.printer.lexicalpreservation.TextElementIteratorsFactory.EmptyIterator",
        "detection": false,
        "justification": "The class has no outgoing dependencies and no incoming dependencies (outgoing_dependencies: 0, incoming_dependencies: 0), so it does not exhibit hub-like modularization which requires many incoming and outgoing dependency relationships."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.resolution.typeinference.MethodType",
        "detection": false,
        "justification": "MethodType has a small number of direct relations: 2 outgoing dependencies (com.github.javaparser.resolution.MethodUsage, com.github.javaparser.resolution.types.ResolvedType) and 2 incoming dependents (com.github.javaparser.symbolsolver.resolution.typeinference.TypeHelper, com.github.javaparser.symbolsolver.resolution.typeinference.constraintformulas.ExpressionCompatibleWithType). Because both incoming and outgoing counts are low, it does not exhibit hub-like modularization."
    },
    {
        "identifier": "(default package).Convolution2D",
        "detection": false,
        "justification": "Not detected: the class has no incoming or outgoing dependencies. analyzed_package.dependencies is an empty list, outgoing_dependencies length = 0, incoming_dependencies length = 0, so it does not have dependencies with a large number of other abstractions."
    },
    {
        "identifier": "com.github.javaparser.printer.lexicalpreservation.LexicalDifferenceCalculator.CsmChild",
        "detection": false,
        "justification": "CsmChild has 0 incoming dependencies and only 1 outgoing dependency (to com.github.javaparser.ast.Node). Hub-like Modularization requires an abstraction to have many incoming and outgoing dependencies; this class does not meet that criterion. (The listed dependencies of com.github.javaparser.ast.Node are dependencies of Node, not direct dependencies of CsmChild.)"
    },
    {
        "identifier": "com.github.javaparser.resolution.declarations.ResolvedTypeParametrizable",
        "detection": false,
        "justification": "ResolvedTypeParametrizable has 0 outgoing dependencies and 5 incoming dependencies (from com.github.javaparser.symbolsolver.reflectionmodel.ReflectionTypeParameter, com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserTypeParameter, com.github.javaparser.symbolsolver.javassistmodel.JavassistUtils, com.github.javaparser.symbolsolver.javassistmodel.JavassistTypeParameter, com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration). Hub-like Modularization requires an abstraction to have many incoming AND many outgoing ties; here outgoing dependencies are absent, so it does not qualify as a hub."
    },
    {
        "identifier": "com.github.javaparser.javadoc.Javadoc",
        "detection": false,
        "justification": "The class has a modest number of direct relationships: 4 outgoing dependencies (com.github.javaparser.javadoc.description.JavadocDescription, com.github.javaparser.ast.comments.JavadocComment, com.github.javaparser.utils.LineSeparator, com.github.javaparser.javadoc.JavadocBlockTag) and 6 incoming dependencies (com.github.javaparser.ast.nodeTypes.NodeWithJavadoc, com.github.javaparser.ast.comments.JavadocComment, com.github.javaparser.ast.comments.TraditionalJavadocComment, com.github.javaparser.StaticJavaParser, com.github.javaparser.JavadocParser, com.github.javaparser.JavaParserAdapter). These connections are concentrated in closely related javadoc/AST parsing classes (including a mutual dependency with JavadocComment) rather than a large, wide-reaching set of unrelated abstractions. Therefore it does not exhibit a hub-like modularization smell under the provided data."
    },
    {
        "identifier": "demo.Main.Callback",
        "detection": false,
        "justification": "The class has only 1 incoming dependency (demo.Main) and 1 outgoing dependency (com.github.javaparser.utils.SourceRoot). Hub-like Modularization requires many incoming and outgoing dependencies; although SourceRoot itself depends on many types, demo.Main.Callback directly references only SourceRoot, so it does not act as a hub."
    },
    {
        "identifier": "com.github.javaparser.ast.body.FieldDeclaration",
        "detection": true,
        "justification": "FieldDeclaration has many outgoing dependencies (≈19) to core AST abstractions such as com.github.javaparser.ast.type.Type, com.github.javaparser.ast.body.VariableDeclarator, com.github.javaparser.ast.body.MethodDeclaration, com.github.javaparser.ast.comments.JavadocComment, com.github.javaparser.ast.Modifier, com.github.javaparser.ast.Node, com.github.javaparser.Range, com.github.javaparser.TokenRange, com.github.javaparser.ast.NodeList, com.github.javaparser.metamodel.JavaParserMetaModel and FieldDeclarationMetaModel, plus visitor interfaces (com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.visitor.GenericVisitor). It also has a large number of incoming dependencies from many other classes and packages (dozens) — for example com.github.javaparser.symbolsolver.JavaSymbolSolver, numerous symbolsolver.javaparsermodel classes (DefaultVisitorAdapter, TypeExtractor, JavaParserFieldDeclaration, FieldSymbolDeclarator, etc.), many visitor implementations (VoidVisitor, GenericVisitor, HashCodeVisitor, EqualsVisitor, CloneVisitor, PrettyPrintVisitor, DefaultPrettyPrinterVisitor, ModifierVisitor, etc.), utilities (PositionUtils, Navigator), and generators. The presence of a large set of both incoming and outgoing ties to many diverse abstractions indicates a hub-like modularization smell: FieldDeclaration acts as a central hub interacting with a large number of other abstractions."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.resolution.typeinference.constraintformulas.TypeContainedByType",
        "detection": false,
        "justification": "TypeContainedByType has 3 outgoing dependencies (com.github.javaparser.symbolsolver.resolution.typeinference.TypeHelper, com.github.javaparser.symbolsolver.resolution.typeinference.BoundSet, com.github.javaparser.resolution.types.ResolvedType) and 0 incoming dependencies. The Hub-like Modularization smell requires an abstraction to have dependencies (both incoming and outgoing) with a large number of other abstractions. Here the analyzed class is linked directly to only three other abstractions and has no incoming links, so it does not meet the criterion for a hub. (Note: the three target classes themselves show many dependencies, but that does not make the analyzed class a hub since its own incoming/outgoing degree is low.)"
    },
    {
        "identifier": "com.github.javaparser.GeneratedJavaParserBase",
        "detection": false,
        "justification": "Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies. The class has a large number of outgoing dependencies (22 outgoing: e.g. com.github.javaparser.Provider, com.github.javaparser.ast.expr.Name, com.github.javaparser.TokenRange, com.github.javaparser.ast.Node, com.github.javaparser.ast.type.Type, com.github.javaparser.JavaToken, etc.), but it has zero incoming dependencies (incoming_dependencies is empty). Because incoming dependencies are absent, the class does not meet the bidirectional dependency criterion for a hub, so the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.RangedList",
        "detection": false,
        "justification": "Hub-like modularization is not detected because RangedList has a small number of direct relationships. Outgoing dependencies: com.github.javaparser.TokenRange, com.github.javaparser.ast.NodeList, com.github.javaparser.JavaToken (3 direct dependencies). Incoming dependencies: only com.github.javaparser.GeneratedJavaParser references RangedList (1 incoming). Although some of those related classes (e.g., NodeList, JavaToken) themselves depend on many types, RangedList itself does not exhibit a large number of both incoming and outgoing dependencies required for a hub-like smell."
    },
    {
        "identifier": "com.github.javaparser.resolution.logic.ConflictingGenericTypesException",
        "detection": false,
        "justification": "The class has 0 incoming dependencies and 1 outgoing dependency (to com.github.javaparser.resolution.types.ResolvedType). Hub-like Modularization requires an abstraction to have dependencies both incoming and outgoing with a large number of other abstractions; this class does not meet that criterion (no incoming dependencies and only a single outgoing dependency)."
    },
    {
        "identifier": "com.github.javaparser.utils.StringEscapeUtils",
        "detection": false,
        "justification": "StringEscapeUtils has a small number of connections: 3 incoming dependencies (com.github.javaparser.ast.expr.TextBlockLiteralExpr, com.github.javaparser.ast.expr.StringLiteralExpr, com.github.javaparser.ast.expr.CharLiteralExpr) and 2 outgoing dependencies (com.github.javaparser.utils.StringEscapeUtils.LookupTranslator, com.github.javaparser.utils.StringEscapeUtils.CharSequenceTranslator). The total set of incoming/outgoing relationships (5) is not a large number and the incoming dependents are closely related literal-expression classes that naturally use string-escaping utilities. Therefore it does not exhibit Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.generator.core.other.GrammarLetterGenerator",
        "detection": false,
        "justification": "The class has 0 incoming dependencies and 0 outgoing dependencies (both lists are empty). Hub-like Modularization requires many incoming and/or outgoing links; with zero dependencies this class does not meet that criterion."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.declarators.ParameterSymbolDeclarator",
        "detection": false,
        "justification": "Hub-like Modularization requires the abstraction to have many incoming and outgoing dependencies. ParameterSymbolDeclarator has 0 incoming dependencies and 3 outgoing dependencies (com.github.javaparser.resolution.TypeSolver, com.github.javaparser.ast.body.Parameter, com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserSymbolDeclaration). The absence of incoming dependencies means it does not act as a hub despite the outgoing links; therefore the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.ast.expr.CharLiteralExpr",
        "detection": true,
        "justification": "CharLiteralExpr has a large number of incoming dependencies (~22 distinct classes/modules in the provided data) including many visitor and core parser components (examples: com.github.javaparser.ast.visitor.VoidVisitor, GenericVisitor, HashCodeVisitor, EqualsVisitor, CloneVisitor, VoidVisitorAdapter, GenericVisitorAdapter, NodeFinderVisitor, Expression, GeneratedJavaParser, PrettyPrintVisitor, DefaultPrettyPrinterVisitor). It also has several outgoing dependencies (8 listed) to core/shared abstractions (com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.TokenRange, com.github.javaparser.metamodel.CharLiteralExprMetaModel, com.github.javaparser.Range, com.github.javaparser.utils.StringEscapeUtils, com.github.javaparser.utils.Utils). The combination of many incoming references from a wide variety of visitors/parsers/printers and multiple outgoing links to meta-model, token/range and utility classes indicates CharLiteralExpr functions as a central hub-like abstraction in the provided dependency graph."
    },
    {
        "identifier": "com.github.javaparser.ast.nodeTypes.SwitchNode",
        "detection": false,
        "justification": "SwitchNode has a small number of direct connections: 4 outgoing dependencies (com.github.javaparser.ast.stmt.SwitchEntry, com.github.javaparser.ast.expr.Expression, com.github.javaparser.ast.NodeList, com.github.javaparser.ast.Node) and 3 incoming dependents (com.github.javaparser.symbolsolver.javaparsermodel.contexts.SwitchEntryContext, com.github.javaparser.printer.PrettyPrintVisitor, com.github.javaparser.printer.DefaultPrettyPrinterVisitor). These links are focused on closely related AST types and printing/analysis visitors rather than a large, diverse set of abstractions, so it does not exhibit hub-like modularization."
    },
    {
        "identifier": "com.github.javaparser.ast.body.ReceiverParameter",
        "detection": true,
        "justification": "ReceiverParameter has a large number of incoming dependencies (23 distinct classes reference it — e.g. com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.printer.PrettyPrintVisitor, com.github.javaparser.GeneratedJavaParser, com.github.javaparser.ast.body.MethodDeclaration) and multiple outgoing dependencies (10 distinct types it depends on — e.g. com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.expr.Name, com.github.javaparser.ast.NodeList, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.ast.type.Type). In total it participates in dependencies with ~33 other abstractions. The combination of many incoming references from diverse visitors/parsers/printers and several outgoing links to core AST/meta types matches the Hub-like Modularization smell."
    },
    {
        "identifier": "com.github.javaparser.range.B",
        "detection": false,
        "justification": "The class has 0 incoming dependencies and 0 outgoing dependencies (no dependencies listed). Hub-like Modularization requires many incoming and outgoing connections to many other abstractions; with both counts at zero, the smell is not present."
    },
    {
        "identifier": "com.github.javaparser.ast.validator.language_level_validations.Java17PreviewValidator",
        "detection": false,
        "justification": "The class has 0 incoming dependencies and 0 outgoing dependencies (incoming_dependencies: [], outgoing_dependencies: []). Hub-like Modularization requires many incoming and outgoing dependencies; this class does not meet that criterion."
    },
    {
        "identifier": "com.github.javaparser.ast.validator.language_level_validations.Java12PreviewValidator",
        "detection": false,
        "justification": "The class has 0 outgoing dependencies and 0 incoming dependencies. Hub-like Modularization requires many incoming and outgoing links with other abstractions; with no dependencies in either direction, this class does not exhibit the smell."
    },
    {
        "identifier": "com.github.javaparser.ast.validator.postprocessors.Java19PostProcessor",
        "detection": false,
        "justification": "The class has no incoming dependencies (incoming_dependencies = []) and no outgoing dependencies (outgoing_dependencies = []), so it does not have dependencies with a large number of other abstractions and is not a hub."
    },
    {
        "identifier": "com.github.javaparser.ast.validator.postprocessors.Java21PostProcessor",
        "detection": false,
        "justification": "The class has no incoming dependencies (incoming_dependencies = []) and no outgoing dependencies (outgoing_dependencies = []). With 0 incoming and 0 outgoing relationships it cannot be a hub-like module (no large number of dependencies)."
    },
    {
        "identifier": "com.github.javaparser.utils.SourceRoot.Result",
        "detection": false,
        "justification": "The class has 0 outgoing dependencies and 0 incoming dependencies (outgoing_dependencies and incoming_dependencies arrays are empty), and analyzed_package.dependencies is empty. Because it has no incoming or outgoing links to many other abstractions, it does not exhibit Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.reflectionmodel.ReflectionPatternDeclaration",
        "detection": false,
        "justification": "The class has no incoming dependencies (incoming_dependencies is empty) and only three outgoing dependencies (com.github.javaparser.resolution.TypeSolver, com.github.javaparser.symbolsolver.reflectionmodel.ReflectionFactory, com.github.javaparser.resolution.types.ResolvedType). Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing relationships; neither condition is met here, so the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.resolution.SymbolSolver",
        "detection": true,
        "justification": "SymbolSolver has many outgoing dependencies (16 distinct abstractions: TypeSolver, ReflectionEnumDeclaration, ResolvedTypeDeclaration, SymbolReference, ResolvedType, ast.Type, Context, ReflectionClassDeclaration, Node, ReflectionInterfaceDeclaration, MethodUsage, ReflectionAnnotationDeclaration, ResolvedPrimitiveType, ResolvedReferenceTypeDeclaration, JavaParserFactory, etc.), and multiple incoming clients depend on it (at least 4 identified: JavaParserFacade, TypeExtractor, JavaParserEnumDeclaration, CompilationUnitContext). The class therefore both uses and is used by a large number of other abstractions across solver, reflection-model, AST types, resolved-types and factory/context components, matching the hub-like modularization smell (central coordinator with many incoming and outgoing links)."
    },
    {
        "identifier": "another.MyEnum",
        "detection": false,
        "justification": "The class has 0 incoming dependencies and 0 outgoing dependencies (incoming_dependencies and outgoing_dependencies are empty, and analyzed_package.dependencies is empty). Therefore it does not have dependencies with a large number of other abstractions and is not a hub."
    },
    {
        "identifier": "com.github.javaparser.metamodel.IntegerLiteralExprMetaModel",
        "detection": false,
        "justification": "Not detected: the class has 0 outgoing dependencies and only 2 incoming dependencies (com.github.javaparser.ast.expr.IntegerLiteralExpr and com.github.javaparser.metamodel.JavaParserMetaModel). Although JavaParserMetaModel references many meta-model classes (including IntegerLiteralExprMetaModel), IntegerLiteralExprMetaModel itself does not exhibit many incoming AND outgoing connections required for Hub-like Modularization."
    },
    {
        "identifier": "(default package).FieldDotExpressions",
        "detection": false,
        "justification": "FieldDotExpressions has 1 outgoing dependency ((default package).InnerClassFieldContainer) and 0 incoming dependencies. Hub-like Modularization requires an abstraction to have many incoming and outgoing dependencies; the provided data shows no large number of dependencies, so the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.ast.validator.language_level_validations.Java25Validator",
        "detection": false,
        "justification": "No incoming or outgoing dependencies are present in the provided data (incoming_dependencies = [], outgoing_dependencies = [], analyzed_package.dependencies = []). Hub-like Modularization requires an abstraction to have dependencies with a large number of other abstractions, which is not the case here."
    },
    {
        "identifier": "com.github.javaparser.ast.validator.language_level_validations.Java20Validator",
        "detection": false,
        "justification": "The class has 0 incoming dependencies and 0 outgoing dependencies (incoming_dependencies: [], outgoing_dependencies: []). Hub-like Modularization requires many incoming and outgoing relationships; none are present here."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.reflectionmodel.comparators.MethodComparator",
        "detection": false,
        "justification": "MethodComparator has only 2 outgoing dependencies (ClassComparator, ParameterComparator) and only 2 incoming dependents (ReflectionClassDeclaration, ReflectionRecordDeclaration). The total number of distinct connected abstractions is small and does not show the large many-to-many incoming/outgoing connectivity characteristic of a hub-like modularization. (Note: ParameterComparator's dependency on ClassComparator does not increase MethodComparator's incoming/outgoing degree.)"
    },
    {
        "identifier": "com.github.javaparser.printer.lexicalpreservation.LexicalPreservingVisitor",
        "detection": false,
        "justification": "LexicalPreservingVisitor has only 2 outgoing dependencies (com.github.javaparser.printer.lexicalpreservation.ChildTextElement, com.github.javaparser.printer.lexicalpreservation.TokenTextElement) and 4 incoming dependencies (com.github.javaparser.printer.lexicalpreservation.TokenTextElement, com.github.javaparser.printer.lexicalpreservation.PrintableTextElement, com.github.javaparser.printer.lexicalpreservation.DefaultLexicalPreservingPrinter, com.github.javaparser.printer.lexicalpreservation.ChildTextElement). The total set of interacting abstractions is small and partly overlapping, so it does not exhibit a large number of distinct incoming and outgoing dependencies required to classify it as a hub-like modularization."
    },
    {
        "identifier": "foo.bar.AnInterface.ListChangeType",
        "detection": false,
        "justification": "Class has 0 incoming dependencies and 0 outgoing dependencies. Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; this class has none, so the smell is not present."
    },
    {
        "identifier": "com.github.javaparser.ast.validator.language_level_validations.Java14PreviewValidator",
        "detection": false,
        "justification": "The class has no incoming dependencies (incoming_dependencies = 0) and no outgoing dependencies (outgoing_dependencies = 0). Hub-like Modularization requires an abstraction to have many incoming and outgoing dependencies; given both dependency counts are zero (and the analyzed_package.dependencies list is empty), this class is not a hub."
    },
    {
        "identifier": "main.A",
        "detection": false,
        "justification": "Not detected. The class main.A has 0 outgoing dependencies and only 1 incoming dependency (from main.Main which lists main.Main.NestedEnum, main.Child, main.A). Hub-like Modularization requires many incoming and outgoing relationships; here both directions are minimal."
    },
    {
        "identifier": "com.github.javaparser.ast.modules.ModuleDeclaration",
        "detection": true,
        "justification": "ModuleDeclaration has many incoming dependencies (references from ~23 different classes in the provided data, e.g. DefaultVisitorAdapter, CompilationUnit, numerous visitor implementations: VoidVisitor, GenericVisitor, EqualsVisitor, HashCodeVisitor, ModifierVisitor, CloneVisitor, VoidVisitorAdapter, GenericVisitorAdapter, NodeFinderVisitor, etc., plus StaticJavaParser, JavaParserAdapter, GeneratedJavaParser, PrettyPrintVisitor, DefaultPrettyPrinterVisitor). It also has a non-trivial set of outgoing dependencies (11 distinct abstractions listed: com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.expr.Name, com.github.javaparser.metamodel.ModuleDeclarationMetaModel, com.github.javaparser.ast.NodeList, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.TokenRange, com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.ast.modules.ModuleDirective, com.github.javaparser.ast.Node, com.github.javaparser.StaticJavaParser, com.github.javaparser.ast.visitor.GenericVisitor). The combination of a large number of incoming callers across many unrelated visitors/parsers/printers and multiple outgoing dependencies identifies ModuleDeclaration as a hub-like abstraction per the given definition."
    },
    {
        "identifier": "com.github.javaparser.ast.validator.language_level_validations.Java16PreviewValidator",
        "detection": false,
        "justification": "Incoming dependencies: 0 (empty). Outgoing dependencies: 0 (empty). Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; this class has none, so it does not qualify."
    },
    {
        "identifier": "(default package).ClassB",
        "detection": false,
        "justification": "ClassB has only 1 incoming dependency (from (default package).ClassA) and 0 outgoing dependencies. Hub-like Modularization requires an abstraction to have many incoming and outgoing dependencies; this class does not meet that condition."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.contexts.UnaryExprContext",
        "detection": false,
        "justification": "Not a hub: Hub-like Modularization requires the abstraction to have many incoming and outgoing dependencies. UnaryExprContext has 0 incoming dependencies and only 2 outgoing dependencies (com.github.javaparser.ast.expr.UnaryExpr, com.github.javaparser.resolution.TypeSolver). The lack of incoming dependencies and the small number of outgoing dependencies mean it does not meet the criteria for a hub."
    },
    {
        "identifier": "com.github.javaparser.printer.lexicalpreservation.Removed",
        "detection": false,
        "justification": "The class has a small number of direct relationships: 4 outgoing dependencies (com.github.javaparser.printer.lexicalpreservation.LexicalDifferenceCalculator, com.github.javaparser.ast.Node, com.github.javaparser.printer.concretesyntaxmodel.CsmToken, com.github.javaparser.printer.concretesyntaxmodel.CsmElement) and 2 incoming dependencies (com.github.javaparser.printer.lexicalpreservation.Difference, com.github.javaparser.printer.lexicalpreservation.RemovedGroup). Hub-like modularization requires an abstraction to have dependencies with a large number of other abstractions in both directions; here both incoming (2) and outgoing (4) counts are low. Note: although some of the outgoing target classes themselves have many dependencies, the analysis considers the Removed class in isolation and counts only its direct incoming/outgoing links, which are insufficient to classify it as a hub."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.resolution.typeinference.ProperLowerBound",
        "detection": false,
        "justification": "ProperLowerBound has only 2 outgoing dependencies (InferenceVariable, ResolvedType) and 0 incoming dependencies. A hub requires many incoming and outgoing relationships; this class does not exhibit a large number of dependencies in either direction."
    },
    {
        "identifier": "com.github.javaparser.metamodel.MethodCallExprMetaModel",
        "detection": false,
        "justification": "The class is not a hub: it has only 1 outgoing dependency (com.github.javaparser.metamodel.PropertyMetaModel) and only 2 incoming dependents (com.github.javaparser.ast.expr.MethodCallExpr and com.github.javaparser.metamodel.JavaParserMetaModel). Hub-like modularization requires dependencies (both incoming and outgoing) with a large number of other abstractions; the provided counts are low."
    },
    {
        "identifier": "japa.bdd.samples.JavaConcepts.Sexo_",
        "detection": false,
        "justification": "The class has no incoming dependencies and no outgoing dependencies (incoming_dependencies = [], outgoing_dependencies = []). Since Hub-like Modularization requires dependencies (both incoming and outgoing) with a large number of other abstractions, this class does not meet that condition."
    },
    {
        "identifier": "com.github.javaparser.ast.visitor.VoidVisitorWithDefaults",
        "detection": false,
        "justification": "The class has a very large number of outgoing dependencies (numerous AST node and meta-model types such as TraditionalJavadocComment, UnaryExpr, MethodDeclaration, ClassOrInterfaceDeclaration, Node, CompilationUnit, RecordPatternExpr, etc.), but it has zero incoming dependencies (incoming_dependencies is empty). Hub-like Modularization requires an abstraction to have both many incoming and many outgoing dependencies; here only the outgoing side is large while the incoming side is absent, so the hub-like smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.ast.expr.ThisExpr",
        "detection": true,
        "justification": "ThisExpr has a large number of both incoming and outgoing dependencies. Outgoing dependencies (11): com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.expr.Name, com.github.javaparser.Range, com.github.javaparser.ast.expr.Expression, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.TokenRange, com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.ast.Node, com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.metamodel.ThisExprMetaModel. Incoming dependencies (21) include many visitor and tooling classes that reference ThisExpr (examples: com.github.javaparser.symbolsolver.javaparsermodel.DefaultVisitorAdapter, com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade, com.github.javaparser.symbolsolver.javaparsermodel.TypeExtractor, multiple com.github.javaparser.ast.visitor classes such as VoidVisitor, GenericVisitor, HashCodeVisitor, EqualsVisitor, ModifierVisitor, VoidVisitorAdapter, GenericVisitorAdapter, PrettyPrintVisitor, DefaultPrettyPrinterVisitor, CloneVisitor, NodeFinderVisitor, GeneratedJavaParser, and com.github.javaparser.ast.expr.Expression). The combination of numerous incoming references from many visitor/printer/resolution classes and outgoing links to core AST/meta-model/resolution types indicates ThisExpr functions as a hub-like abstraction connecting many other abstractions."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.TypeExtractor",
        "detection": false,
        "justification": "TypeExtractor has a large number of outgoing dependencies (68 distinct referenced abstractions including com.github.javaparser.ast.expr.Expression, com.github.javaparser.ast.Node, com.github.javaparser.resolution.types.ResolvedType, com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade, com.github.javaparser.resolution.TypeSolver, etc.), but it has only a single incoming dependency recorded (only com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade depends on TypeExtractor). The Hub-like Modularization smell requires the abstraction to have both many incoming and many outgoing relationships; here outgoing fan-out is high while incoming fan-in is minimal, so the smell is not detected when the class is considered in isolation."
    },
    {
        "identifier": "com.github.javaparser.ast.body.MethodDeclaration",
        "detection": true,
        "justification": "MethodDeclaration shows hub-like modularization: it has a large number of outgoing dependencies (20) to many core AST and infrastructure types (e.g. com.github.javaparser.ast.Node, com.github.javaparser.ast.NodeList, com.github.javaparser.ast.type.Type, com.github.javaparser.ast.stmt.BlockStmt, com.github.javaparser.TokenRange, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.ast.Modifier, com.github.javaparser.ast.comments.JavadocComment, com.github.javaparser.ast.expr.SimpleName, com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration) and a very large number of incoming dependencies (59) from diverse visitors, printers, generators and tooling classes (e.g. com.github.javaparser.ast.visitor.VoidVisitor, GenericVisitor, EqualsVisitor, HashCodeVisitor, PrettyPrintVisitor, DefaultPrettyPrinterVisitor; many generator classes such as MetaModelGenerator, Generator, NodeGenerator, VisitorGenerator, and many visitor-generator variants; tooling classes such as StaticJavaParser, Navigator, PositionUtils). The coexistence of many incoming references from disparate components and many outgoing references to core abstractions indicates MethodDeclaration functions as a central hub and therefore exhibits the Hub-like Modularization smell."
    },
    {
        "identifier": "com.github.javaparser.generator.VisitorGenerator",
        "detection": false,
        "justification": "Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies. VisitorGenerator has no incoming dependencies (incoming_dependencies = []), and only six outgoing dependencies: com.github.javaparser.metamodel.BaseNodeMetaModel, com.github.javaparser.ast.CompilationUnit, com.github.javaparser.ast.body.ClassOrInterfaceDeclaration, com.github.javaparser.ast.body.MethodDeclaration, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.utils.SourceRoot. Because it lacks incoming connections and its outgoing dependency set is small, it does not meet the hub-like modularization criteria."
    },
    {
        "identifier": "com.github.javaparser.generator.core.visitor.GenericVisitorAdapterGenerator",
        "detection": false,
        "justification": "Hub-like Modularization requires an abstraction to have many BOTH incoming and outgoing dependency links. This class has 0 incoming dependencies (incoming_dependencies is empty) and only 5 outgoing dependencies: com.github.javaparser.metamodel.BaseNodeMetaModel, com.github.javaparser.ast.stmt.BlockStmt, com.github.javaparser.ast.CompilationUnit, com.github.javaparser.ast.body.MethodDeclaration, com.github.javaparser.utils.SourceRoot. Because there are no incoming links and the outgoing degree is small, the class does not meet the hub-like criteria."
    },
    {
        "identifier": "a.RefClass2",
        "detection": false,
        "justification": "RefClass2 has 0 incoming dependencies and 0 outgoing dependencies (incoming_dependencies: [], outgoing_dependencies: []). Hub-like Modularization requires many incoming and outgoing connections; this class does not meet that criterion."
    },
    {
        "identifier": "com.github.javaparser.ast.validator.language_level_validations.Java1_4Validator",
        "detection": false,
        "justification": "Java1_4Validator has 0 incoming dependencies and 0 outgoing dependencies (incoming_dependencies: [], outgoing_dependencies: []), so it does not exhibit hub-like modularization which requires many incoming and outgoing connections."
    },
    {
        "identifier": "com.github.javaparser.printer.DotPrinter",
        "detection": false,
        "justification": "DotPrinter has 0 incoming dependencies and only 4 outgoing dependencies (com.github.javaparser.ast.NodeList, com.github.javaparser.metamodel.NodeMetaModel, com.github.javaparser.utils.LineSeparator, com.github.javaparser.ast.Node). Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; the absence of incoming dependencies and a modest number of outgoing dependencies means DotPrinter is not a hub."
    },
    {
        "identifier": "com.github.javaparser.metamodel.CompilationUnitMetaModel",
        "detection": false,
        "justification": "CompilationUnitMetaModel has only a single outgoing dependency (com.github.javaparser.metamodel.PropertyMetaModel) and only two incoming dependencies (com.github.javaparser.ast.CompilationUnit and com.github.javaparser.metamodel.JavaParserMetaModel). Hub-like Modularization requires an abstraction to have dependencies with a large number of other abstractions on both incoming and outgoing sides; the provided data shows neither side has a large number of connections."
    },
    {
        "identifier": "com.github.javaparser.ast.comments.TraditionalJavadocComment",
        "detection": false,
        "justification": "TraditionalJavadocComment has a high number of incoming dependencies (≈20 distinct clients such as com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.visitor.GenericVisitor, many visitor implementations like HashCodeVisitor/EqualsVisitor/CloneVisitor, and printer classes like com.github.javaparser.printer.PrettyPrintVisitor and com.github.javaparser.printer.DefaultPrettyPrinterVisitor), but only a small set of outgoing dependencies (7 listed: com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.javadoc.Javadoc, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.TokenRange, com.github.javaparser.StaticJavaParser, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.metamodel.TraditionalJavadocCommentMetaModel). The hub-like modularization smell requires both many incoming and many outgoing connections; here fan-in is high but fan-out is low, so the class is not a hub by the provided data."
    },
    {
        "identifier": "com.github.javaparser.utils.StringEscapeUtils.CharSequenceTranslator",
        "detection": false,
        "justification": "The class has 1 incoming dependency (com.github.javaparser.utils.StringEscapeUtils) and 0 outgoing dependencies. Hub-like Modularization requires an abstraction to have many incoming and outgoing dependencies; the provided data shows only a single incoming link and no outgoing links, so this is not a hub."
    },
    {
        "identifier": "com.foo.base.Widget",
        "detection": false,
        "justification": "Both incoming and outgoing dependency lists are empty (incoming_dependencies = [], outgoing_dependencies = []). Hub-like Modularization requires an abstraction to have dependencies with a large number of other abstractions; Widget has zero incoming and zero outgoing dependencies, so it is not a hub."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.cache.NoCache",
        "detection": false,
        "justification": "NoCache has only 1 outgoing dependency (com.github.javaparser.resolution.cache.CacheStats) and 0 incoming dependencies. Hub-like modularization requires many incoming and outgoing relationships; the provided data does not show a large number of dependencies, so the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.DefaultVisitorAdapter",
        "detection": false,
        "justification": "The class has a large number of outgoing dependencies (106 distinct external classes in the provided list, e.g. com.github.javaparser.ast.expr.UnaryExpr, com.github.javaparser.ast.body.MethodDeclaration, com.github.javaparser.ast.CompilationUnit, com.github.javaparser.ast.type.ClassOrInterfaceType), but zero incoming dependencies (incoming_dependencies is empty). Hub-like Modularization requires an abstraction to have many dependencies in both directions (many incoming and many outgoing). Because there are no incoming dependencies in the provided data, the hub-like modularization smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.ast.validator.language_level_validations.Java13PreviewValidator",
        "detection": false,
        "justification": "The class has no incoming dependencies (incoming_dependencies = []) and no outgoing dependencies (outgoing_dependencies = []). Hub-like Modularization requires an abstraction to have dependencies with a large number of other abstractions; here both dependency counts are zero, so the smell is not present."
    },
    {
        "identifier": "com.github.javaparser.ast.expr.ArrayAccessExpr",
        "detection": true,
        "justification": "ArrayAccessExpr exhibits hub-like modularization: it has a large number of incoming dependencies (23 distinct classes depend on it, e.g. com.github.javaparser.symbolsolver.javaparsermodel.DefaultVisitorAdapter, com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.printer.PrettyPrintVisitor, com.github.javaparser.printer.DefaultPrettyPrinterVisitor, com.github.javaparser.ast.visitor.EqualsVisitor, com.github.javaparser.ast.visitor.CloneVisitor, com.github.javaparser.ast.expr.Expression, com.github.javaparser.GeneratedJavaParser) while also depending on multiple other abstractions itself (9 outgoing dependencies, e.g. com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.metamodel.ArrayAccessExprMetaModel, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.Range, com.github.javaparser.TokenRange, com.github.javaparser.ast.Node, com.github.javaparser.ast.expr.Expression, com.github.javaparser.ast.observer.ObservableProperty). The combination of high in-degree (many clients/visitors referencing this class) and non-trivial out-degree qualifies it as a hub-like abstraction."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.reflectionmodel.ReflectionAnnotationMemberDeclaration",
        "detection": false,
        "justification": "Hub-like Modularization requires an abstraction to have dependencies both incoming and outgoing with a large number of other abstractions. The provided data shows 6 outgoing dependencies: com.github.javaparser.resolution.model.SymbolReference, com.github.javaparser.resolution.types.ResolvedType, com.github.javaparser.resolution.TypeSolver, com.github.javaparser.ast.expr.Expression, com.github.javaparser.ast.NodeList, com.github.javaparser.resolution.types.ResolvedPrimitiveType, and 0 incoming dependencies. Because there are no incoming dependencies (incoming count = 0), the class does not meet the definition of a hub (which requires many incoming and outgoing connections)."
    },
    {
        "identifier": "com.github.javaparser.ast.nodeTypes.NodeWithBody",
        "detection": false,
        "justification": "NodeWithBody has outgoing dependencies to 2 classes (com.github.javaparser.ast.stmt.BlockStmt, com.github.javaparser.ast.stmt.Statement) and has 0 incoming dependencies. Hub-like Modularization requires the abstraction to have many incoming and outgoing dependencies. Although the outgoing targets themselves reference many other classes (BlockStmt -> 9 dependencies; Statement -> 26 dependencies), NodeWithBody in isolation does not exhibit a large number of incoming dependencies, so it is not a hub."
    },
    {
        "identifier": "com.github.javaparser.resolution.declarations.ResolvedTypePatternDeclaration",
        "detection": false,
        "justification": "ResolvedTypePatternDeclaration has 0 outgoing dependencies (no outbound edges) and only 1 incoming dependency source (com.github.javaparser.resolution.declarations.ResolvedDeclaration). Although ResolvedDeclaration itself references multiple declarations (ResolvedFieldDeclaration, ResolvedParameterDeclaration, ResolvedEnumConstantDeclaration, ResolvedTypeDeclaration, ResolvedMethodDeclaration, ResolvedTypePatternDeclaration), the analyzed class interacts directly with only that single abstraction. Hub-like Modularization requires many incoming and outgoing dependencies with numerous distinct abstractions; those conditions are not met here."
    },
    {
        "identifier": "com.github.javaparser.printer.lexicalpreservation.Difference.EnforcingIndentationContext",
        "detection": false,
        "justification": "The analyzed class has no outgoing dependencies (outgoing_dependencies = []) and only a single incoming dependency (from com.github.javaparser.printer.lexicalpreservation.Difference). Hub-like Modularization requires an abstraction to have many incoming and outgoing connections; here incoming count = 1 and outgoing count = 0, so this class is not a hub."
    },
    {
        "identifier": "com.github.javaparser.generator.core.node.MainConstructorGenerator",
        "detection": false,
        "justification": "Hub-like modularization requires an abstraction to have dependencies both incoming and outgoing with a large number of other abstractions. For MainConstructorGenerator there are no incoming dependencies (incoming_dependencies is empty). The class has 8 outgoing dependencies: com.github.javaparser.StaticJavaParser, com.github.javaparser.metamodel.BaseNodeMetaModel, com.github.javaparser.ast.body.ConstructorDeclaration, com.github.javaparser.ast.stmt.BlockStmt, com.github.javaparser.ast.CompilationUnit, com.github.javaparser.ast.body.ClassOrInterfaceDeclaration, com.github.javaparser.utils.SeparatedItemStringBuilder, and com.github.javaparser.utils.SourceRoot. Because incoming dependencies are absent and the outgoing set is moderate, the criteria for a hub-like module (many incoming and outgoing connections) is not met."
    },
    {
        "identifier": "javaparser.GenericClass.Foo",
        "detection": false,
        "justification": "The class has 0 outgoing dependencies and only 1 incoming dependency (from javaparser.GenericClass). Hub-like Modularization requires an abstraction to have both many incoming and outgoing dependencies with a large number of other abstractions; these counts are low, so the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.ast.validator.language_level_validations.Java15PreviewValidator",
        "detection": false,
        "justification": "The class has 0 incoming dependencies and 0 outgoing dependencies (incoming_dependencies: [], outgoing_dependencies: []). Hub-like Modularization requires an abstraction to have dependencies both incoming and outgoing with a large number of other abstractions; since both dependency lists are empty, this class does not exhibit the hub-like modularization smell."
    },
    {
        "identifier": "com.github.javaparser.metamodel.ClassExprMetaModel",
        "detection": false,
        "justification": "ClassExprMetaModel has only 1 outgoing dependency (com.github.javaparser.metamodel.PropertyMetaModel) and only 2 incoming dependents (com.github.javaparser.ast.expr.ClassExpr and com.github.javaparser.metamodel.JavaParserMetaModel). These small numbers of both incoming and outgoing relationships do not constitute a hub-like modularization."
    },
    {
        "identifier": "com.github.javaparser.ast.expr.AssignExpr",
        "detection": true,
        "justification": "AssignExpr has a large number of incoming and outgoing dependencies: outgoing dependencies include ~11 core abstractions (examples: com.github.javaparser.ast.Node, com.github.javaparser.ast.expr.Expression, com.github.javaparser.ast.expr.BinaryExpr, com.github.javaparser.TokenRange, com.github.javaparser.Range, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.metamodel.AssignExprMetaModel, com.github.javaparser.ast.expr.AssignExpr.Operator, com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.visitor.GenericVisitor), while it is depended on by ~25 other abstractions (incoming examples: many visitor and utility classes such as DefaultVisitorAdapter, VoidVisitor, GenericVisitor, ModifierVisitor, HashCodeVisitor, EqualsVisitor, CloneVisitor, VoidVisitorAdapter, GenericVisitorWithDefaults, NodeFinderVisitor, PrettyPrintVisitor, DefaultPrettyPrinterVisitor, as well as symbol solver classes like TypeExtractor and LambdaExprContext and parser code like GeneratedJavaParser). The class therefore functions as a central hub with numerous both incoming and outgoing links to diverse modules, which matches the Hub-like Modularization smell."
    },
    {
        "identifier": "com.github.javaparser.metamodel.MatchAllPatternExprMetaModel",
        "detection": false,
        "justification": "Outgoing dependencies are limited (only com.github.javaparser.metamodel.PropertyMetaModel). Incoming dependencies come from two classes: com.github.javaparser.ast.expr.MatchAllPatternExpr and com.github.javaparser.metamodel.JavaParserMetaModel. Hub-like modularization requires many incoming and outgoing relationships; here outgoing = 1 and incoming = 2, so this class is not a hub."
    },
    {
        "identifier": "com.github.javaparser.ast.validator.postprocessors.Java23PostProcessor",
        "detection": false,
        "justification": "The class has 0 incoming dependencies and 0 outgoing dependencies in the provided data. Hub-like Modularization requires an abstraction to have dependencies with a large number of other abstractions (many incoming and outgoing links); this class does not meet that condition."
    },
    {
        "identifier": "com.github.javaparser.resolution.types.parametrization.ResolvedTypeParameterValueProvider",
        "detection": false,
        "justification": "Not a hub: Hub-like Modularization requires the abstraction to have both many incoming and many outgoing dependencies. In the provided data this class has 0 incoming dependencies and only 3 outgoing dependencies (com.github.javaparser.resolution.types.ResolvedWildcard, com.github.javaparser.resolution.types.ResolvedType, com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration), which does not constitute a large number of mutual dependencies."
    },
    {
        "identifier": "com.github.javaparser.ast.validator.language_level_validations.chunks.NoBinaryIntegerLiteralsValidator",
        "detection": false,
        "justification": "NoBinaryIntegerLiteralsValidator has outgoing dependencies to 4 abstractions (com.github.javaparser.ast.expr.LiteralStringValueExpr, com.github.javaparser.ast.expr.LongLiteralExpr, com.github.javaparser.ast.validator.ProblemReporter, com.github.javaparser.ast.expr.IntegerLiteralExpr) and has 0 incoming dependencies. Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; here incoming dependencies are absent and outgoing dependencies are limited (4), so it does not qualify as a hub."
    },
    {
        "identifier": "com.github.javaparser.ast.expr.CastExpr",
        "detection": true,
        "justification": "CastExpr has a large number of incoming dependencies (24 distinct callers) including many visitor and utility classes (e.g., com.github.javaparser.symbolsolver.javaparsermodel.DefaultVisitorAdapter, com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.ast.visitor.ModifierVisitor, com.github.javaparser.printer.PrettyPrintVisitor, com.github.javaparser.GeneratedJavaParser, etc.), and it also has multiple outgoing dependencies (10 distinct targets) such as com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.ast.expr.Expression, com.github.javaparser.ast.type.Type, com.github.javaparser.ast.Node, com.github.javaparser.TokenRange, com.github.javaparser.Range, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.metamodel.CastExprMetaModel, and com.github.javaparser.ast.observer.ObservableProperty. The combination of many incoming connections (many other abstractions depend on CastExpr) together with several outgoing connections (CastExpr depends on many abstractions) matches the Hub-like Modularization smell."
    },
    {
        "identifier": "(default package).c",
        "detection": false,
        "justification": "Class (default package).c has 0 outgoing dependencies and 0 incoming dependencies (both lists are empty), so it does not have dependencies with a large number of other abstractions and therefore is not a hub-like module."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.reflectionmodel.ReflectionTypeParameter",
        "detection": false,
        "justification": "ReflectionTypeParameter has outgoing dependencies to 7 distinct abstractions: com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration, com.github.javaparser.resolution.TypeSolver, com.github.javaparser.symbolsolver.reflectionmodel.ReflectionMethodDeclaration, com.github.javaparser.symbolsolver.reflectionmodel.ReflectionFactory, com.github.javaparser.resolution.declarations.ResolvedTypeParametrizable, com.github.javaparser.symbolsolver.reflectionmodel.ReflectionConstructorDeclaration, and com.github.javaparser.resolution.types.ResolvedReferenceType. However, it has only a single incoming dependency (used by com.github.javaparser.symbolsolver.reflectionmodel.ReflectionFactory). Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; here the incoming dependency count is minimal, so the class does not exhibit a hub-like modularization smell."
    },
    {
        "identifier": "com.github.javaparser.ast.body.TypeDeclaration",
        "detection": true,
        "justification": "TypeDeclaration has a large number of both outgoing and incoming relationships: 13 outgoing dependencies (e.g. com.github.javaparser.ast.Node, com.github.javaparser.ast.NodeList, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.TokenRange, com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.Range, com.github.javaparser.ast.body.CallableDeclaration) and 14 incoming dependencies (e.g. com.github.javaparser.symbolsolver.JavaSymbolSolver, com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade, com.github.javaparser.ast.CompilationUnit, com.github.javaparser.ast.visitor.CloneVisitor, com.github.javaparser.GeneratedJavaParser, com.github.javaparser.resolution.Navigator, com.github.javaparser.generator.AbstractGenerator). The class therefore has many incoming and outgoing connections across diverse abstractions, exhibiting the hub-like modularization smell."
    },
    {
        "identifier": "(default package).A",
        "detection": false,
        "justification": "Class A has only 1 incoming dependency (from (default package).B) and 1 outgoing dependency (to com.github.javaparser.quality.Preconditions). Hub-like Modularization requires many incoming and outgoing dependencies; these counts are low, so A is not a hub."
    },
    {
        "identifier": "com.github.javaparser.resolution.logic.FunctionalInterfaceLogic",
        "detection": true,
        "justification": "FunctionalInterfaceLogic has a large number of incoming dependencies (7 distinct classes reference it: com.github.javaparser.symbolsolver.javaparsermodel.TypeExtractor; com.github.javaparser.symbolsolver.javaparsermodel.contexts.LambdaExprContext; com.github.javaparser.symbolsolver.javaparsermodel.contexts.MethodReferenceExprContext; com.github.javaparser.symbolsolver.resolution.typeinference.TypeHelper; com.github.javaparser.symbolsolver.resolution.typeinference.constraintformulas.ExpressionCompatibleWithType; com.github.javaparser.resolution.model.typesystem.ReferenceTypeImpl; com.github.javaparser.resolution.logic.MethodResolutionLogic) while also depending on multiple other abstractions (3 outgoing dependencies: com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration; com.github.javaparser.resolution.MethodUsage; com.github.javaparser.resolution.types.ResolvedType). These incoming references come from diverse subsystems (javaparsermodel, contexts, typeinference, model.typesystem, resolution.logic), indicating FunctionalInterfaceLogic acts as a central connector/hub between many modules. Total distinct collaborators (10) and the cross-cutting nature of ties justify classifying it as a hub-like modularization smell."
    },
    {
        "identifier": "d.e.f.DataObjectFactory",
        "detection": false,
        "justification": "The class has 0 incoming dependencies and 0 outgoing dependencies (analyzed_package.dependencies = [], incoming_dependencies = [], outgoing_dependencies = []). Hub-like Modularization requires an abstraction to have many incoming and outgoing dependencies, which is not the case here."
    },
    {
        "identifier": "com.github.javaparser.ast.validator.language_level_validations.Java7Validator",
        "detection": false,
        "justification": "Java7Validator has only one outgoing dependency (com.github.javaparser.ast.validator.SingleNodeTypeValidator) and zero incoming dependencies. Hub-like Modularization requires many incoming and outgoing dependency relationships; the provided metrics show no large number of connections for this class."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.contexts.IfStatementContext",
        "detection": false,
        "justification": "IfStatementContext has multiple outgoing dependencies (e.g. com.github.javaparser.resolution.Context, com.github.javaparser.symbolsolver.javaparsermodel.PatternVariableResult, com.github.javaparser.resolution.TypeSolver, com.github.javaparser.ast.expr.Expression, com.github.javaparser.symbolsolver.javaparsermodel.PatternVariableVisitor, com.github.javaparser.ast.stmt.IfStmt, com.github.javaparser.symbolsolver.javaparsermodel.contexts.AbstractJavaParserContext, com.github.javaparser.ast.Node, com.github.javaparser.symbolsolver.javaparsermodel.NormalCompletionVisitor), but the provided data shows no incoming dependencies (incoming_dependencies is empty). The Hub-like Modularization smell requires an abstraction to have a large number of both incoming and outgoing dependencies; since there are no incoming dependencies in the given data, the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.generator.metamodel.InitializeConstructorParametersStatementsGenerator",
        "detection": false,
        "justification": "The class has only 1 incoming dependency (com.github.javaparser.generator.metamodel.NodeMetaModelGenerator) and 3 outgoing dependencies (com.github.javaparser.StaticJavaParser, com.github.javaparser.ast.NodeList, com.github.javaparser.generator.metamodel.MetaModelGenerator). These small numbers of incoming and outgoing relationships do not constitute a hub-like abstraction (no large number of both incoming and outgoing dependencies)."
    },
    {
        "identifier": "com.github.javaparser.ast.expr.ConditionalExpr",
        "detection": true,
        "justification": "ConditionalExpr shows hub-like modularization: it has a large number of incoming dependencies from many different abstractions (examples: numerous visitor and utility classes such as DefaultVisitorAdapter, TypeExtractor, ConditionalExprContext, TypeInference, ExpressionCompatibleWithType, VoidVisitor, HashCodeVisitor, EqualsVisitor, CloneVisitor, GeneratedJavaParser, PrettyPrintVisitor, DefaultPrettyPrinterVisitor, and many other visitor/solver/printer classes listed under incoming_dependencies). It also has multiple outgoing dependencies to core abstractions (examples: com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.ast.expr.Expression, com.github.javaparser.ast.Node, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.TokenRange, com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.Range, com.github.javaparser.metamodel.ConditionalExprMetaModel). Several of these outgoing dependencies themselves link to large sets of abstractions (see the long dependency lists for VoidVisitor, GenericVisitor, Expression, Node and JavaParserMetaModel in the provided data), increasing the effective coupling. The combination of many distinct incoming references plus multiple outgoing ties (including to highly-connected meta/visitor/core classes) indicates ConditionalExpr functions as a hub and therefore exhibits the Hub-like Modularization smell."
    },
    {
        "identifier": "com.packageName.InnerStaticClassFieldContainer.InnerInnerClass",
        "detection": false,
        "justification": [
            "The class has 0 incoming dependencies and 0 outgoing dependencies (incoming_dependencies and outgoing_dependencies are empty), so it does not have a large number of connections required for a hub-like module."
        ]
    },
    {
        "identifier": "com.github.javaparser.ast.Node.DirectChildrenIterator",
        "detection": false,
        "justification": "The class has 0 incoming dependencies and 0 outgoing dependencies (incoming_dependencies: [], outgoing_dependencies: []). The analyzed_package.dependencies list is also empty, so it does not have dependencies with a large number of other abstractions and therefore is not a hub."
    },
    {
        "identifier": "com.github.javaparser.resolution.types.ResolvedLambdaConstraintType",
        "detection": false,
        "justification": "ResolvedLambdaConstraintType has 1 outgoing dependency (com.github.javaparser.resolution.types.ResolvedType) and is referenced by 5 incoming classes: com.github.javaparser.symbolsolver.javaparsermodel.contexts.LambdaExprContext, com.github.javaparser.symbolsolver.javaparsermodel.contexts.MethodReferenceExprContext, com.github.javaparser.symbolsolver.javaparsermodel.contexts.MethodCallExprContext, com.github.javaparser.resolution.types.ResolvedType, and com.github.javaparser.resolution.logic.InferenceContext. That yields 6 distinct direct connections in the provided data. This number of incoming/outgoing links is small and does not show the large, widespread coupling characteristic of a hub-like modularization (no many heterogeneous abstractions depend on or are depended on by this class), so the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.utils.VisitorList",
        "detection": false,
        "justification": "com.github.javaparser.utils.VisitorList has a single outgoing dependency: com.github.javaparser.ast.visitor.GenericVisitor, and a single incoming dependency: com.github.javaparser.utils.VisitorList.EqualsHashcodeOverridingFacade. Hub-like modularization requires an abstraction to have many incoming and outgoing dependencies; here both incoming and outgoing counts are low. (While GenericVisitor itself depends on many AST classes, those are dependencies of GenericVisitor, not direct dependencies of VisitorList.)"
    },
    {
        "identifier": "com.github.javaparser.ast.visitor.ModifierVisitor",
        "detection": false,
        "justification": "ModifierVisitor has a large number of outgoing dependencies (e.g., com.github.javaparser.ast.Node, com.github.javaparser.ast.expr.Expression, com.github.javaparser.ast.stmt.Statement, com.github.javaparser.ast.body.MethodDeclaration, com.github.javaparser.ast.body.ClassOrInterfaceDeclaration, com.github.javaparser.ast.CompilationUnit and many other AST node types and comment types) but has no incoming dependencies (incoming_dependencies is empty). Hub-like Modularization requires an abstraction to have many both incoming and outgoing dependencies; because incoming dependencies are absent, this class is not exhibiting Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.contexts.EnclosedExprContext",
        "detection": false,
        "justification": "EnclosedExprContext has only 2 outgoing dependencies (com.github.javaparser.ast.expr.EnclosedExpr, com.github.javaparser.resolution.TypeSolver) and 0 incoming dependencies. Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing connections; here the incoming degree is zero and the outgoing degree is minimal, so the smell is not present."
    },
    {
        "identifier": "com.github.javaparser.generator.metamodel.AstTypeAnalysis",
        "detection": false,
        "justification": "AstTypeAnalysis has 0 outgoing dependencies and only 2 incoming dependents (NodeMetaModelGenerator, InitializePropertyMetaModelsStatementsGenerator). Hub-like Modularization requires an abstraction to have both many incoming and many outgoing dependencies; AstTypeAnalysis lacks outgoing dependencies and has a small number of incoming dependents, so it does not qualify."
    },
    {
        "identifier": "(default package).InnerClassDotExpressions.InnerInnerClass",
        "detection": false,
        "justification": [
            "Class has no incoming dependencies and no outgoing dependencies (incoming_dependencies = [], outgoing_dependencies = []), so it does not have dependencies with a large number of other abstractions and therefore is not a hub."
        ]
    },
    {
        "identifier": "com.github.javaparser.ast.nodeTypes.NodeWithBlockStmt",
        "detection": false,
        "justification": "NodeWithBlockStmt has only one direct outgoing dependency (com.github.javaparser.ast.stmt.BlockStmt) and zero incoming dependencies. Hub-like Modularization requires an abstraction to have many incoming and outgoing relationships; the provided data shows only a single outgoing link and no incoming links, so it is not a hub."
    },
    {
        "identifier": "com.github.javaparser.metamodel.SwitchStmtMetaModel",
        "detection": false,
        "justification": "SwitchStmtMetaModel has only 1 outgoing dependency (com.github.javaparser.metamodel.PropertyMetaModel) and 2 incoming dependencies (com.github.javaparser.ast.stmt.SwitchStmt and com.github.javaparser.metamodel.JavaParserMetaModel) in the provided data. Although JavaParserMetaModel lists many meta-models, it counts as a single incoming abstraction. The class therefore does not exhibit dependencies with a large number of other abstractions and is not a hub-like module."
    },
    {
        "identifier": "(default package).X",
        "detection": false,
        "justification": "Class (default package).X has 0 incoming dependencies and 0 outgoing dependencies. Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; since both counts are zero, the smell is not present."
    },
    {
        "identifier": "com.github.javaparser.metamodel.CastExprMetaModel",
        "detection": false,
        "justification": "CastExprMetaModel has low connectivity: outgoing dependencies = 1 (com.github.javaparser.metamodel.PropertyMetaModel); incoming dependencies = 2 (com.github.javaparser.ast.expr.CastExpr and com.github.javaparser.metamodel.JavaParserMetaModel). Hub-like Modularization requires an abstraction to have incoming and outgoing relationships with a large number of other abstractions. The provided data shows only a small number of incoming/outgoing links, so CastExprMetaModel is not a hub."
    },
    {
        "identifier": "extends_duplicate.DuplicateTypeName",
        "detection": false,
        "justification": "The class has 0 incoming dependencies and 0 outgoing dependencies (incoming_dependencies and outgoing_dependencies are empty, analyzed_package.dependencies is empty). Hub-like Modularization requires an abstraction to have many incoming and outgoing dependencies, which is not the case here."
    },
    {
        "identifier": "japa.bdd.samples.JavaConcepts.Enum",
        "detection": false,
        "justification": "The class has no incoming or outgoing dependencies (incoming: 0, outgoing: 0). Because it does not have dependencies with a large number of other abstractions, it does not exhibit Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.resolution.typeinference.Instantiation",
        "detection": false,
        "justification": "Instantiation has only 2 outgoing dependencies (InferenceVariable, ResolvedType) and is directly referenced by 2 incoming classes (BoundSet, InstantiationSet). A hub-like module would have many incoming and outgoing dependency edges to many other abstractions; the provided data shows only a small number of direct connections. (Note: BoundSet itself has many dependencies, but those are not direct dependencies of Instantiation in the provided data.)"
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.reflectionmodel.ReflectionEnumDeclaration",
        "detection": false,
        "justification": "ReflectionEnumDeclaration has a relatively large number of outgoing dependencies (15 distinct target abstractions, e.g. ResolvedEnumConstantDeclaration, TypeSolver, SymbolReference, ResolvedType, ReflectionMethodResolutionLogic, ReflectionFactory, ReflectionClassAdapter, MethodUsage, ResolvedReferenceTypeDeclaration, InferenceContext, etc.) but only 2 incoming dependencies (ReflectionEnumConstantDeclaration and SymbolSolver). Hub-like Modularization requires an abstraction to have many incoming and outgoing dependencies; here the incoming degree is small, so this class does not meet the definition of a hub in isolation."
    },
    {
        "identifier": "com.github.javaparser.ast.visitor.NoCommentEqualsVisitor",
        "detection": false,
        "justification": "NoCommentEqualsVisitor has a very large number of outgoing dependencies (it references many AST node and related types such as com.github.javaparser.ast.Node, com.github.javaparser.ast.expr.MethodCallExpr, com.github.javaparser.ast.body.MethodDeclaration, com.github.javaparser.ast.comments.TraditionalJavadocComment, com.github.javaparser.ast.CompilationUnit, com.github.javaparser.ast.NodeList, etc.), but the provided data shows zero incoming dependencies (incoming_dependencies is empty). Hub-like Modularization requires an abstraction to have both a large number of incoming and outgoing dependencies; because this class has no incoming dependencies in the given data, it does not meet the definition of a hub."
    },
    {
        "identifier": "(default package).InnerClassFieldContainer.InnerInnerClass",
        "detection": false,
        "justification": "The class has zero incoming dependencies and zero outgoing dependencies (incoming_dependencies: [], outgoing_dependencies: []), so it does not depend on or is depended upon by a large number of other abstractions and therefore is not a hub-like modularization."
    },
    {
        "identifier": "com.github.javaparser.ast.stmt.ForStmt",
        "detection": true,
        "justification": "ForStmt has a large number of both outgoing and incoming dependencies. Outgoing: 11 distinct abstractions (examples: com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.stmt.Statement, com.github.javaparser.metamodel.ForStmtMetaModel, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.ast.expr.Expression, com.github.javaparser.ast.NodeList, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.TokenRange, com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.ast.Node, com.github.javaparser.Range). Incoming: 23 distinct abstractions reference ForStmt (examples: com.github.javaparser.symbolsolver.javaparsermodel.DefaultVisitorAdapter, com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFactory, com.github.javaparser.symbolsolver.javaparsermodel.NormalCompletionVisitor, com.github.javaparser.symbolsolver.javaparsermodel.contexts.ForStatementContext, plus many visitor/printer classes such as com.github.javaparser.ast.visitor.VoidVisitor, GenericVisitor, ModifierVisitor, HashCodeVisitor, PrettyPrintVisitor, DefaultPrettyPrinterVisitor, and others). The high counts and the variety of roles (visitors, metamodel, AST node types, symbol solver, printers, observers) show ForStmt is highly connected in both directions, meeting the characteristics of Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.resolution.types.ResolvedUnionType",
        "detection": false,
        "justification": "ResolvedUnionType has a small set of relationships: 2 outgoing dependencies (com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration, com.github.javaparser.resolution.types.ResolvedType) and 2 incoming dependents (com.github.javaparser.ast.type.UnionType, com.github.javaparser.resolution.types.ResolvedType). Because both incoming and outgoing adjacency are limited (only two distinct other abstractions each), it does not exhibit Hub-like Modularization, which requires many incoming and outgoing dependencies to a large number of other abstractions."
    },
    {
        "identifier": "com.github.javaparser.serialization.JavaParserJsonSerializer.JsonToken",
        "detection": false,
        "justification": "The class has 0 outgoing dependencies and only 1 incoming dependency (from com.github.javaparser.serialization.JavaParserJsonSerializer). Hub-like Modularization requires an abstraction to have both many incoming and many outgoing relationships with other abstractions. Here the analyzed class lacks outgoing links and has a single incoming link, so it does not meet the hub-like criteria."
    },
    {
        "identifier": "com.github.javaparser.ast.nodeTypes.NodeWithName",
        "detection": false,
        "justification": "Hub-like Modularization requires an abstraction to have dependencies both incoming and outgoing with a large number of other abstractions. NodeWithName has 0 incoming dependencies and only 3 outgoing dependencies (com.github.javaparser.ast.expr.Name, com.github.javaparser.StaticJavaParser, com.github.javaparser.utils.Utils). Because there are no incoming dependencies and the outgoing set is small, it does not meet the hub-like criterion."
    },
    {
        "identifier": "com.github.javaparser.range.A",
        "detection": false,
        "justification": "Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies. This class has 0 incoming_dependencies and 0 outgoing_dependencies (both empty), so it does not exhibit hub-like modularization."
    },
    {
        "identifier": "com.github.javaparser.metamodel.UnaryExprMetaModel",
        "detection": false,
        "justification": "UnaryExprMetaModel has only 1 outgoing dependency (com.github.javaparser.metamodel.PropertyMetaModel) and only 2 incoming dependencies (com.github.javaparser.ast.expr.UnaryExpr and com.github.javaparser.metamodel.JavaParserMetaModel). These small numbers of incoming/outgoing relationships do not constitute a hub-like modularization (which requires dependencies with a large number of other abstractions)."
    },
    {
        "identifier": "com.github.javaparser.printer.lexicalpreservation.ReshuffledDiffElementExtractor.MatchClassification",
        "detection": false,
        "justification": "Class has 0 outgoing dependencies and only 1 incoming dependency (from com.github.javaparser.printer.lexicalpreservation.ReshuffledDiffElementExtractor). Hub-like modularization requires an abstraction to have many incoming and outgoing dependencies; this class does not meet that criterion."
    },
    {
        "identifier": "com.github.javaparser.ast.validator.Validator",
        "detection": false,
        "justification": "Validator has high incoming coupling but low outgoing coupling: 15 incoming dependents (e.g. com.github.javaparser.ast.validator.TreeVisitorValidator, com.github.javaparser.ast.validator.Validators, many language_level_validations such as Java1_2Validator, Java22Validator, Java17Validator, Java9Validator, and configuration classes com.github.javaparser.ParserConfiguration and com.github.javaparser.ParserConfiguration.LanguageLevel) but only 2 direct outgoing dependencies (com.github.javaparser.ast.validator.ProblemReporter and com.github.javaparser.ast.Node). Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; Validator has many incoming but only a small number of outgoing dependencies, so it is not a hub."
    },
    {
        "identifier": "com.github.javaparser.ast.stmt.BlockStmt",
        "detection": true,
        "justification": "BlockStmt has a broad set of outgoing dependencies (e.g. com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.Range, com.github.javaparser.ast.NodeList, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.TokenRange, com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.ast.Node, com.github.javaparser.metamodel.BlockStmtMetaModel, com.github.javaparser.ast.visitor.GenericVisitor) and a very large number of incoming dependents spanning many subsystems. Examples of incoming dependents include parser and facade classes (com.github.javaparser.JavaParser, com.github.javaparser.StaticJavaParser, com.github.javaparser.GeneratedJavaParser), numerous visitor implementations (VoidVisitor, GenericVisitor, HashCodeVisitor, EqualsVisitor, ModifierVisitor, various *VisitorAdapter classes), printers (PrettyPrintVisitor, DefaultPrettyPrinterVisitor), type/resolution logic (TypeExtractor, ControlFlowLogic, ExpressionCompatibleWithType), generator components (multiple *Generator classes), and many AST node types and node-type utilities (MethodDeclaration, ConstructorDeclaration, FieldDeclaration, TryStmt, CatchClause, ForEachStmt, Statement, NodeWithMembers, NodeWithBody, etc.). This combination of dozens of incoming dependencies together with multiple outgoing links shows BlockStmt acts as a central hub between many abstractions, matching the Hub-like Modularization smell."
    },
    {
        "identifier": "com.github.javaparser.ast.body.ClassOrInterfaceDeclaration",
        "detection": true,
        "justification": "The class participates in a large number of incoming and outgoing dependencies. Incoming: 52 distinct classes depend on ClassOrInterfaceDeclaration (examples: many visitor and utility classes such as com.github.javaparser.ast.visitor.VoidVisitor, GenericVisitor, HashCodeVisitor, EqualsVisitor, PrettyPrintVisitor; generator and metamodel classes such as com.github.javaparser.generator.metamodel.MetaModelGenerator, NodeMetaModelGenerator, VisitorGenerator; symbol-solver related classes such as com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade and com.github.javaparser.symbolsolver.SourceFileInfoExtractor). Outgoing: ClassOrInterfaceDeclaration depends on 12 other abstractions (examples: com.github.javaparser.ast.Node, com.github.javaparser.ast.NodeList, com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.ast.expr.SimpleName, com.github.javaparser.ast.comments.JavadocComment, com.github.javaparser.TokenRange, com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration, com.github.javaparser.metamodel.ClassOrInterfaceDeclarationMetaModel, com.github.javaparser.Range). The combination of a very large number of incoming dependents (52) together with multiple outgoing dependencies to core/metamodel/visitor types indicates a hub-like modularization smell."
    },
    {
        "identifier": "com.github.javaparser.ast.Modifier",
        "detection": true,
        "justification": "Modifier has a large number of incoming and several outgoing dependencies. Outgoing dependencies (9): com.github.javaparser.ast.AccessSpecifier, com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.NodeList, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.TokenRange, com.github.javaparser.ast.Modifier.Keyword, com.github.javaparser.metamodel.ModifierMetaModel, com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.ast.visitor.GenericVisitor. Incoming dependencies are numerous (37) from diverse classes across visitors, AST nodes, printers and validators (examples: com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.ast.visitor.ModifierVisitor, com.github.javaparser.ast.CompilationUnit, com.github.javaparser.ast.body.MethodDeclaration, com.github.javaparser.printer.PrettyPrintVisitor, com.github.javaparser.printer.DefaultPrettyPrinterVisitor, com.github.javaparser.printer.lexicalpreservation.LexicalPreservingPrinter, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.GeneratedJavaParser). The combination of many incoming references (37 distinct clients) and multiple outgoing dependencies indicates Modifier functions as a hub-like abstraction."
    },
    {
        "identifier": "com.github.javaparser.printer.concretesyntaxmodel.PrintingHelper",
        "detection": false,
        "justification": "PrintingHelper has 0 outgoing dependencies (empty outgoing_dependencies) and only 2 incoming dependencies (from com.github.javaparser.printer.concretesyntaxmodel.CsmAttribute and com.github.javaparser.printer.concretesyntaxmodel.CsmList). Both incoming entries list PrintingHelper among a small set of dependencies, so the class does not exhibit the high number of both incoming and outgoing connections required for Hub-like Modularization (incoming=2, outgoing=0)."
    },
    {
        "identifier": "com.github.javaparser.metamodel.ContinueStmtMetaModel",
        "detection": false,
        "justification": "ContinueStmtMetaModel has a small number of relationships: only 1 outgoing dependency (com.github.javaparser.metamodel.PropertyMetaModel) and only 2 incoming dependents (com.github.javaparser.ast.stmt.ContinueStmt and com.github.javaparser.metamodel.JavaParserMetaModel). Although JavaParserMetaModel itself references many meta-model classes, ContinueStmtMetaModel does not have many incoming and outgoing dependencies itself, so it does not exhibit Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.SimpleCharStream",
        "detection": false,
        "justification": "SimpleCharStream has only 1 outgoing dependency (com.github.javaparser.Provider) and 2 incoming dependents (com.github.javaparser.GeneratedJavaParser and com.github.javaparser.GeneratedJavaParserTokenManager). Hub-like Modularization requires an abstraction to have dependencies (both incoming and outgoing) with a large number of other abstractions; the provided data shows low outgoing degree (1) and only two incoming classes, so it does not meet the 'hub-like' criteria."
    },
    {
        "identifier": "com.github.javaparser.printer.lexicalpreservation.LookaheadIterator",
        "detection": false,
        "justification": "The class has 0 incoming dependencies and 0 outgoing dependencies. Hub-like Modularization requires an abstraction to have many incoming and outgoing dependencies; since this class has none, it is not a hub."
    },
    {
        "identifier": "com.github.javaparser.ast.validator.RecordAsTypeIdentifierNotAllowed",
        "detection": false,
        "justification": "The class has outgoing dependencies to 4 abstractions (com.github.javaparser.ast.expr.Name, com.github.javaparser.ast.validator.ProblemReporter, com.github.javaparser.ast.Node, com.github.javaparser.ast.expr.SimpleName) but has 0 incoming dependencies. Hub-like Modularization requires an abstraction to have many incoming and outgoing dependencies. Since there are no incoming dependencies (incoming_dependencies is empty) and only a small number of outgoing dependencies, this class does not exhibit the Hub-like Modularization smell."
    },
    {
        "identifier": "com.github.javaparser.javasymbolsolver.javassist_symbols.main_jar.ConcreteClass",
        "detection": false,
        "justification": "ConcreteClass has 0 incoming dependencies and 0 outgoing dependencies (both dependency lists are empty). Because it has no incoming or outgoing connections to other abstractions, it does not exhibit hub-like modularization."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.resolution.typeinference.Substitution",
        "detection": false,
        "justification": "Substitution has a small number of connections: 2 outgoing dependencies (com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration, com.github.javaparser.resolution.types.ResolvedType) and 2 incoming dependents (com.github.javaparser.symbolsolver.resolution.typeinference.TypeInference, com.github.javaparser.symbolsolver.resolution.typeinference.BoundSet). Because both incoming and outgoing dependency counts are low, it does not exhibit Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.resolution.declarations.ResolvedAnnotationDeclaration",
        "detection": false,
        "justification": "ResolvedAnnotationDeclaration has 0 outgoing dependencies (no listed outgoing_dependencies) but has multiple incoming dependencies (5): com.github.javaparser.symbolsolver.JavaSymbolSolver, com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade, com.github.javaparser.ast.body.AnnotationDeclaration, com.github.javaparser.ast.expr.AnnotationExpr, com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration. Hub-like Modularization requires an abstraction to have dependencies both incoming and outgoing with a large number of other abstractions; since this class has no outgoing dependencies, it does not meet the criterion for a hub."
    },
    {
        "identifier": "com.github.javaparser.ast.nodeTypes.NodeWithVariables.Helper",
        "detection": false,
        "justification": "Not detected: the class has 0 outgoing dependencies and only 1 incoming dependency (from com.github.javaparser.ast.nodeTypes.NodeWithVariables). A hub-like modularization would require dependencies (incoming and outgoing) with a large number of other abstractions; this class shows low connectivity."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javassistmodel.JavassistTypeDeclarationAdapter",
        "detection": true,
        "justification": "The class has numerous outgoing and incoming relationships indicative of a hub. Outgoing dependencies (6): com.github.javaparser.resolution.types.ResolvedType, com.github.javaparser.resolution.TypeSolver, com.github.javaparser.resolution.model.typesystem.ReferenceTypeImpl, com.github.javaparser.symbolsolver.javassistmodel.JavassistFactory, com.github.javaparser.symbolsolver.javassistmodel.JavassistUtils, com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration. Incoming dependencies from multiple other abstractions (5): com.github.javaparser.symbolsolver.javassistmodel.JavassistEnumDeclaration, JavassistInterfaceDeclaration, JavassistRecordDeclaration, JavassistClassDeclaration, JavassistAnnotationDeclaration. The class both depends on many core resolution types and utility/factory classes and is referenced by many different declaration classes, matching the Hub-like Modularization smell."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.reflectionmodel.ReflectionMethodDeclaration",
        "detection": true,
        "justification": "ReflectionMethodDeclaration has a high number of outgoing dependencies (10) spanning many different abstractions and packages — e.g. Context, MethodUsage, AccessSpecifier, ResolvedParameterDeclaration, ResolvedType, AbstractTypeDeclaration, TypeSolver, TypeUtils, ReflectionFactory, ResolvedReferenceTypeDeclaration — indicating broad coupling outward. It is also referenced by multiple other components (4 distinct incoming classes: ReflectionClassDeclaration, ReflectionRecordDeclaration, ReflectionTypeParameter, ReflectionMethodResolutionLogic) that rely on it. The combination of substantial fan-out across diverse subsystems and multiple fan-in callers shows it functions as a central hub-like abstraction."
    },
    {
        "identifier": "com.github.javaparser.generator.core.utils.CodeUtils",
        "detection": false,
        "justification": "CodeUtils has only one direct outgoing dependency (com.github.javaparser.ast.type.Type) and only one incoming dependency (com.github.javaparser.generator.core.node.PropertyGenerator). Although the Type class shows many dependencies, those are indirect/transitive from CodeUtils. The provided data shows CodeUtils does not have a large number of distinct incoming and outgoing direct relationships required to classify it as Hub-like Modularization."
    },
    {
        "identifier": "bar.A",
        "detection": false,
        "justification": "The class has no incoming or outgoing dependencies: incoming_dependencies = 0, outgoing_dependencies = 0 (analyzed_package.dependencies = []). Therefore it does not have dependencies with a large number of other abstractions and is not a hub-like modularization."
    },
    {
        "identifier": "com.github.javaparser.ast.expr.ObjectCreationExpr",
        "detection": true,
        "justification": "ObjectCreationExpr has a large number of incoming and outgoing dependencies. Incoming: 28 distinct other abstractions reference it (examples include com.github.javaparser.symbolsolver.javaparsermodel.DefaultVisitorAdapter, com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade, com.github.javaparser.symbolsolver.javaparsermodel.TypeExtractor, various ast.visitor classes such as VoidVisitor, GenericVisitor, ModifierVisitor, many visitor/adapters, printers like PrettyPrintVisitor and DefaultPrettyPrinterVisitor, and parser/runtime classes like GeneratedJavaParser). Outgoing: it depends on 15 distinct abstractions (examples include com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.body.BodyDeclaration, com.github.javaparser.Range, com.github.javaparser.ast.expr.Expression, com.github.javaparser.NodeList, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.TokenRange, com.github.javaparser.ast.Node, com.github.javaparser.ast.type.Type, com.github.javaparser.resolution.declarations.ResolvedConstructorDeclaration, and ObjectCreationExprMetaModel). The presence of many incoming references from diverse visitors, symbol-solver contexts and printers combined with many outgoing references to core AST, type, token and meta-model classes indicates a hub-like abstraction interacting with a large number of other abstractions."
    },
    {
        "identifier": "issue1945.main.MainIssue1945",
        "detection": false,
        "justification": "MainIssue1945 has outgoing dependencies to three abstractions (issue1945.interfaces.HairyAnimal, issue1945.interfaces.HairTypeRenderer, issue1945.interfaces.HairType) but has no incoming dependencies (incoming_dependencies is empty). Hub-like Modularization requires an abstraction to have both many incoming and outgoing dependencies; since there are no incoming dependencies, the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.StreamProvider",
        "detection": false,
        "justification": "No incoming or outgoing dependencies reported (incoming_dependencies = 0, outgoing_dependencies = 0). Hub-like Modularization requires an abstraction to have dependencies with a large number of other abstractions; StreamProvider has none, so it is not a hub."
    },
    {
        "identifier": "com.packageName.InnerStaticClassFieldContainer.InnerClass",
        "detection": false,
        "justification": "Hub-like Modularization requires an abstraction to have numerous incoming and outgoing dependencies. This class has 0 incoming dependencies and 0 outgoing dependencies (both dependency lists are empty), so it does not exhibit hub-like modularization."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver",
        "detection": false,
        "justification": "ReflectionTypeSolver has a small number of direct incoming and outgoing relationships: incoming from 2 classes (com.github.javaparser.symbolsolver.resolution.typesolvers.TypeSolverBuilder, com.github.javaparser.symbolsolver.resolution.typeinference.constraintformulas.TypeCompatibleWithType) and outgoing to 2 classes (com.github.javaparser.symbolsolver.utils.ModuleLayerHelper, com.github.javaparser.symbolsolver.reflectionmodel.ReflectionFactory). There is no evidence in the provided data of many distinct incoming or outgoing abstractions directly coupled to ReflectionTypeSolver (the many types listed are dependencies of ReflectionFactory, not direct dependencies of ReflectionTypeSolver). Therefore it does not exhibit Hub-like Modularization."
    },
    {
        "identifier": "issue1945.implementations.Sheep",
        "detection": false,
        "justification": "Incoming dependencies: 0; Outgoing dependencies: 0. Hub-like Modularization requires an abstraction to have dependencies (both incoming and outgoing) with a large number of other abstractions. With zero incoming and zero outgoing dependencies, Sheep does not exhibit hub-like modularization."
    },
    {
        "identifier": "com.github.javaparser.metamodel.UnparsableStmtMetaModel",
        "detection": false,
        "justification": "UnparsableStmtMetaModel has no outgoing dependencies (outgoing_dependencies = []). It does have incoming dependencies from com.github.javaparser.ast.stmt.UnparsableStmt and from com.github.javaparser.metamodel.JavaParserMetaModel (the latter references a very large set of meta-model classes including UnparsableStmtMetaModel). Hub-like Modularization requires an abstraction to have many incoming AND many outgoing dependencies; since this class has zero outgoing dependencies, it does not qualify as hub-like."
    },
    {
        "identifier": "com.github.javaparser.printer.configuration.PrettyPrinterConfiguration",
        "detection": false,
        "justification": "PrettyPrinterConfiguration has a small, focused set of outgoing dependencies (4): DefaultPrinterConfiguration, PrinterConfiguration, Indentation, ConfigurationOption. It has a small number of incoming dependents (3): com.github.javaparser.printer.PrettyPrintVisitor, com.github.javaparser.printer.SourcePrinter, com.github.javaparser.printer.PrettyPrinter. Both the incoming and outgoing dependencies are limited in number and confined to related printing/configuration abstractions rather than a large number of diverse classes, so it does not meet the criteria for Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.metamodel.ArrayInitializerExprMetaModel",
        "detection": false,
        "justification": "Not hub-like: the class has a single outgoing dependency (com.github.javaparser.metamodel.PropertyMetaModel) and only two incoming dependents in the provided data (com.github.javaparser.ast.expr.ArrayInitializerExpr and com.github.javaparser.metamodel.JavaParserMetaModel). Hub-like modularization requires many incoming and many outgoing dependencies; here outgoing_count = 1 and incoming_count = 2, so the class does not exhibit a hub-like coupling pattern."
    },
    {
        "identifier": "com.github.javaparser.JavaToken.Category",
        "detection": false,
        "justification": "Hub-like Modularization not detected: the class has 0 outgoing dependencies and only 1 incoming dependency (from com.github.javaparser.JavaToken). The smell requires an abstraction to have dependencies both incoming and outgoing with a large number of other abstractions; here there is neither many incoming references nor any outgoing dependencies."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassAdapter",
        "detection": true,
        "justification": "ReflectionClassAdapter has a substantial number of outgoing dependencies (7 distinct abstractions: com.github.javaparser.resolution.types.ResolvedType; com.github.javaparser.resolution.declarations.ResolvedFieldDeclaration; com.github.javaparser.resolution.TypeSolver; com.github.javaparser.symbolsolver.reflectionmodel.ReflectionFieldDeclaration; com.github.javaparser.resolution.model.typesystem.ReferenceTypeImpl; com.github.javaparser.symbolsolver.reflectionmodel.ReflectionFactory; com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration) and is the target of many incoming dependencies (5 distinct classes depend on it: ReflectionClassDeclaration; ReflectionAnnotationDeclaration; ReflectionEnumDeclaration; ReflectionRecordDeclaration; ReflectionInterfaceDeclaration). These incoming callers themselves reference numerous other abstractions (e.g., Context, MethodUsage, ResolvedFieldDeclaration, TypeSolver, ResolvedReferenceTypeDeclaration, inference and resolution logic types), indicating ReflectionClassAdapter sits at a central connection point between multiple packages and concepts. The combination of multiple incoming dependents and multiple outgoing dependencies across packages fits the Hub-like Modularization smell."
    },
    {
        "identifier": "com.github.javaparser.ast.nodeTypes.modifiers.NodeWithAbstractModifier",
        "detection": false,
        "justification": "The class has 0 incoming dependencies and 0 outgoing dependencies (incoming_dependencies=[]; outgoing_dependencies=[]), so it does not interact with a large number of other abstractions and therefore is not a hub."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.declarations.DefaultConstructorDeclaration",
        "detection": false,
        "justification": "Not detected: the class has 0 incoming dependencies and only 3 direct outgoing dependencies (com.github.javaparser.ast.AccessSpecifier, com.github.javaparser.resolution.declarations.ResolvedParameterDeclaration, com.github.javaparser.resolution.types.ResolvedType). Hub-like Modularization requires an abstraction to have many incoming and outgoing connections. Although one outgoing dependency (ResolvedType) itself references many types, DefaultConstructorDeclaration does not have the large number of incoming/outgoing relationships required for the smell."
    },
    {
        "identifier": "com.github.javaparser.ast.validator.language_level_validations.UpgradeJavaMessage",
        "detection": false,
        "justification": "UpgradeJavaMessage has only 1 outgoing dependency (com.github.javaparser.ParserConfiguration) and 1 incoming dependency (com.github.javaparser.ast.validator.ProblemReporter). Hub-like Modularization requires an abstraction to have many incoming and outgoing connections; the provided data shows a single incoming and a single outgoing relation, so it does not qualify as hub-like."
    },
    {
        "identifier": "(default package).Foo",
        "detection": false,
        "justification": "The class has 0 incoming dependencies and 0 outgoing dependencies. Hub-like Modularization requires many incoming and outgoing connections to other abstractions, which is not present here."
    },
    {
        "identifier": "com.github.javaparser.ast.validator.language_level_validations.Java6Validator",
        "detection": false,
        "justification": "The class has 0 outgoing dependencies and 0 incoming dependencies (outgoing_dependencies: [], incoming_dependencies: []). Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; this class has none."
    },
    {
        "identifier": "japa.bdd.samples.JavaConcepts.QWE",
        "detection": false,
        "justification": "Not a hub: the class has 0 outgoing dependencies (outgoing_dependencies = []) and only 1 incoming dependency (from japa.bdd.samples.JavaConcepts). The incoming entry lists dependencies [\"com.github.javaparser.ast.CompilationUnit\", \"japa.bdd.samples.JavaConcepts.A\", \"japa.bdd.samples.JavaConcepts.QWE\"], but there is only a single distinct incoming class referencing QWE. Hub-like Modularization requires a large number of both incoming and outgoing relationships; here incoming_count=1 and outgoing_count=0."
    },
    {
        "identifier": "com.github.javaparser.javadoc.JavadocBlockTag.Type",
        "detection": false,
        "justification": "The class has 0 outgoing dependencies and only 1 incoming dependency (from com.github.javaparser.javadoc.JavadocBlockTag). Hub-like Modularization requires an abstraction to have many incoming and outgoing dependencies; these counts are low, so the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.ast.stmt.IfStmt",
        "detection": false,
        "justification": "Incoming dependencies are numerous (24 distinct incoming classes depend on IfStmt — e.g. com.github.javaparser.symbolsolver.javaparsermodel.DefaultVisitorAdapter, com.github.javaparser.symbolsolver.javaparsermodel.NormalCompletionVisitor, com.github.javaparser.printer.PrettyPrintVisitor, com.github.javaparser.GeneratedJavaParser, com.github.javaparser.ast.visitor.EqualsVisitor, com.github.javaparser.ast.stmt.Statement). However, outgoing dependencies from IfStmt are modest (10 distinct outgoing dependencies: com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.stmt.Statement, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.ast.expr.Expression, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.TokenRange, com.github.javaparser.metamodel.IfStmtMetaModel, com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.ast.Node, com.github.javaparser.Range). The Hub-like Modularization smell requires an abstraction to have dependencies with a large number of other abstractions in both directions (high fan-in and high fan-out). While IfStmt has high fan-in, its fan-out is not comparably large, so it does not meet the criteria for Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.printer.lexicalpreservation.TextElementMatcher",
        "detection": false,
        "justification": "TextElementMatcher has 1 outgoing dependency (com.github.javaparser.printer.lexicalpreservation.TextElement) and is referenced by 3 incoming classes (NodeText, TextElement, TextElementMatchers). There are 3 distinct other abstractions interacting with this class. This is a small number of both incoming and outgoing relationships, so it does not constitute a hub-like modularization."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.cache.GuavaCache",
        "detection": false,
        "justification": "GuavaCache has 1 outgoing dependency (com.github.javaparser.resolution.cache.CacheStats) and 0 incoming dependencies. Hub-like Modularization requires an abstraction to have many incoming and outgoing dependencies; this class does not meet that criterion."
    },
    {
        "identifier": "(default package).B",
        "detection": false,
        "justification": "B has outgoing dependencies to (default package).A and com.github.javaparser.quality.Preconditions (2 distinct outgoing abstractions) and a single incoming dependency from (default package).ConstantA (1 incoming). Hub-like Modularization requires an abstraction to have many incoming and outgoing dependencies; the counts here are low and do not justify labeling B as a hub."
    },
    {
        "identifier": "com.github.javaparser.ast.validator.postprocessors.Java16PostProcessor",
        "detection": false,
        "justification": "The class has no incoming or outgoing relationships: analyzed_package.dependencies = [], outgoing_dependencies = [], incoming_dependencies = []. Hub-like Modularization requires many incoming and outgoing dependencies, which are absent here."
    },
    {
        "identifier": "com.github.javaparser.generator.metamodel.NodeMetaModelGenerator",
        "detection": false,
        "justification": "NodeMetaModelGenerator has many outgoing dependencies (14 distinct abstractions: com.github.javaparser.StaticJavaParser, com.github.javaparser.utils.CodeGenerationUtils, com.github.javaparser.generator.metamodel.InitializePropertyMetaModelsStatementsGenerator, com.github.javaparser.generator.metamodel.MetaModelGenerator, com.github.javaparser.utils.Utils, com.github.javaparser.ast.body.ConstructorDeclaration, com.github.javaparser.ast.body.BodyDeclaration, com.github.javaparser.ast.body.ClassOrInterfaceDeclaration, com.github.javaparser.generator.metamodel.InitializeConstructorParametersStatementsGenerator, com.github.javaparser.ast.CompilationUnit, com.github.javaparser.generator.metamodel.AstTypeAnalysis, com.github.javaparser.ast.NodeList, com.github.javaparser.ast.body.FieldDeclaration, com.github.javaparser.utils.SourceRoot) but only a single incoming dependency (from com.github.javaparser.generator.metamodel.MetaModelGenerator). Hub-like modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; here the incoming degree is low (1) while the outgoing degree is high, so the class does not meet the definition of a hub (both-sided high connectivity) and the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.ast.visitor.NodeFinderVisitor",
        "detection": false,
        "justification": "NodeFinderVisitor has numerous outgoing dependencies on many AST node types and utility classes (examples: com.github.javaparser.ast.Node, com.github.javaparser.ast.CompilationUnit, com.github.javaparser.Range, com.github.javaparser.ast.expr.MethodCallExpr, com.github.javaparser.ast.stmt.IfStmt, com.github.javaparser.ast.expr.LambdaExpr, com.github.javaparser.ast.body.MethodDeclaration, among many others), but it has no incoming dependencies (incoming_dependencies is empty). The Hub-like Modularization smell requires an abstraction to have a large number of both incoming and outgoing dependencies; because there are zero incoming dependencies, this class does not meet the definition of a hub."
    },
    {
        "identifier": "com.github.javaparser.ast.expr.SuperExpr",
        "detection": true,
        "justification": "SuperExpr has a substantial number of both incoming and outgoing dependencies. Outgoing dependencies (10) include: com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.expr.Name, com.github.javaparser.Range, com.github.javaparser.ast.expr.Expression, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.TokenRange, com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.ast.Node, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.metamodel.SuperExprMetaModel. Incoming dependencies (22) come from many distinct abstractions — notably numerous visitor and analysis classes such as com.github.javaparser.symbolsolver.javaparsermodel.DefaultVisitorAdapter, TypeExtractor, com.github.javaparser.ast.visitor.VoidVisitor, HashCodeVisitor, EqualsVisitor, ModifierVisitor, CloneVisitor, NodeFinderVisitor, com.github.javaparser.GeneratedJavaParser, com.github.javaparser.printer.PrettyPrintVisitor, and others. The presence of many diverse incoming references (multiple visitors, printers, parsers, and symbol-solver components) combined with multiple outgoing ties to core AST, metadata and token types indicates a hub-like role; therefore this class exhibits the Hub-like Modularization smell."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.contexts.CompilationUnitContext",
        "detection": false,
        "justification": "Hub-like Modularization requires the abstraction to have many incoming and many outgoing dependencies. CompilationUnitContext has 12 outgoing dependencies (SymbolReference, Name, JavaParserFacade, MethodDeclaration, TypeSolver, SymbolSolver, ResolvedTypeDeclaration, Node, ResolvedReferenceTypeDeclaration, CompilationUnit, ClassOrInterfaceType, MethodResolutionLogic) but zero incoming dependencies. Because there are no incoming dependencies in the provided data, the class does not meet the 'both incoming and outgoing with a large number of other abstractions' criterion and therefore is not a hub."
    },
    {
        "identifier": "com.github.javaparser.ParseStart",
        "detection": false,
        "justification": "ParseStart has a small number of direct connections: 2 outgoing dependencies (com.github.javaparser.ParseException, com.github.javaparser.GeneratedJavaParser) and 3 incoming dependencies (com.github.javaparser.ast.CompilationUnit, com.github.javaparser.ast.CompilationUnit.Storage, com.github.javaparser.JavaParser). Although GeneratedJavaParser itself lists many internal dependencies, ParseStart directly depends only on GeneratedJavaParser and ParseException, and is referenced by only three classes — these counts do not constitute a large number of both incoming and outgoing dependencies required to qualify as Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.ast.validator.language_level_validations.chunks.ModifierValidator",
        "detection": false,
        "justification": "Hub-like Modularization requires an abstraction to have many both incoming and outgoing dependencies. ModifierValidator has many outgoing dependencies (15 distinct outgoing dependencies: com.github.javaparser.ast.body.TypeDeclaration, com.github.javaparser.ast.body.AnnotationDeclaration, com.github.javaparser.ast.body.AnnotationMemberDeclaration, com.github.javaparser.ast.modules.ModuleRequiresDirective, com.github.javaparser.ast.body.MethodDeclaration, com.github.javaparser.ast.validator.ProblemReporter, com.github.javaparser.ast.body.ClassOrInterfaceDeclaration, com.github.javaparser.ast.body.ConstructorDeclaration, com.github.javaparser.ast.Modifier, com.github.javaparser.utils.SeparatedItemStringBuilder, com.github.javaparser.ast.body.EnumDeclaration, com.github.javaparser.ast.expr.VariableDeclarationExpr, com.github.javaparser.ast.expr.LambdaExpr, com.github.javaparser.ast.stmt.CatchClause, com.github.javaparser.ast.body.FieldDeclaration) but has zero incoming dependencies (incoming_dependencies is empty). Because it lacks incoming links, it does not meet the definition of a hub (requires many incoming and outgoing dependencies)."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.NormalCompletionVisitor",
        "detection": false,
        "justification": "Outgoing dependencies: NormalCompletionVisitor depends on a large set of distinct abstractions (20) including many AST statement types and core AST/resolution types (e.g. com.github.javaparser.ast.stmt.ForStmt, ThrowStmt, YieldStmt, SynchronizedStmt, DoStmt, BlockStmt, LabeledStmt, ReturnStmt, IfStmt, ContinueStmt, TryStmt, BreakStmt, SwitchStmt, WhileStmt, Statement, com.github.javaparser.ast.Node, com.github.javaparser.ast.NodeList, com.github.javaparser.ast.stmt.SwitchEntry, com.github.javaparser.resolution.types.ResolvedType, com.github.javaparser.resolution.types.ResolvedReferenceType). Incoming dependencies: only 4 classes reference it (com.github.javaparser.symbolsolver.javaparsermodel.contexts.WhileStatementContext, IfStatementContext, ForStatementContext, DoStatementContext). The Hub-like Modularization smell requires an abstraction to have dependencies (both incoming and outgoing) with a large number of other abstractions. Because NormalCompletionVisitor has many outgoing but only a small number of incoming dependencies in the provided data, it does not meet the definition of a hub-like modularization."
    },
    {
        "identifier": "com.github.javaparser.ast.visitor.GenericVisitorWithDefaults",
        "detection": false,
        "justification": "The class has a large number of outgoing dependencies (104 distinct target abstractions, e.g. com.github.javaparser.ast.Node, com.github.javaparser.ast.CompilationUnit, com.github.javaparser.ast.body.MethodDeclaration, com.github.javaparser.ast.expr.MethodCallExpr), but there are no incoming dependencies in the provided data (incoming_dependencies is empty). Hub-like Modularization requires an abstraction to have both many incoming and many outgoing connections; here the incoming side is absent, so the smell is not detected."
    },
    {
        "identifier": "(default package).Issue2367",
        "detection": false,
        "justification": "The class has 0 incoming dependencies and 0 outgoing dependencies. Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; since both counts are zero, the smell is not present."
    },
    {
        "identifier": "com.github.javaparser.AbstractCharStream",
        "detection": false,
        "justification": "No incoming or outgoing dependencies: incoming_dependencies = 0 (empty), outgoing_dependencies = 0 (empty). Hub-like Modularization requires an abstraction to have many incoming and outgoing dependencies, which is not the case here."
    },
    {
        "identifier": "com.github.javaparser.printer.concretesyntaxmodel.CsmMix",
        "detection": false,
        "justification": "CsmMix has 2 outgoing dependencies (com.github.javaparser.printer.SourcePrinter, com.github.javaparser.ast.Node) and 4 incoming dependencies (com.github.javaparser.printer.lexicalpreservation.LexicalDifferenceCalculator, com.github.javaparser.printer.lexicalpreservation.LexicalPreservingPrinter, com.github.javaparser.printer.lexicalpreservation.ReshuffledDiffElementExtractor, com.github.javaparser.printer.lexicalpreservation.Reshuffled). The counts of both incoming and outgoing relationships are small and do not indicate an abstraction acting as a hub connected to a large number of other abstractions, so Hub-like Modularization is not detected."
    },
    {
        "identifier": "com.github.javaparser.UnicodeEscapeProcessingProvider.PositionMapping",
        "detection": false,
        "justification": "The class has 0 outgoing dependencies and only 1 incoming dependency (from com.github.javaparser.UnicodeEscapeProcessingProvider). Hub-like modularization requires many incoming and outgoing connections; this class does not exhibit a large number of dependencies in either direction."
    },
    {
        "identifier": "com.github.javaparser.metamodel.ModuleDeclarationMetaModel",
        "detection": false,
        "justification": "The class has only 1 outgoing dependency (com.github.javaparser.metamodel.PropertyMetaModel) and only 2 incoming dependencies (com.github.javaparser.ast.modules.ModuleDeclaration and com.github.javaparser.metamodel.JavaParserMetaModel). Hub-like Modularization requires an abstraction to have dependencies with a large number of other abstractions both incoming and outgoing. The provided data does not show a large number of incoming or outgoing connections for com.github.javaparser.metamodel.ModuleDeclarationMetaModel, so the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.generator.core.visitor.VoidVisitorWithDefaultsGenerator",
        "detection": false,
        "justification": "The class has outgoing dependencies to five other abstractions (com.github.javaparser.metamodel.BaseNodeMetaModel, com.github.javaparser.ast.stmt.BlockStmt, com.github.javaparser.ast.CompilationUnit, com.github.javaparser.ast.body.MethodDeclaration, com.github.javaparser.utils.SourceRoot) but has no incoming dependencies (incoming_dependencies is empty). Hub-like Modularization requires an abstraction to have many incoming AND outgoing connections; here incoming connections are absent, so the class is not a hub. Note: several of the outgoing dependencies themselves are highly connected, but that does not make the analyzed class a hub in isolation."
    },
    {
        "identifier": "com.github.javaparser.ast.validator.ReservedKeywordValidator",
        "detection": false,
        "justification": "ReservedKeywordValidator has no incoming dependencies and only three outgoing dependencies: com.github.javaparser.ast.expr.Name, com.github.javaparser.ast.validator.ProblemReporter, com.github.javaparser.ast.expr.SimpleName. Hub-like Modularization requires an abstraction to have many incoming and outgoing relationships; the provided data shows a limited set of outgoing links and zero incoming links, so this is not a hub."
    },
    {
        "identifier": "(default package).Extends",
        "detection": false,
        "justification": "Extends has 0 outgoing dependencies and only 1 incoming dependency (from (default package).Usage). Hub-like Modularization requires an abstraction to have dependencies with a large number of other abstractions (many incoming and outgoing links); with only one incoming and no outgoing dependencies, Extends does not meet that criterion."
    },
    {
        "identifier": "com.github.javaparser.ast.expr.MethodCallExpr",
        "detection": true,
        "justification": "MethodCallExpr has a large number of outgoing dependencies (15) to many core abstractions (examples: com.github.javaparser.ast.expr.Expression, com.github.javaparser.ast.Node, com.github.javaparser.ast.NodeList, com.github.javaparser.Range, com.github.javaparser.resolution.types.ResolvedType, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.ast.expr.NameExpr, com.github.javaparser.ast.expr.SimpleName, com.github.javaparser.TokenRange). It is also the target of numerous incoming dependencies from many distinct classes (31 distinct incoming clients) across the codebase, including many visitor/utility classes and symbol solver components (examples: multiple ast.visitor classes such as VoidVisitor, GenericVisitor, HashCodeVisitor, EqualsVisitor, PrettyPrintVisitor and symbolsolver classes such as JavaParserFacade, TypeExtractor, MethodCallExprContext, SourceFileInfoExtractor). The combination of many incoming and many outgoing ties to a wide set of unrelated abstractions indicates MethodCallExpr functions as a hub, satisfying the Hub-like Modularization smell."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javassistmodel.JavassistRecordDeclaration",
        "detection": false,
        "justification": "Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies. The provided data shows JavassistRecordDeclaration has many outgoing dependencies (11): Context, SymbolReference, AccessSpecifier, ResolvedType, TypeSolver, JavassistFactory, JavassistUtils, ResolvedReferenceTypeDeclaration, Node, ResolvedReferenceType, JavassistTypeDeclarationAdapter. However, it has zero incoming dependencies. Because incoming dependency count is 0, the class does not meet the definition (requires both incoming and outgoing connections) and therefore is not detected as a hub."
    },
    {
        "identifier": "com.github.javaparser.metamodel.ObjectCreationExprMetaModel",
        "detection": false,
        "justification": [
            "Outgoing dependencies: 1 — com.github.javaparser.metamodel.PropertyMetaModel.",
            "Incoming dependencies: 2 — com.github.javaparser.ast.expr.ObjectCreationExpr and com.github.javaparser.metamodel.JavaParserMetaModel.",
            "Hub-like Modularization requires an abstraction to have dependencies (both incoming and outgoing) with a large number of other abstractions; this class has low fan-in (2) and fan-out (1), so it is not hub-like."
        ]
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.contexts.SwitchEntryContext",
        "detection": false,
        "justification": "SwitchEntryContext has many outgoing dependencies (14 distinct dependencies including TypeSolver, Navigator, JavaParserFacade, ResolvedType, AbstractJavaParserContext, SwitchStmt, SwitchEntry, Node, JavaParserFactory, ReferenceTypeImpl, SymbolReference, ResolvedReferenceTypeDeclaration, SymbolDeclarator, SwitchNode) but zero incoming dependencies in the provided data. The Hub-like Modularization smell requires an abstraction to have numerous incoming and outgoing relationships; since there are no incoming dependencies, the class does not meet the hub-like criterion."
    },
    {
        "identifier": "com.github.javaparser.metamodel.IfStmtMetaModel",
        "detection": false,
        "justification": "IfStmtMetaModel has a small number of dependencies in the provided data: only 1 outgoing dependency (com.github.javaparser.metamodel.PropertyMetaModel) and 2 incoming dependents (com.github.javaparser.ast.stmt.IfStmt and com.github.javaparser.metamodel.JavaParserMetaModel). Hub-like Modularization requires an abstraction to have dependencies with a large number of other abstractions both incoming and outgoing. The metrics here show limited fan-out (1) and limited fan-in (2), so it does not meet the hub-like criterion. Note: although JavaParserMetaModel itself references many meta-model classes, that represents a single incoming dependency source rather than many distinct incoming dependents for IfStmtMetaModel."
    },
    {
        "identifier": "com.github.javaparser.ast.expr.MatchAllPatternExpr",
        "detection": true,
        "justification": "MatchAllPatternExpr has a large number of incoming dependencies from many distinct abstractions (examples: numerous visitor implementations and utilities such as com.github.javaparser.symbolsolver.javaparsermodel.DefaultVisitorAdapter, com.github.javaparser.ast.visitor.VoidVisitor, HashCodeVisitor, EqualsVisitor, CloneVisitor, ModifierVisitor, GenericVisitorAdapter, PrettyPrintVisitor, DefaultPrettyPrinterVisitor, GeneratedJavaParser, com.github.javaparser.ast.expr.Expression, etc. — ~19 distinct incoming dependents listed). It also has multiple outgoing dependencies to core/meta abstractions (com.github.javaparser.ast.Node, com.github.javaparser.ast.NodeList, com.github.javaparser.TokenRange, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.metamodel.MatchAllPatternExprMetaModel). The class therefore participates in many incoming and outgoing relationships with different modules/abstractions, matching the Hub-like Modularization smell."
    },
    {
        "identifier": "com.github.javaparser.printer.lexicalpreservation.changes.PropertyChange",
        "detection": false,
        "justification": "PropertyChange has only outgoing dependencies to 2 abstractions (com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.ast.Node) and has 0 incoming dependencies. Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; the provided data shows neither a large outgoing fan‑out nor any incoming dependencies, so the smell is not present."
    },
    {
        "identifier": "(default package).Y",
        "detection": false,
        "justification": "Class '(default package).Y' has 0 incoming dependencies and 0 outgoing dependencies. Hub-like Modularization requires an abstraction to have many incoming and outgoing relationships; since both counts are zero, the smell is not present."
    },
    {
        "identifier": "com.github.javaparser.ast.Modifier.Keyword",
        "detection": false,
        "justification": "Modifier.Keyword has 0 outgoing dependencies and only 1 incoming dependency (from com.github.javaparser.ast.Modifier). Hub-like Modularization requires an abstraction to have both many incoming and many outgoing dependencies; this class does not meet that criterion."
    },
    {
        "identifier": "com.github.javaparser.Position",
        "detection": false,
        "justification": "Position has many incoming dependencies (referenced by 6 other abstractions: com.github.javaparser.ast.CompilationUnit, com.github.javaparser.ast.Node, com.github.javaparser.Range, com.github.javaparser.utils.PositionUtils, com.github.javaparser.printer.SourcePrinter, com.github.javaparser.serialization.JavaParserJsonDeserializer) but only a single outgoing dependency (depends on com.github.javaparser.ast.Node). Hub-like modularization requires an abstraction to have both a large number of incoming and a large number of outgoing dependencies; Position lacks a large outgoing dependency set, so it is not a hub."
    },
    {
        "identifier": "com.github.javaparser.utils.LineSeparator",
        "detection": false,
        "justification": "LineSeparator has many incoming dependencies (19 distinct classes depend on it, e.g. com.github.javaparser.ast.Node, com.github.javaparser.ast.comments.MarkdownComment, com.github.javaparser.ParseResult, com.github.javaparser.JavadocParser, com.github.javaparser.JavaToken, com.github.javaparser.printer.lexicalpreservation.LexicalPreservingPrinter, com.github.javaparser.utils.Utils, com.github.javaparser.printer.configuration.DefaultPrinterConfiguration, com.github.javaparser.printer.concretesyntaxmodel.CsmElement, com.github.javaparser.printer.lexicalpreservation.LexicalDifferenceCalculator, com.github.javaparser.ParseProblemException, com.github.javaparser.Problem, com.github.javaparser.TokenTypes, com.github.javaparser.LineEndingProcessingProvider), but it has no outgoing dependencies (outgoing_dependencies = []). The definition of Hub-like Modularization requires an abstraction to have dependencies in both directions with a large number of other abstractions. Because LineSeparator has zero outgoing dependencies, it does not satisfy the 'both incoming and outgoing' requirement and therefore is not detected as Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.ast.stmt.YieldStmt",
        "detection": true,
        "justification": "YieldStmt has a high number of incoming dependencies (22 distinct clients in the input) including many visitor implementations (VoidVisitor, GenericVisitor, VoidVisitorAdapter, ModifierVisitor, HashCodeVisitor, EqualsVisitor, CloneVisitor, etc.), printer classes (PrettyPrintVisitor, DefaultPrettyPrinterVisitor), the generated parser (GeneratedJavaParser) and symbol-solver visitors (DefaultVisitorAdapter, NormalCompletionVisitor). It also has multiple outgoing dependencies (8) to core AST/meta types it uses (com.github.javaparser.ast.expr.Expression, com.github.javaparser.ast.Node, com.github.javaparser.TokenRange, com.github.javaparser.metamodel.JavaParserMetaModel, YieldStmtMetaModel, com.github.javaparser.ast.observer.ObservableProperty, and the visitor interfaces VoidVisitor and GenericVisitor). The combination of many distinct incoming clients plus several outgoing ties to core abstractions indicates YieldStmt acts as a hub-like abstraction."
    },
    {
        "identifier": "com.github.javaparser.metamodel.BlockStmtMetaModel",
        "detection": false,
        "justification": "BlockStmtMetaModel has only 1 outgoing dependency (com.github.javaparser.metamodel.PropertyMetaModel) and only 2 incoming dependents (com.github.javaparser.ast.stmt.BlockStmt and com.github.javaparser.metamodel.JavaParserMetaModel). The large number of dependencies listed for JavaParserMetaModel reflects that JavaParserMetaModel is a hub, but BlockStmtMetaModel itself does not have incoming and outgoing relationships with a large number of distinct abstractions, so it is not a hub-like modularization."
    },
    {
        "identifier": "com.github.javaparser.ast.observer.AstObserver",
        "detection": false,
        "justification": "AstObserver has 4 outgoing dependencies: com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.ast.Node, com.github.javaparser.ast.NodeList, com.github.javaparser.ast.observer.AstObserver.ListChangeType. It has 7 incoming dependencies from: com.github.javaparser.ast.NodeList, com.github.javaparser.ast.Node, com.github.javaparser.ast.observer.PropagatingAstObserver, com.github.javaparser.ast.observer.Observable, com.github.javaparser.printer.lexicalpreservation.LexicalPreservingPrinter, com.github.javaparser.printer.lexicalpreservation.LexicalPreservingPrinter.Observer, com.github.javaparser.printer.lexicalpreservation.PhantomNodeLogic. The outgoing dependency count is small and the incoming references are limited to closely related classes, so the class does not exhibit the extensive many-to-many incoming and outgoing connections characteristic of Hub-like Modularization."
    },
    {
        "identifier": "(default package).U9",
        "detection": false,
        "justification": "No incoming or outgoing dependencies: incoming_dependencies = [], outgoing_dependencies = []. With 0 incoming and 0 outgoing links, the class does not depend on or is depended on by a large number of other abstractions, so it is not a hub-like module."
    },
    {
        "identifier": "com.github.javaparser.generator.core.visitor.GenericListVisitorAdapterGenerator",
        "detection": false,
        "justification": "The class has no incoming dependencies (incoming_dependencies is empty) and only five outgoing dependencies (com.github.javaparser.metamodel.BaseNodeMetaModel, com.github.javaparser.ast.stmt.BlockStmt, com.github.javaparser.ast.CompilationUnit, com.github.javaparser.ast.body.MethodDeclaration, com.github.javaparser.utils.SourceRoot). Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing connections; this class lacks incoming connections and its outgoing degree is small, so the smell is not present."
    },
    {
        "identifier": "com.github.javaparser.ast.expr.MarkerAnnotationExpr",
        "detection": true,
        "justification": "MarkerAnnotationExpr has a large number of incoming and outgoing relationships: 22 incoming dependencies (examples: com.github.javaparser.symbolsolver.javaparsermodel.DefaultVisitorAdapter, com.github.javaparser.ast.nodeTypes.NodeWithAnnotations, many visitor classes such as VoidVisitor, GenericVisitor, ModifierVisitor, EqualsVisitor, CloneVisitor, PrettyPrintVisitor, GeneratedJavaParser, etc.) and 9 outgoing dependencies (examples: com.github.javaparser.ast.expr.NameExpr, com.github.javaparser.ast.expr.Name, com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.metamodel.MarkerAnnotationExprMetaModel, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.TokenRange, com.github.javaparser.StaticJavaParser, com.github.javaparser.Range). The high number of distinct incoming callers (many visitor/parser classes) combined with multiple outgoing links to core parsing/meta-model utilities indicates a hub-like role, satisfying the Hub-like Modularization smell criteria."
    },
    {
        "identifier": "com.github.javaparser.CharStream",
        "detection": false,
        "justification": "The class has 0 incoming dependencies and 0 outgoing dependencies (both incoming_dependencies and outgoing_dependencies are empty). Hub-like Modularization requires an abstraction to have dependencies with a large number of other abstractions; with no incoming or outgoing links, this class is not a hub."
    },
    {
        "identifier": "com.github.javaparser.ast.validator.language_level_validations.Java10PreviewValidator",
        "detection": false,
        "justification": "Incoming dependencies: 0 (incoming_dependencies = []). Outgoing dependencies: 0 (outgoing_dependencies = []). Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; this class has none, so it is not a hub."
    },
    {
        "identifier": "com.github.javaparser.javadoc.description.JavadocSnippet",
        "detection": false,
        "justification": "The class has 0 outgoing dependencies and 0 incoming dependencies (both dependency lists are empty). Because it has no incoming or outgoing ties to many other abstractions, it does not exhibit hub-like modularization."
    },
    {
        "identifier": "com.github.javaparser.ast.stmt.SwitchStmt",
        "detection": true,
        "justification": "SwitchStmt has many outgoing dependencies (11) including com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.metamodel.SwitchStmtMetaModel, com.github.javaparser.Range, com.github.javaparser.ast.expr.Expression, com.github.javaparser.ast.NodeList, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.TokenRange, com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.ast.Node, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.ast.stmt.SwitchEntry, and many incoming dependencies (26) from numerous visitors, printers, generators and context classes (e.g. DefaultVisitorAdapter, NormalCompletionVisitor, SwitchEntryContext, Statement, VoidVisitor, HashCodeVisitor, PrettyPrintVisitor, GeneratedJavaParser, Navigator, AbstractGenerator, TokenKindGenerator). The class therefore has both a large number of incoming and outgoing links to diverse abstractions, matching the Hub-like Modularization smell."
    },
    {
        "identifier": "com.github.javaparser.ast.expr.ArrayInitializerExpr",
        "detection": true,
        "justification": "ArrayInitializerExpr shows hub-like modularization: it has a large number of incoming dependencies (26 distinct classes reference it) — many visitor implementations and utilities (e.g. VoidVisitor, GenericVisitor, HashCodeVisitor, EqualsVisitor, ModifierVisitor, CloneVisitor, PrettyPrintVisitor, DefaultPrettyPrinterVisitor, VoidVisitorAdapter, GenericVisitorAdapter, GenericVisitorWithDefaults, VoidVisitorWithDefaults, NodeFinderVisitor) and parser components (GeneratedJavaParser, GeneratedJavaParserBase, StaticJavaParser, JavaParserAdapter), plus AST classes (Expression, ArrayCreationExpr). It also has multiple outgoing dependencies (9) to core abstractions such as Node, NodeList, JavaParserMetaModel, ArrayInitializerExprMetaModel, VoidVisitor, GenericVisitor, Range, TokenRange and ObservableProperty. The combination of high fan-in (many incoming clients) and non-trivial fan-out (multiple dependencies) indicates ArrayInitializerExpr acts as a hub connecting many other abstractions."
    },
    {
        "identifier": "japa.bdd.samples.XXX",
        "detection": false,
        "justification": "Not detected: analyzed_package.dependencies is empty, incoming_dependencies is an empty list (0 incoming), and outgoing_dependencies is an empty list (0 outgoing); the class has no large number of incoming or outgoing dependencies."
    },
    {
        "identifier": "com.github.javaparser.ast.stmt.SynchronizedStmt",
        "detection": true,
        "justification": "SynchronizedStmt has many incoming dependents (22 distinct classes reference it) and multiple outgoing dependencies (10 distinct abstractions it depends on). Incoming dependents include numerous visitor and utility classes (e.g., com.github.javaparser.ast.visitor.VoidVisitor, GenericVisitor, HashCodeVisitor, EqualsVisitor, PrettyPrintVisitor, GeneratedJavaParser, DefaultPrettyPrinterVisitor), showing many modules depend on SynchronizedStmt. Outgoing dependencies include core AST and meta-model elements (e.g., com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.Range, com.github.javaparser.ast.expr.Expression, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.TokenRange, com.github.javaparser.ast.Node, com.github.javaparser.ast.stmt.BlockStmt). Because it has both a large number of incoming links (22) and multiple outgoing links (10) to many different abstractions, it fits the Hub-like Modularization smell."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.contexts.MethodCallExprContext",
        "detection": false,
        "justification": "Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies. MethodCallExprContext has many outgoing dependencies (analyzed_package.dependencies count = 19; outgoing_dependencies entries = 20, e.g. NameExpr, ResolvedTypeVariable, MethodResolutionLogic, JavaParserFacade, ResolvedType, MethodCallExpr, ContextHelper, ReferenceTypeImpl, MethodUsage, etc.) but has zero incoming dependencies (incoming_dependencies count = 0). Because there are no incoming dependencies, it does not meet the definition of a hub (highly connected both ways), so the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.resolution.typeinference.bounds.SubtypeOfBound",
        "detection": false,
        "justification": "SubtypeOfBound has a small number of direct relationships: 3 outgoing dependencies (InferenceVariableSubstitution, TypeHelper, ResolvedType) and 2 incoming dependents (TypeInference, BoundSet). Hub-like modularization requires an abstraction to have incoming and outgoing dependencies with a large number of other abstractions. The direct IN/OUT counts here (3 outgoing, 2 incoming) are low. Note: although the outgoing dependency TypeHelper itself lists many dependencies, those are indirect and do not make SubtypeOfBound a hub by the provided direct-dependency data."
    },
    {
        "identifier": "com.github.javaparser.printer.configuration.ConfigurationOption",
        "detection": false,
        "justification": "ConfigurationOption is referenced by several other classes (incoming dependencies from DefaultPrettyPrinterVisitor, PrinterConfiguration, DefaultConfigurationOption, DefaultPrinterConfiguration, PrettyPrinterConfiguration — 5 incoming). However, it has no outgoing dependencies (empty dependencies list). The Hub-like Modularization smell requires an abstraction to have a large number of both incoming and outgoing dependencies; here only incoming are present while outgoing are zero, so the smell is not detected."
    },
    {
        "identifier": "japa.bdd.samples.JavaConcepts.Sexo",
        "detection": false,
        "justification": "The class has 0 incoming dependencies and 0 outgoing dependencies (both dependency lists are empty). Hub-like Modularization requires many incoming and outgoing links; with no dependencies, this class is not a hub."
    },
    {
        "identifier": "javaparser.JSONObject",
        "detection": false,
        "justification": "Incoming dependencies: 0; Outgoing dependencies: 0. The class has no incoming or outgoing links to other abstractions, so it does not exhibit hub-like modularization."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserTypeAdapter",
        "detection": true,
        "justification": "JavaParserTypeAdapter has a large number of both outgoing and incoming relations: 10 outgoing dependencies (com.github.javaparser.resolution.model.SymbolReference, com.github.javaparser.ast.body.TypeDeclaration, com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade, com.github.javaparser.symbolsolver.javaparsermodel.declarations.AstResolutionUtils, com.github.javaparser.resolution.types.ResolvedType, com.github.javaparser.resolution.TypeSolver, com.github.javaparser.ast.NodeList, com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration, com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFactory, com.github.javaparser.ast.body.FieldDeclaration) and 5 incoming dependents (JavaParserAnnotationDeclaration, JavaParserEnumDeclaration, JavaParserRecordDeclaration, JavaParserClassDeclaration, JavaParserInterfaceDeclaration). The combined set of 15 distinct connections indicates the class acts as a central hub mediating many abstractions (AST node types, resolution utilities, type/solver classes), which meets the Hub-like Modularization smell criteria."
    },
    {
        "identifier": "com.github.javaparser.metamodel.InitializerDeclarationMetaModel",
        "detection": false,
        "justification": "InitializerDeclarationMetaModel has a very small set of direct dependencies: 1 outgoing dependency (com.github.javaparser.metamodel.PropertyMetaModel) and 2 incoming dependencies (com.github.javaparser.ast.body.InitializerDeclaration and com.github.javaparser.metamodel.JavaParserMetaModel). Although JavaParserMetaModel depends on many meta-model classes (including InitializerDeclarationMetaModel), that makes JavaParserMetaModel a hub, not InitializerDeclarationMetaModel. The class itself does not have incoming and outgoing relationships with a large number of other abstractions, so it does not exhibit Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.resolution.declarations.ResolvedEnumDeclaration",
        "detection": false,
        "justification": "ResolvedEnumDeclaration has only 1 outgoing dependency (com.github.javaparser.resolution.declarations.ResolvedEnumConstantDeclaration) and 4 incoming dependencies (com.github.javaparser.symbolsolver.JavaSymbolSolver, com.github.javaparser.symbolsolver.javaparsermodel.contexts.FieldAccessContext, com.github.javaparser.ast.body.EnumDeclaration, com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration). Hub-like modularization requires an abstraction to have a large number of both incoming and outgoing connections; here the outgoing coupling is minimal and the incoming references (4 callers) are not a 'large number', so the class is not a hub."
    },
    {
        "identifier": "com.github.javaparser.metamodel.NameMetaModel",
        "detection": false,
        "justification": "The analyzed class has a low number of direct relationships: only 1 outgoing dependency (com.github.javaparser.metamodel.PropertyMetaModel) and only 2 incoming dependents (com.github.javaparser.ast.expr.Name and com.github.javaparser.metamodel.JavaParserMetaModel). Hub-like Modularization requires an abstraction to have incoming and outgoing dependencies with a large number of other abstractions; the provided data shows a small degree for NameMetaModel. (Note: JavaParserMetaModel references many meta-models, but that indicates JavaParserMetaModel is a hub, not NameMetaModel.)"
    },
    {
        "identifier": "com.github.javaparser.metamodel.SynchronizedStmtMetaModel",
        "detection": false,
        "justification": "SynchronizedStmtMetaModel has only 1 outgoing dependency (com.github.javaparser.metamodel.PropertyMetaModel) and only 2 incoming dependencies (com.github.javaparser.ast.stmt.SynchronizedStmt and com.github.javaparser.metamodel.JavaParserMetaModel). Hub-like Modularization requires an abstraction to have dependencies (incoming and outgoing) with a large number of other abstractions; the provided counts (outgoing=1, incoming=2) are low, so this class is not a hub."
    },
    {
        "identifier": "(default package).Trie",
        "detection": false,
        "justification": "Both incoming_dependencies and outgoing_dependencies are empty (zero dependencies). With no incoming or outgoing links to other abstractions, Trie does not exhibit hub-like modularization."
    },
    {
        "identifier": "com.github.javaparser.metamodel.ConditionalExprMetaModel",
        "detection": false,
        "justification": "Incoming dependencies: 2 classes (com.github.javaparser.ast.expr.ConditionalExpr, com.github.javaparser.metamodel.JavaParserMetaModel). Outgoing dependencies: 1 class (com.github.javaparser.metamodel.PropertyMetaModel). Hub-like Modularization requires an abstraction to have dependencies (both incoming and outgoing) with a large number of other abstractions. The ConditionalExprMetaModel has only a small number of incoming (2) and outgoing (1) dependencies, so it does not exhibit a hub-like modularization smell."
    },
    {
        "identifier": "com.github.javaparser.metamodel.VariableDeclaratorMetaModel",
        "detection": false,
        "justification": "VariableDeclaratorMetaModel has 1 outgoing dependency (com.github.javaparser.metamodel.PropertyMetaModel) and 2 incoming dependencies (com.github.javaparser.ast.body.VariableDeclarator and com.github.javaparser.metamodel.JavaParserMetaModel). That yields only 3 distinct dependency partners. This is not a large number of incoming and outgoing dependencies, so it does not meet the Hub-like Modularization smell criteria. (Note: JavaParserMetaModel references many meta-model classes, but only one of its many dependencies is VariableDeclaratorMetaModel.)"
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.resolution.typeinference.ConstraintFormula.ReductionResult",
        "detection": false,
        "justification": "ReductionResult has 1 outgoing dependency (com.github.javaparser.symbolsolver.resolution.typeinference.BoundSet) and 1 incoming dependency (com.github.javaparser.symbolsolver.resolution.typeinference.ConstraintFormula). Hub-like Modularization requires dependencies (both incoming and outgoing) with a large number of other abstractions; ReductionResult shows only a single incoming and a single outgoing dependency, so it is not a hub. (BoundSet has many dependencies, but those are not direct dependencies of ReductionResult.)"
    },
    {
        "identifier": "com.github.javaparser.ast.expr.NameExpr",
        "detection": true,
        "justification": "NameExpr has a large number of incoming and outgoing dependencies. Incoming: ~37 distinct clients depend on NameExpr (examples: com.github.javaparser.symbolsolver.javaparsermodel.DefaultVisitorAdapter, JavaParserFacade, TypeExtractor, many AST nodes and node-types such as PackageDeclaration, ImportDeclaration, VariableDeclarator, MethodDeclaration, TypeDeclaration, ConstructorDeclaration, MethodCallExpr, FieldAccessExpr, Expression, AnnotationExpr, plus numerous visitor classes like VoidVisitor, GenericVisitor, PrettyPrintVisitor, CloneVisitor, EqualsVisitor). Outgoing: NameExpr itself depends on 10 distinct abstractions (examples: com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.resolution.declarations.ResolvedValueDeclaration, com.github.javaparser.metamodel.NameExprMetaModel, com.github.javaparser.ast.expr.SimpleName, com.github.javaparser.TokenRange, com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.ast.Node, com.github.javaparser.Range). The combination of many incoming clients (dozens across core visitors and AST node types) and multiple outgoing dependencies indicates NameExpr functions as a central hub and therefore exhibits the Hub-like Modularization smell."
    },
    {
        "identifier": "com.github.javaparser.ModifierHolder",
        "detection": false,
        "justification": "ModifierHolder has only two outgoing dependencies (com.github.javaparser.ast.NodeList, com.github.javaparser.JavaToken) and a single incoming dependency entry (com.github.javaparser.GeneratedJavaParser). Although GeneratedJavaParser itself depends on many types, the data shows only one incoming abstraction referencing ModifierHolder and only two outgoing references — not a large number of incoming and outgoing dependency relationships required for a hub-like modularization smell."
    },
    {
        "identifier": "com.github.javaparser.resolution.TypeSolver",
        "detection": false,
        "justification": "The class has a large number of incoming dependencies (~125 distinct classes reference it, e.g. com.github.javaparser.symbolsolver.JavaSymbolSolver, com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade, com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver, various reflectionmodel.* and many javaparsermodel.contexts). However, its outgoing dependencies are small (3: com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration, com.github.javaparser.resolution.model.SymbolReference, com.github.javaparser.resolution.UnsolvedSymbolException). The Hub-like Modularization smell requires a large number of both incoming and outgoing dependencies; here only incoming is large while outgoing is minimal, so the smell is not detected."
    },
    {
        "identifier": "(default package).Test1",
        "detection": false,
        "justification": "Hub-like Modularization requires an abstraction to have many incoming and outgoing dependencies. Test1 has 0 incoming dependencies and 0 outgoing dependencies (both lists are empty), so it does not meet the criteria for a hub-like module."
    },
    {
        "identifier": "com.github.javaparser.resolution.MethodUsage",
        "detection": false,
        "justification": "MethodUsage has many incoming dependencies (26 distinct clients including ReflectionClassDeclaration, JavaParserFacade, SymbolSolver, MethodResolutionLogic, TypeInference, JavassistUtils, Solver, etc.), but only a small set of outgoing dependencies (5 targets: com.github.javaparser.resolution.types.parametrization.ResolvedTypeParametersMap, com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration, com.github.javaparser.resolution.types.ResolvedType, com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration, com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration). Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; here incoming is large but outgoing is limited, so the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.metamodel.AnnotationMemberDeclarationMetaModel",
        "detection": false,
        "justification": "Incoming dependencies: com.github.javaparser.ast.body.AnnotationMemberDeclaration and com.github.javaparser.metamodel.JavaParserMetaModel (2 incoming). Outgoing dependencies: com.github.javaparser.metamodel.PropertyMetaModel (1 outgoing). Hub-like Modularization requires an abstraction to have dependencies with a large number of other abstractions; here fan-in = 2 and fan-out = 1, which is not a large number, so the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.resolution.typesolvers.JavaParserTypeSolver",
        "detection": false,
        "justification": "JavaParserTypeSolver has a moderate number of outgoing dependencies (9 distinct types: com.github.javaparser.resolution.model.SymbolReference, com.github.javaparser.symbolsolver.utils.FileUtils, com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade, com.github.javaparser.resolution.TypeSolver, com.github.javaparser.resolution.cache.Cache, com.github.javaparser.ParserConfiguration, com.github.javaparser.JavaParser, com.github.javaparser.ast.CompilationUnit, com.github.javaparser.resolution.Navigator) but only a single incoming dependency in the provided data (com.github.javaparser.symbolsolver.resolution.typesolvers.TypeSolverBuilder). Hub-like Modularization requires an abstraction to have dependencies with a large number of other abstractions both incoming and outgoing; here the incoming dependency count is low (1), so the class does not meet the hub-like criteria based on the given data."
    },
    {
        "identifier": "com.github.javaparser.ast.stmt.WhileStmt",
        "detection": true,
        "justification": "WhileStmt has a large number of incoming dependencies (≈23 distinct abstractions reference it, e.g. many visitor implementations and utilities such as DefaultVisitorAdapter, VoidVisitor, GenericVisitor, HashCodeVisitor, EqualsVisitor, CloneVisitor, GeneratedJavaParser, PrettyPrintVisitor, DefaultPrettyPrinterVisitor, NodeFinderVisitor, NormalCompletionVisitor, WhileStatementContext, Statement, etc.) while also depending outward on many core abstractions (10 outgoing dependencies: com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.metamodel.WhileStmtMetaModel, com.github.javaparser.ast.stmt.Statement, com.github.javaparser.Range, com.github.javaparser.ast.expr.Expression, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.TokenRange, com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.ast.Node, com.github.javaparser.ast.visitor.GenericVisitor). The class therefore has many incoming and outgoing links to diverse parts of the system (visitors, meta-model, core AST types, token/range/observer utilities), matching the Hub-like Modularization smell."
    },
    {
        "identifier": "com.github.javaparser.utils.PositionUtils",
        "detection": false,
        "justification": "PositionUtils has many outgoing dependencies (9): com.github.javaparser.Range, com.github.javaparser.ast.body.ClassOrInterfaceDeclaration, com.github.javaparser.ast.expr.AnnotationExpr, com.github.javaparser.ast.Node, com.github.javaparser.ast.body.MethodDeclaration, com.github.javaparser.ast.NodeList, com.github.javaparser.Position, com.github.javaparser.ast.body.FieldDeclaration, com.github.javaparser.ast.Modifier. However it has only one incoming dependency (1): com.github.javaparser.CommentsInserter. Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing relationships; here incoming connections are minimal, so PositionUtils is not a hub."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.contexts.StatementContext",
        "detection": true,
        "justification": "StatementContext has a broad set of outgoing dependencies to many distinct abstractions: com.github.javaparser.resolution.model.SymbolReference, com.github.javaparser.resolution.Context, com.github.javaparser.ast.stmt.Statement, com.github.javaparser.resolution.TypeSolver, com.github.javaparser.symbolsolver.javaparsermodel.contexts.AbstractJavaParserContext, com.github.javaparser.ast.nodeTypes.NodeWithStatements, com.github.javaparparser.ast.Node, com.github.javaparser.resolution.SymbolDeclarator, com.github.javaparser.resolution.model.Value, and com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFactory. It also has multiple incoming dependencies from other context classes that use it (com.github.javaparser.symbolsolver.javaparsermodel.contexts.ForEachStatementContext, com.github.javaparser.symbolsolver.javaparsermodel.contexts.TryWithResourceContext, com.github.javaparser.symbolsolver.javaparsermodel.contexts.ForStatementContext). Because it both depends on many diverse modules (AST node types, resolution APIs, factories, and abstract context classes) and is referenced by several other context classes, it acts as a central connector between many abstractions — matching the Hub-like Modularization smell."
    },
    {
        "identifier": "com.github.javaparser.metamodel.EnclosedExprMetaModel",
        "detection": false,
        "justification": "EnclosedExprMetaModel has only one outgoing dependency (com.github.javaparser.metamodel.PropertyMetaModel) and only two incoming dependencies (com.github.javaparser.ast.expr.EnclosedExpr and com.github.javaparser.metamodel.JavaParserMetaModel). A hub-like modularization requires an abstraction to have dependencies (both incoming and outgoing) with a large number of other abstractions; the observed incoming/outgoing counts are small, so this class is not a hub."
    },
    {
        "identifier": "javaparser.GenericClass.Bar",
        "detection": false,
        "justification": "The class has no incoming or outgoing dependencies (incoming_dependencies = [], outgoing_dependencies = []), therefore it does not exhibit hub-like modularization which requires a large number of both incoming and outgoing dependencies."
    },
    {
        "identifier": "com.github.javaparser.JavaParserAdapter",
        "detection": false,
        "justification": "JavaParserAdapter has many outgoing dependencies (25 distinct types listed, e.g. ParserConfiguration, JavaParser, CompilationUnit, ParseResult, numerous AST node types such as Name, MethodDeclaration, Type, BlockStmt), but very few incoming dependencies (only 1 incoming: com.github.javaparser.StaticJavaParser). Hub-like Modularization requires an abstraction to have dependencies with a large number of other abstractions in both directions (many incoming and many outgoing). Because incoming dependency count is minimal while outgoing is large, this class does not meet the bidirectional 'hub' criterion."
    },
    {
        "identifier": "com.github.javaparser.TokenMgrException",
        "detection": false,
        "justification": "TokenMgrException has 0 outgoing dependencies and only 1 incoming dependency (from com.github.javaparser.GeneratedJavaParserTokenManager). Hub-like Modularization requires an abstraction to have many incoming and many outgoing dependencies; here both counts are not large (outgoing=0, incoming=1), so the smell is not present."
    },
    {
        "identifier": "com.github.javaparser.resolution.Navigator",
        "detection": true,
        "justification": "Navigator has a large number of both outgoing and incoming dependencies. Outgoing dependencies (11) include: com.github.javaparser.ast.body.EnumDeclaration, ConstructorDeclaration, CompilationUnit, TypeDeclaration, ClassOrInterfaceDeclaration, Node, VariableDeclarator, MethodDeclaration, SwitchStmt, FieldDeclaration, ReturnStmt. Incoming dependencies (21) include many core symbol-solver and context classes such as JavaSymbolSolver, JavaParserFacade, JavaParserFactory, TypeExtractor, JavaParserMethodDeclaration, various JavaParser* declarations, multiple context classes (LambdaExprContext, MethodReferenceExprContext, ForEachStatementContext, ForStatementContext, TryWithResourceContext, SwitchEntryContext), and JavaParserTypeSolver. Because Navigator is referenced by many other abstractions and itself depends on many AST node types, it matches the Hub-like Modularization smell (high both-way coupling)."
    },
    {
        "identifier": "com.github.javaparser.metamodel.ReceiverParameterMetaModel",
        "detection": false,
        "justification": "ReceiverParameterMetaModel has incoming dependencies from 2 abstractions (com.github.javaparser.ast.body.ReceiverParameter and com.github.javaparser.metamodel.JavaParserMetaModel) and a single outgoing dependency to com.github.javaparser.metamodel.PropertyMetaModel — a total of 3 connected abstractions. This is not a large number of both incoming and outgoing dependencies, so it does not meet the Hub-like Modularization smell criteria."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.logic.ObjectProvider",
        "detection": false,
        "justification": "ObjectProvider has only one direct outgoing dependency (com.github.javaparser.resolution.types.ResolvedReferenceType) and zero incoming dependencies. Hub-like Modularization requires an abstraction to have many incoming and outgoing dependencies; here there are not multiple direct dependents or dependencies, so the smell is not detected. (The listed dependencies of ResolvedReferenceType are second-level and do not count as direct dependencies of ObjectProvider.)"
    },
    {
        "identifier": "com.github.javaparser.ast.type.VarType",
        "detection": true,
        "justification": "VarType has both many incoming and outgoing relationships with other abstractions: it directly depends on 12 distinct abstractions (examples: com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.resolution.types.ResolvedType, com.github.javaparser.ast.body.VariableDeclarator, com.github.javaparser.ast.expr.Expression, com.github.javaparser.ast.NodeList, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.TokenRange, com.github.javaparser.ast.Node, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.metamodel.VarTypeMetaModel). It is referenced by at least 21 different incoming classes (examples: DefaultVisitorAdapter, Type, VoidVisitor, HashCodeVisitor, VoidVisitorWithDefaults, GenericVisitor, ModifierVisitor, GenericListVisitorAdapter, ObjectIdentityEqualsVisitor, ObjectIdentityHashCodeVisitor, EqualsVisitor, GenericVisitorAdapter, NoCommentEqualsVisitor, CloneVisitor, VoidVisitorAdapter, GenericVisitorWithDefaults, NoCommentHashCodeVisitor, NodeFinderVisitor, VarValidator, PrettyPrintVisitor, DefaultPrettyPrinterVisitor). The presence of numerous and diverse incoming visitors/utilities and multiple outgoing links to core AST, resolution, and meta-model abstractions indicates VarType functions as a hub-like abstraction (many incoming + many outgoing dependencies)."
    },
    {
        "identifier": "com.github.javaparser.utils.ClassUtils",
        "detection": false,
        "justification": "Class has 0 outgoing dependencies and only 1 incoming dependency (from com.github.javaparser.ast.CompilationUnit). Hub-like Modularization requires many incoming and outgoing connections; here outgoing_dependencies is empty and incoming count is low, so the class is not a hub."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javassistmodel.JavassistParameterDeclaration",
        "detection": false,
        "justification": "Hub-like Modularization requires the class to have both many incoming and many outgoing dependencies. JavassistParameterDeclaration has 0 incoming dependencies and only 3 outgoing dependencies: com.github.javaparser.resolution.types.ResolvedType, com.github.javaparser.resolution.TypeSolver, and com.github.javaparser.symbolsolver.javassistmodel.JavassistFactory. Because there are no incoming links and the number of direct outgoing dependencies is small and limited to these specific abstractions, it does not meet the criteria for a hub."
    },
    {
        "identifier": "com.github.javaparser.ast.type.ConvertibleToUsage",
        "detection": false,
        "justification": "ConvertibleToUsage has 0 incoming dependencies and only 2 direct outgoing dependencies (com.github.javaparser.resolution.Context, com.github.javaparser.resolution.types.ResolvedType). Hub-like Modularization requires an abstraction to have many incoming and outgoing relationships; here incoming is empty and outgoing is small. Although ResolvedType itself lists many dependencies, the analysis must consider the class in isolation, so those transitive links do not make ConvertibleToUsage a hub."
    },
    {
        "identifier": "com.github.javaparser.StaticJavaParser",
        "detection": true,
        "justification": "StaticJavaParser has a large number of outgoing dependencies (27 distinct target classes, e.g. com.github.javaparser.JavadocParser, com.github.javaparser.JavaParser, com.github.javaparser.ast.CompilationUnit, com.github.javaparser.ast.body.MethodDeclaration, com.github.javaparser.ast.type.Type, com.github.javaparser.ast.expr.Name) and a large number of incoming dependencies (38 distinct clients, e.g. com.github.javaparser.ast.CompilationUnit, many node-type interfaces such as NodeWithParameters, NodeWithAnnotations, NodeWithMembers, and numerous generator/utility classes such as MetaModelGenerator, CoreGenerator, AbstractGenerator). The presence of many both incoming and outgoing ties indicates the class acts as a central hub coordinating many other abstractions, matching the Hub-like Modularization smell."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.resolution.typeinference.constraintformulas.TypeSameAsType",
        "detection": false,
        "justification": "TypeSameAsType has only 3 outgoing dependencies (TypeHelper, BoundSet, ResolvedType) and a single incoming dependency (BoundSet). Hub-like modularization requires an abstraction to have many incoming and outgoing dependencies; the provided data shows small, limited coupling, so this class is not a hub."
    },
    {
        "identifier": "com.github.javaparser.ast.type.ArrayType.ArrayBracketPair",
        "detection": false,
        "justification": "ArrayType.ArrayBracketPair has only 1 incoming dependency (com.github.javaparser.ast.type.ArrayType) and 2 outgoing dependencies (com.github.javaparser.ast.NodeList, com.github.javaparser.TokenRange). The total number of direct incoming and outgoing relationships is small (incoming=1, outgoing=2), so it does not meet the definition of a hub-like modularization (an abstraction with dependencies with a large number of other abstractions)."
    },
    {
        "identifier": "com.github.javaparser.utils.VisitorMap",
        "detection": false,
        "justification": "VisitorMap has only one incoming dependency (com.github.javaparser.utils.VisitorMap.EqualsHashcodeOverridingFacade -> com.github.javaparser.utils.VisitorMap) and one direct outgoing dependency (com.github.javaparser.ast.visitor.GenericVisitor). Although GenericVisitor itself depends on many AST classes, the analysis must consider VisitorMap in isolation and its direct incoming/outgoing dependency counts are low, so it does not exhibit Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.metamodel.MemberValuePairMetaModel",
        "detection": false,
        "justification": "MemberValuePairMetaModel has a very small number of direct dependencies: one outgoing dependency to com.github.javaparser.metamodel.PropertyMetaModel, and only two incoming dependencies (com.github.javaparser.ast.expr.MemberValuePair and com.github.javaparser.metamodel.JavaParserMetaModel). Hub-like Modularization is characterized by an abstraction having incoming and outgoing relationships with a large number of other abstractions; the provided data shows low incoming (2) and low outgoing (1) counts, so this class is not a hub. Note: although JavaParserMetaModel itself references many meta-model classes, that constitutes a single incoming dependency to MemberValuePairMetaModel in the given data and does not make MemberValuePairMetaModel a hub."
    },
    {
        "identifier": "(default package).OuterClass",
        "detection": false,
        "justification": "The class has no incoming or outgoing dependencies (incoming_dependencies = 0, outgoing_dependencies = 0). Hub-like Modularization requires an abstraction to have dependencies both incoming and outgoing with a large number of other abstractions; this class has none, so the smell is not present."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.resolution.typeinference.ControlFlowLogic",
        "detection": false,
        "justification": "ControlFlowLogic has many outgoing dependencies (16 distinct abstractions: com.github.javaparser.ast.stmt.ExpressionStmt, ContinueStmt, com.github.javaparser.ast.visitor.GenericVisitorAdapter, com.github.javaparser.ast.stmt.Statement, LocalClassDeclarationStmt, IfStmt, AssertStmt, BlockStmt, com.github.javaparser.ast.Node, com.github.javaparser.ast.expr.VariableDeclarationExpr, LocalRecordDeclarationStmt, EmptyStmt, DoStmt, com.github.javaparser.ast.visitor.GenericVisitor, LabeledStmt, BreakStmt) but only a single incoming dependency (com.github.javaparser.symbolsolver.resolution.typeinference.constraintformulas.ExpressionCompatibleWithType). Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing relationships; because incoming connections are minimal here, the smell is not present."
    },
    {
        "identifier": "com.github.javaparser.resolution.Context",
        "detection": false,
        "justification": "Although Context has a very large number of incoming dependencies (dozens of distinct classes across many packages reference com.github.javaparser.resolution.Context — e.g. MethodDeclarationCommonLogic, JavaParserFacade, many reflectionmodel.* and javaparsermodel.* classes, Solver, multiple ast.type.* classes), its outgoing dependency set is small: only three direct outgoing dependencies are listed (com.github.javaparser.resolution.model.Value, com.github.javaparser.resolution.model.SymbolReference, com.github.javaparser.ast.Node). The Hub-like Modularization smell requires an abstraction to have both many incoming and many outgoing dependencies; here incoming degree is high but outgoing degree is low when the class is considered in isolation, so the smell is not detected."
    },
    {
        "identifier": "com.example.Alpha.CustomInterface",
        "detection": false,
        "justification": "The class has 0 incoming dependencies and 0 outgoing dependencies (incoming_dependencies: [], outgoing_dependencies: []). Hub-like Modularization requires an abstraction to have dependencies both incoming and outgoing with a large number of other abstractions; this class has none, so the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.ast.nodeTypes.modifiers.NodeWithPublicModifier",
        "detection": false,
        "justification": "Hub-like Modularization is not detected because the class has no incoming or outgoing dependencies. incoming_dependencies = 0 (empty list) and outgoing_dependencies = 0 (empty list), so it does not exhibit the large number of both incoming and outgoing relationships required for a hub-like abstraction."
    },
    {
        "identifier": "com.github.javaparser.ast.expr.EnclosedExpr",
        "detection": true,
        "justification": "EnclosedExpr has many incoming and outgoing relations indicating a hub role. Outgoing dependencies (9) include core/central abstractions: com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.ast.expr.Expression, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.TokenRange, com.github.javaparser.metamodel.EnclosedExprMetaModel, com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.ast.Node, and com.github.javaparser.Range. Incoming dependencies are extensive (~26 distinct classes) from many different subsystems — e.g. numerous visitor implementations (VoidVisitor, GenericVisitor, HashCodeVisitor, EqualsVisitor, ModifierVisitor, various VisitorAdapters), symbol-solver classes (DefaultVisitorAdapter, TypeExtractor, TypeInference, ExpressionCompatibleWithType), printer/parser classes (PrettyPrintVisitor, GeneratedJavaParser, DefaultPrettyPrinterVisitor), and core AST classes (Expression, NodeFinderVisitor). The combination of a moderate-to-large set of outgoing core dependencies and a very large set of incoming dependents across diverse modules fits the Hub-like Modularization smell."
    },
    {
        "identifier": "com.github.javaparser.EscapeSequences",
        "detection": false,
        "justification": "incoming_dependencies: [] (0); outgoing_dependencies: [] (0). Hub-like Modularization requires many incoming and outgoing dependencies; this class has none, so it is not a hub."
    },
    {
        "identifier": "com.github.javaparser.resolution.logic.InferenceVariableType",
        "detection": false,
        "justification": "InferenceVariableType has only one incoming dependency (com.github.javaparser.resolution.logic.InferenceContext) and five outgoing dependencies (com.github.javaparser.resolution.types.ResolvedReferenceType, com.github.javaparser.resolution.TypeSolver, com.github.javaparser.resolution.types.ResolvedType, com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration, com.github.javaparser.resolution.types.ResolvedWildcard). Hub-like Modularization requires an abstraction to have dependencies (both incoming and outgoing) with a large number of other abstractions; the provided data shows a single incoming collaborator and a modest number of outgoing dependencies, so the hub smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.printer.concretesyntaxmodel.CsmSequence",
        "detection": false,
        "justification": "CsmSequence has only 2 outgoing dependencies (com.github.javaparser.printer.SourcePrinter, com.github.javaparser.ast.Node) and only 1 incoming depender in the provided data (com.github.javaparser.printer.lexicalpreservation.LexicalDifferenceCalculator). While the outgoing targets (SourcePrinter and Node) themselves list many dependencies, the class under analysis directly connects to only a small number of other abstractions (outgoing=2, incoming=1). Therefore, based on the provided data and considering the class in isolation, it does not exhibit Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.metamodel.VarTypeMetaModel",
        "detection": false,
        "justification": "VarTypeMetaModel has 0 outgoing dependencies (outgoing_dependencies is empty) and only 2 incoming dependency sources: com.github.javaparser.ast.type.VarType and com.github.javaparser.metamodel.JavaParserMetaModel (both list com.github.javaparser.metamodel.VarTypeMetaModel in their dependencies). Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; this class does not meet that criterion."
    },
    {
        "identifier": "com.github.javaparser.printer.lexicalpreservation.TextElementMatchers",
        "detection": false,
        "justification": "TextElementMatchers has a small number of direct outgoing dependencies (3): TextElement, TextElementMatcher, and com.github.javaparser.ast.Node. It has a single incoming dependency from NodeText. The total set of directly connected abstractions is therefore limited (4 distinct classes). Although one of its outgoing targets (Node) itself has many dependencies, the analysis must consider the class in isolation; TextElementMatchers does not exhibit a large number of both incoming and outgoing relationships and thus does not meet the Hub-like Modularization smell criteria."
    },
    {
        "identifier": "com.github.javaparser.ParserConfiguration",
        "detection": true,
        "justification": "ParserConfiguration has many outgoing dependencies (10) including: com.github.javaparser.LineEndingProcessingProvider, com.github.javaparser.ast.validator.Validator, com.github.javaparser.resolution.SymbolResolver, com.github.javaparser.ParserConfiguration.LanguageLevel, com.github.javaparser.ast.Node, com.github.javaparser.ParseResult, com.github.javaparser.Providers, com.github.javaparser.ast.validator.postprocessors.PostProcessors, com.github.javaparser.UnicodeEscapeProcessingProvider. It is also widely depended upon (22 incoming references) by diverse classes such as com.github.javaparser.JavaParser, com.github.javaparser.StaticJavaParser, com.github.javaparser.Processor, com.github.javaparser.utils.SourceRoot, com.github.javaparser.utils.ProjectRoot, com.github.javaparser.generator.metamodel.MetaModelGenerator, com.github.javaparser.generator.core.CoreGenerator, various language-level validator classes (e.g., Java17Validator, Java1_0Validator) and postprocessors. The combination of a large number of distinct incoming and outgoing relationships indicates the class functions as a central hub, matching the Hub-like Modularization smell."
    },
    {
        "identifier": "com.github.javaparser.resolution.logic.InferenceContext",
        "detection": true,
        "justification": "InferenceContext has broad outgoing coupling to 8 core resolution abstractions (ResolvedReferenceType, TypeSolver, ResolvedType, ResolvedTypeParameterDeclaration, ResolvedReferenceTypeDeclaration, InferenceVariableType, ResolvedWildcard, ResolvedLambdaConstraintType) while being referenced by 7 distinct clients (MethodDeclarationCommonLogic, ReflectionAnnotationDeclaration, ReflectionEnumDeclaration, ReflectionInterfaceDeclaration, TypeExtractor, LambdaExprContext, MethodReferenceExprContext). The incoming callers come from multiple packages and varied responsibilities (symbolsolver.declarations.common, reflectionmodel, javaparsermodel, javaparsermodel.contexts), and the outgoing targets are central type/resolution classes. This combination of many incoming and many outgoing connections demonstrates a hub-like modularization smell."
    },
    {
        "identifier": "com.github.javaparser.ast.visitor.TreeVisitor",
        "detection": false,
        "justification": "TreeVisitor has 0 incoming dependencies and only 1 outgoing dependency (com.github.javaparser.ast.Node). Hub-like Modularization requires the abstraction itself to have many incoming and outgoing relationships. While the single outgoing target (Node) has many dependencies, the analysis must consider TreeVisitor in isolation, so it does not qualify as a hub."
    },
    {
        "identifier": "com.github.javaparser.resolution.types.ResolvedTypeVariable",
        "detection": false,
        "justification": "ResolvedTypeVariable has a moderate number of incoming dependencies (7 distinct clients: ReflectionMethodResolutionLogic, MethodCallExprContext, TypeParameter, LazyType, ResolvedType, ResolvedReferenceType, MethodResolutionLogic) indicating it is widely used. However, its outgoing dependency set is small (3 dependencies: com.github.javaparser.resolution.Context, com.github.javaparser.resolution.types.ResolvedType, com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration). The smell requires the abstraction to have both many incoming and many outgoing ties; here only incoming ties are numerous while outgoing ties remain limited, so it does not meet the hub-like modularization criteria."
    },
    {
        "identifier": "com.github.javaparser.metamodel.ReturnStmtMetaModel",
        "detection": false,
        "justification": "ReturnStmtMetaModel is not hub-like: it has only one outgoing dependency (com.github.javaparser.metamodel.PropertyMetaModel) and two incoming dependencies (com.github.javaparser.ast.stmt.ReturnStmt and com.github.javaparser.metamodel.JavaParserMetaModel). Hub-like modularization requires relationships (both incoming and outgoing) with a large number of other abstractions; the provided data shows small in/out degree. Note: although JavaParserMetaModel itself references many meta-model classes, that does not increase the number of direct incoming or outgoing dependencies of ReturnStmtMetaModel beyond being referenced by JavaParserMetaModel."
    },
    {
        "identifier": "com.github.javaparser.resolution.model.typesystem.ReferenceTypeImpl",
        "detection": true,
        "justification": "ReferenceTypeImpl has a large number of incoming dependencies (at least 16 distinct clients) including: com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassAdapter, ReflectionInterfaceDeclaration, ReflectionMethodResolutionLogic; com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade, TypeExtractor, JavaParserEnumDeclaration; com.github.javaparser.symbolsolver.javaparsermodel.contexts.MethodCallExprContext, SwitchEntryContext; com.github.javaparser.symbolsolver.resolution.typeinference.TypeInference, BoundSet, TypeHelper; com.github.javaparser.symbolsolver.resolution.typeinference.constraintformulas.TypeCompatibleWithType; com.github.javaparser.symbolsolver.javassistmodel.JavassistEnumConstantDeclaration, JavassistTypeDeclarationAdapter; com.github.javaparser.ast.type.VarType; com.github.javaparser.resolution.logic.MethodResolutionLogic. It also has multiple outgoing dependencies (8) on core abstraction types such as com.github.javaparser.resolution.types.ResolvedReferenceType, ResolvedTypeParametersMap, ResolvedTypeTransformer, FunctionalInterfaceLogic, ResolvedType, ResolvedTypeParameterDeclaration, ResolvedReferenceTypeDeclaration, and MethodUsage. The combination of many distinct incoming clients plus numerous outgoing ties to core type abstractions indicates ReferenceTypeImpl functions as a coupling hub and thus exhibits the Hub-like Modularization smell."
    },
    {
        "identifier": "com.github.javaparser.ast.nodeTypes.NodeWithMembers",
        "detection": false,
        "justification": "NodeWithMembers has a substantial set of outgoing dependencies (12 direct outgoing targets: com.github.javaparser.ast.body.BodyDeclaration, com.github.javaparser.ast.body.VariableDeclarator, com.github.javaparser.ast.body.MethodDeclaration, com.github.javaparser.ast.expr.Expression, com.github.javaparser.ast.body.ConstructorDeclaration, com.github.javaparser.ast.Modifier, com.github.javaparser.ast.NodeList, com.github.javaparser.ast.type.Type, com.github.javaparser.ast.body.InitializerDeclaration, com.github.javaparser.StaticJavaParser, com.github.javaparser.ast.stmt.BlockStmt, com.github.javaparser.ast.body.FieldDeclaration), but only a single incoming dependency is recorded (com.github.javaparser.symbolsolver.javaparsermodel.declarations.AstResolutionUtils). Because the smell requires the abstraction to have a large number of both incoming and outgoing dependencies, the presence of many outgoing links alone is insufficient to classify NodeWithMembers as a hub; the incoming dependency count is low (1), so Hub-like Modularization is not detected."
    },
    {
        "identifier": "com.github.javaparser.metamodel.JavadocCommentMetaModel",
        "detection": false,
        "justification": "Outgoing dependencies are empty (no outgoing links). There are only two incoming dependents: com.github.javaparser.ast.comments.JavadocComment and com.github.javaparser.metamodel.JavaParserMetaModel. Although JavaParserMetaModel references JavadocCommentMetaModel among many other meta-model classes, the analyzed class itself has no outgoing dependencies and only two incoming connections — not the large number of both incoming and outgoing dependencies required to classify it as a hub-like modularization."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.SourceFileInfoExtractor",
        "detection": false,
        "justification": "Hub-like Modularization requires an abstraction to have many incoming AND many outgoing dependencies. The analyzed class has outgoing dependencies to 13 distinct abstractions (e.g., com.github.javaparser.resolution.model.SymbolReference, com.github.javaparser.ast.body.TypeDeclaration, com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade, com.github.javaparser.resolution.types.ResolvedType, com.github.javaparser.resolution.TypeSolver, com.github.javaparser.ast.body.ClassOrInterfaceDeclaration, com.github.javaparser.resolution.Navigator, com.github.javaparser.ParseException, com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration, com.github.javaparser.ast.Node, com.github.javaparser.ast.CompilationUnit, com.github.javaparser.StaticJavaParser, com.github.javaparser.ast.expr.MethodCallExpr) but has zero incoming dependencies (incoming_dependencies is empty). Because it lacks incoming dependencies, it does not meet the definition of a hub."
    },
    {
        "identifier": "com.github.javaparser.resolution.MethodAmbiguityException",
        "detection": false,
        "justification": "The class has 0 incoming dependencies and 0 outgoing dependencies (incoming_dependencies and outgoing_dependencies are empty). Hub-like Modularization requires many incoming and outgoing connections; with counts of 0 and 0 this class does not exhibit the smell."
    },
    {
        "identifier": "com.github.javaparser.ast.stmt.DoStmt",
        "detection": true,
        "justification": "DoStmt exhibits hub-like modularization: it has a large number of distinct incoming dependencies (24 different classes reference DoStmt, e.g. com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.ast.visitor.HashCodeVisitor, com.github.javaparser.ast.visitor.EqualsVisitor, com.github.javaparser.ast.visitor.CloneVisitor, com.github.javaparser.printer.PrettyPrintVisitor, com.github.javaparser.GeneratedJavaParser, com.github.javaparser.symbolsolver.javaparsermodel.DefaultVisitorAdapter, com.github.javaparser.symbolsolver.javaparsermodel.NormalCompletionVisitor, com.github.javaparser.symbolsolver.javaparsermodel.contexts.DoStatementContext, com.github.javaparser.symbolsolver.resolution.typeinference.ControlFlowLogic, com.github.javaparser.ast.stmt.Statement, etc.). It also has multiple outgoing dependencies to many core abstractions (10 distinct outgoing dependencies including com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.stmt.Statement, com.github.javaparser.Range, com.github.javaparser.ast.expr.Expression, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.TokenRange, com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.ast.Node, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.metamodel.DoStmtMetaModel). The combination of many incoming callers (various visitors, printers, parsers, symbol solver contexts) and multiple outgoing ties to core AST/meta-model types indicates DoStmt acts as a hub between many abstractions, satisfying the Hub-like Modularization smell."
    },
    {
        "identifier": "com.github.javaparser.ast.nodeTypes.modifiers.NodeWithAccessModifiers",
        "detection": false,
        "justification": "Hub-like Modularization requires an abstraction to have dependencies (incoming and outgoing) with a large number of other abstractions. This class has 0 outgoing dependencies and 0 incoming dependencies (both empty), so it does not exhibit hub-like modularization."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.JavaSymbolSolver",
        "detection": false,
        "justification": "JavaSymbolSolver has a large number of outgoing dependencies (28 distinct abstractions, e.g. com.github.javaparser.resolution.declarations.ResolvedEnumConstantDeclaration, com.github.javaparser.ast.body.TypeDeclaration, com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserVariableDeclaration, com.github.javaparser.resolution.TypeSolver, com.github.javaparser.ast.expr.Expression, com.github.javaparser.symbolsolver.JavaSymbolSolver.ArrayLengthValueDeclaration, com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade, com.github.javaparser.resolution.types.ResolvedType, com.github.javaparser.ast.Node, com.github.javaparser.ast.CompilationUnit, com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFactory), but only a single incoming dependency is present (com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade). The hub-like modularization smell requires an abstraction to have many incoming and many outgoing relationships; here the incoming connections are minimal (1), so the class does not meet the full criteria for a hub."
    },
    {
        "identifier": "com.github.javaparser.printer.configuration.imports.DefaultImportOrderingStrategy",
        "detection": false,
        "justification": "DefaultImportOrderingStrategy has a single outgoing dependency: com.github.javaparser.ast.NodeList. It has a single incoming dependent class in the provided data: com.github.javaparser.printer.DefaultPrettyPrinterVisitor (which references DefaultImportOrderingStrategy among many other types). Because there is only one distinct incoming class and one outgoing dependency listed, the class does not exhibit hub-like modularization (it does not have both many incoming and many outgoing relationships)."
    },
    {
        "identifier": "com.github.javaparser.metamodel.ImportDeclarationMetaModel",
        "detection": false,
        "justification": "ImportDeclarationMetaModel has only 1 outgoing dependency (com.github.javaparser.metamodel.PropertyMetaModel) and 2 incoming dependents (com.github.javaparser.ast.ImportDeclaration and com.github.javaparser.metamodel.JavaParserMetaModel). These counts do not constitute dependencies with a large number of other abstractions, so it does not exhibit Hub-like Modularization. (Although JavaParserMetaModel references many meta models, that reflects the caller's breadth, not a large number of direct incoming/outgoing links for ImportDeclarationMetaModel itself.)"
    },
    {
        "identifier": "box.Foo",
        "detection": false,
        "justification": "No evidence of hub-like modularization: analyzed_package.dependencies = [], outgoing_dependencies = [], incoming_dependencies = []. The class has neither incoming nor outgoing dependencies with other abstractions, so it cannot be a hub."
    },
    {
        "identifier": "com.github.javaparser.metamodel.MarkerAnnotationExprMetaModel",
        "detection": false,
        "justification": "MarkerAnnotationExprMetaModel has no outgoing dependencies (dependencies: []). It has only two incoming dependents: com.github.javaparser.ast.expr.MarkerAnnotationExpr and com.github.javaparser.metamodel.JavaParserMetaModel. Although JavaParserMetaModel lists many dependencies (including MarkerAnnotationExprMetaModel), the analyzed class itself does not have a large number of both incoming and outgoing relationships required for Hub-like Modularization. Therefore the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.metamodel.ClassOrInterfaceTypeMetaModel",
        "detection": false,
        "justification": "ClassOrInterfaceTypeMetaModel has only 1 outgoing dependency (com.github.javaparser.metamodel.PropertyMetaModel) and 2 incoming dependencies (com.github.javaparser.ast.type.ClassOrInterfaceType and com.github.javaparser.metamodel.JavaParserMetaModel). A hub-like modularization requires an abstraction to have incoming and outgoing relationships with a large number of other abstractions. Although JavaParserMetaModel itself depends on many meta-model classes (including ClassOrInterfaceTypeMetaModel), ClassOrInterfaceTypeMetaModel does not exhibit a large number of both incoming and outgoing dependencies, so the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.ast.expr.LiteralStringValueExpr",
        "detection": false,
        "justification": "LiteralStringValueExpr has a small number of outgoing dependencies (4: com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.metamodel.LiteralStringValueExprMetaModel, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.TokenRange) and a small number of incoming dependents (3: com.github.javaparser.ast.expr.Expression, com.github.javaparser.ast.validator.language_level_validations.chunks.NoUnderscoresInIntegerLiteralsValidator, com.github.javaparser.ast.validator.language_level_validations.chunks.NoBinaryIntegerLiteralsValidator). The total set of directly connected abstractions (7 unique classes) is not a large number, so it does not meet the Hub-like Modularization smell criteria."
    },
    {
        "identifier": "issue1945.interfaces.HairyAnimal",
        "detection": false,
        "justification": "HairyAnimal has 3 incoming dependencies (issue1945.implementations.WoolRenderer, issue1945.main.MainIssue1945, issue1945.interfaces.HairTypeRenderer) and 1 outgoing dependency (issue1945.interfaces.HairType). The total number of distinct incoming/outgoing relationships is small, so it does not exhibit hub-like modularization (no large number of incoming and outgoing dependencies)."
    },
    {
        "identifier": "com.github.javaparser.resolution.types.ResolvedReferenceType",
        "detection": true,
        "justification": "ResolvedReferenceType has a large number of incoming dependencies (29 distinct callers) and a substantial number of outgoing dependencies (10 distinct targets). Incoming examples include: ReflectionClassDeclaration, ReflectionFactory, ReflectionRecordDeclaration, ReflectionTypeParameter, ObjectProvider, AbstractClassDeclaration, NormalCompletionVisitor, JavaParserTypeParameter, JavaParserAnonymousClassDeclaration, JavaParserEnumDeclaration, JavaParserRecordDeclaration, JavaParserClassDeclaration, JavaParserInterfaceDeclaration, FieldAccessContext, MethodCallExprContext, BoundSet, LeastUpperBoundLogic, TypeHelper, JavassistInterfaceDeclaration, JavassistRecordDeclaration, JavassistClassDeclaration, JavassistTypeParameter, ResolvedTypeParameterDeclaration, LazyType, ReferenceTypeImpl, ResolvedType, InferenceContext, InferenceVariableType, MethodResolutionLogic. Outgoing dependencies include: com.github.javaparser.resolution.types.parametrization.ResolvedTypeParametersMap, ResolvedTypeTransformer, ResolvedTypeVariable, com.github.javaparser.resolution.model.typesystem.LazyType, ResolvedType, ResolvedTypeParameterDeclaration, ResolvedReferenceTypeDeclaration, ResolvedPrimitiveType, ResolvedWildcard, and com.github.javaparser.ast.AccessSpecifier. The class therefore acts as a central hub connecting many abstractions in both directions, which matches the Hub-like Modularization smell."
    },
    {
        "identifier": "com.github.javaparser.TestFile",
        "detection": false,
        "justification": "incoming_dependencies is empty (0 incoming) and outgoing_dependencies is empty (0 outgoing). Hub-like Modularization requires a large number of both incoming and outgoing dependencies; with 0 incoming and 0 outgoing, this class does not exhibit the smell."
    },
    {
        "identifier": "com.github.javaparser.ast.Node.ParentsVisitor",
        "detection": false,
        "justification": "ParentsVisitor has a single outgoing dependency: com.github.javaparser.ast.Node (dependencies list contains only that entry) and it has no incoming dependencies (incoming_dependencies is empty). The Hub-like Modularization smell requires an abstraction to have dependencies both incoming and outgoing with a large number of other abstractions. While the provided outgoing_dependencies show many dependencies for class Node, those belong to com.github.javaparser.ast.Node, not to Node.ParentsVisitor. Therefore, Node.ParentsVisitor does not exhibit hub-like modularization."
    },
    {
        "identifier": "japa.bdd.samples.JavaConcepts.Teste",
        "detection": false,
        "justification": "Hub-like Modularization requires an abstraction to have many incoming and outgoing dependencies. This class has incoming_dependencies = [] (0) and outgoing_dependencies = [] (0), so it has no incoming or outgoing relationships and does not meet the hub-like criteria."
    },
    {
        "identifier": "com.github.javaparser.resolution.promotion.ConditionalExprHandler",
        "detection": false,
        "justification": "ConditionalExprHandler has a small number of direct relationships: only one outgoing dependency (com.github.javaparser.resolution.types.ResolvedType) and two incoming dependents (com.github.javaparser.symbolsolver.javaparsermodel.TypeExtractor and com.github.javaparser.symbolsolver.resolution.promotion.ConditionalExprResolver). Although ResolvedType itself depends on many types, ConditionalExprHandler does not directly depend on those abstractions. Because the class does not exhibit a large number of both incoming and outgoing direct dependencies, it does not meet the Hub-like Modularization smell criteria."
    },
    {
        "identifier": "a.RefCycleClass",
        "detection": false,
        "justification": "RefCycleClass has only one outgoing dependency (a.RefCycleEnum) and zero incoming dependencies. Hub-like Modularization requires many incoming and outgoing dependencies; this class does not meet that criterion."
    },
    {
        "identifier": "com.github.javaparser.ast.nodeTypes.modifiers.NodeWithPrivateModifier",
        "detection": false,
        "justification": "The class has no incoming dependencies (incoming_dependencies is empty) and no outgoing dependencies (outgoing_dependencies is empty). Hub-like Modularization requires an abstraction to have many incoming and outgoing dependencies; since both are absent for this class, it is not a hub."
    },
    {
        "identifier": "com.github.javaparser.printer.lexicalpreservation.LexicalDifferenceCalculator.CalculatedSyntaxModel",
        "detection": false,
        "justification": "Not a hub: the class has no outgoing dependencies (outgoing_dependencies = []). It has incoming dependency from a single class (com.github.javaparser.printer.lexicalpreservation.LexicalDifferenceCalculator) only. Because it does not have both many incoming and many outgoing connections to other abstractions, it does not exhibit Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.logic.AbstractTypeDeclaration",
        "detection": false,
        "justification": "AbstractTypeDeclaration is referenced by a relatively large number of other abstractions (6 incoming): com.github.javaparser.symbolsolver.reflectionmodel.ReflectionMethodDeclaration, ReflectionClassDeclaration, ReflectionFactory, ReflectionEnumDeclaration, ReflectionRecordDeclaration, and ReflectionConstructorDeclaration. However, it has only a single outgoing dependency in the provided data: com.github.javaparser.resolution.MethodUsage (1 outgoing). The Hub-like Modularization smell requires an abstraction to have many incoming and many outgoing dependencies. Because AbstractTypeDeclaration shows many incoming but only one outgoing dependency (incoming = 6, outgoing = 1), it does not meet the 'both many incoming and many outgoing' criterion and therefore is not detected as a hub."
    },
    {
        "identifier": "com.github.javaparser.ast.validator.postprocessors.Java13PostProcessor",
        "detection": false,
        "justification": "The class has no incoming or outgoing dependencies (incoming_dependencies = 0, outgoing_dependencies = 0), so it does not depend on or is depended upon by a large number of other abstractions and therefore is not a hub."
    },
    {
        "identifier": "com.github.javaparser.ast.expr.TypeExpr",
        "detection": true,
        "justification": "TypeExpr has a substantial number of incoming and outgoing relationships in the provided data: 23 distinct incoming dependents (examples: com.github.javaparser.symbolsolver.javaparsermodel.DefaultVisitorAdapter, com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade, com.github.javaparser.symbolsolver.javaparsermodel.TypeExtractor, many visitor classes such as com.github.javaparser.ast.visitor.VoidVisitor, GenericVisitor, HashCodeVisitor, PrettyPrintVisitor, CloneVisitor, etc., plus core classes like com.github.javaparser.ast.expr.Expression and com.github.javaparser.GeneratedJavaParser) and 9 outgoing dependencies (com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.TokenRange, com.github.javaparser.metamodel.TypeExprMetaModel, com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.ast.type.Type, com.github.javaparser.ast.Node, com.github.javaparser.Range). Because the abstraction both depends on multiple other abstractions and is depended upon by a large and diverse set of other classes (notably many visitors and core components), it functions as a hub and therefore exhibits the Hub-like Modularization smell."
    },
    {
        "identifier": "com.github.javaparser.ast.expr.Name",
        "detection": true,
        "justification": "The class has a large number of incoming dependencies from many distinct abstractions (dozens) across visitors, AST nodes, printers, validators and modules — e.g. com.github.javaparser.ast.visitor.VoidVisitor, GenericVisitor, HashCodeVisitor, EqualsVisitor, VoidVisitorAdapter, ModifierVisitor, PrettyPrintVisitor, DefaultPrettyPrinterVisitor, many AST node classes (CompilationUnit, PackageDeclaration, ImportDeclaration, ModuleDeclaration, Module*Directive, AnnotationExpr, ThisExpr, SuperExpr, etc.), validators (ReservedKeywordValidator, RecordAsTypeIdentifierNotAllowed), parsers/adapters (StaticJavaParser, GeneratedJavaParser, GeneratedJavaParserBase), and others. At the same time it has outgoing dependencies to multiple core abstractions (8 listed) such as com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.ast.Node, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.metamodel.NameMetaModel, com.github.javaparser.TokenRange, com.github.javaparser.ast.observer.ObservableProperty and com.github.javaparser.utils.Utils. Because Name both depends on several core components and is depended-on by a very large and diverse set of other classes, it functions as a hub and exhibits the Hub-like Modularization smell."
    },
    {
        "identifier": "com.github.javaparser.javasymbolsolver.javassist_symbols.excluded_jar.InterfaceExcludedJar",
        "detection": false,
        "justification": "The class has 0 incoming dependencies and 0 outgoing dependencies (incoming_dependencies = [], outgoing_dependencies = []), so it does not have dependencies with a large number of other abstractions and therefore is not a hub-like module."
    },
    {
        "identifier": "com.github.javaparser.printer.lexicalpreservation.TextElementIteratorsFactory",
        "detection": false,
        "justification": "TextElementIteratorsFactory has 4 outgoing dependencies (TextElement, NodeText, ChildTextElement, TextElementIteratorsFactory.Provider) and only 1 incoming dependency (LexicalPreservingPrinter). The number of distinct incoming and outgoing connections is small, so it does not meet the criterion for Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.testpackage.TestClass",
        "detection": false,
        "justification": "The class has no incoming or outgoing dependencies (incoming_dependencies = [], outgoing_dependencies = []; analyzed_package.dependencies = []). Hub-like Modularization requires an abstraction to have dependencies both incoming and outgoing with a large number of other abstractions; with zero dependencies this class does not meet that criterion."
    },
    {
        "identifier": "com.github.javaparser.ast.type.VoidType",
        "detection": true,
        "justification": "VoidType has many incoming dependencies (referenced by ~23 distinct classes) — e.g. numerous visitor and utility classes such as com.github.javaparser.symbolsolver.javaparsermodel.DefaultVisitorAdapter, JavaParserFacade, TypeExtractor, com.github.javaparser.ast.type.Type, com.github.javaparser.ast.visitor.VoidVisitor, HashCodeVisitor, PrettyPrintVisitor, DefaultPrettyPrinterVisitor, ModifierVisitor, CloneVisitor, NodeFinderVisitor, and many Generic/Void visitor variants. It also has multiple outgoing dependencies (10 distinct abstractions) including com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.resolution.Context, com.github.javaparser.resolution.types.ResolvedType, com.github.javaparser.metamodel.VoidTypeMetaModel, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.ast.NodeList, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.TokenRange, com.github.javaparser.Range, and com.github.javaparser.resolution.types.ResolvedVoidType. Because VoidType both depends on a non-trivial set of other abstractions and is depended upon by a large number of other abstractions across multiple packages (especially many visitor/processor classes), it matches the Hub-like Modularization smell."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.reflectionmodel.ReflectionEnumConstantDeclaration",
        "detection": false,
        "justification": "Not detected: the class has outgoing dependencies to 4 other abstractions (com.github.javaparser.resolution.TypeSolver, com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration, com.github.javaparser.symbolsolver.reflectionmodel.ReflectionEnumDeclaration, com.github.javaparser.resolution.types.ResolvedType) but has no incoming dependencies (incoming count = 0). Hub-like modularization requires an abstraction to have many both incoming and outgoing dependencies; here the absence of incoming dependencies prevents this class from being a hub."
    },
    {
        "identifier": "com.github.javaparser.metamodel.ExpressionStmtMetaModel",
        "detection": false,
        "justification": "ExpressionStmtMetaModel has only 1 outgoing dependency (com.github.javaparser.metamodel.PropertyMetaModel) and only 2 incoming dependents (com.github.javaparser.ast.stmt.ExpressionStmt and com.github.javaparser.metamodel.JavaParserMetaModel). The total number of direct incoming/outgoing relationships is small (3 distinct other abstractions), so it does not meet the 'large number of other abstractions' criterion for Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.ast.validator.SimpleValidator",
        "detection": false,
        "justification": "Both incoming_dependencies and outgoing_dependencies are empty (0 incoming, 0 outgoing). Hub-like Modularization requires an abstraction to have dependencies with a large number of other abstractions; this class has no incoming or outgoing dependencies, so it is not a hub."
    },
    {
        "identifier": "com.github.javaparser.resolution.declarations.ResolvedEnumConstantDeclaration",
        "detection": false,
        "justification": "ResolvedEnumConstantDeclaration has multiple incoming dependencies (5 distinct dependents: com.github.javaparser.symbolsolver.JavaSymbolSolver, com.github.javaparser.symbolsolver.reflectionmodel.ReflectionEnumDeclaration, com.github.javaparser.ast.body.EnumConstantDeclaration, com.github.javaparser.resolution.declarations.ResolvedEnumDeclaration, com.github.javaparser.resolution.declarations.ResolvedDeclaration) but has no outgoing dependencies (outgoing_dependencies = []). Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; here outgoing count is zero, so the hub-like smell is not present."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.resolution.typesolvers.JarTypeSolver",
        "detection": false,
        "justification": "JarTypeSolver has outgoing dependencies to 6 distinct abstractions (SymbolReference, JavassistModuleHelper, TypeSolver, JavassistFactory, UnsolvedSymbolException, ResolvedReferenceTypeDeclaration) but only 2 incoming dependents (TypeSolverBuilder, AarTypeSolver). Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; here the incoming dependency count is low (2), so it does not qualify as a hub."
    },
    {
        "identifier": "com.github.javaparser.ast.body.AnnotationDeclaration",
        "detection": true,
        "justification": "AnnotationDeclaration has a large number of incoming and outgoing dependencies. Incoming: 26 distinct classes depend on it (examples: com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.ast.visitor.ModifierVisitor, com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade, com.github.javaparser.printer.PrettyPrintVisitor, com.github.javaparser.GeneratedJavaParser, com.github.javaparser.ast.CompilationUnit, com.github.javaparser.ast.body.BodyDeclaration, com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserAnnotationDeclaration). Outgoing: it depends on 13 distinct abstractions (examples: com.github.javaparser.ast.NodeList, com.github.javaparser.ast.Modifier, com.github.javaparser.ast.expr.SimpleName, com.github.javaparser.ast.type.Type, com.github.javaparser.ast.comments.JavadocComment, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.TokenRange, com.github.javaparser.Range, com.github.javaparser.resolution.declarations.ResolvedAnnotationDeclaration, com.github.javaparser.ast.body.FieldDeclaration, com.github.javaparser.metamodel.AnnotationDeclarationMetaModel). The presence of many incoming visitor/parser/printer classes plus many outgoing links across unrelated concerns (visitor APIs, metamodel, token/range, resolution, comments, types, fields) indicates AnnotationDeclaration functions as a hub-like abstraction."
    },
    {
        "identifier": "issue241.TypeWithMemberType",
        "detection": false,
        "justification": "No incoming or outgoing dependencies found (incoming_dependencies = [], outgoing_dependencies = []). Hub-like Modularization requires an abstraction to have dependencies with a large number of other abstractions, which is not the case here."
    },
    {
        "identifier": "com.github.javaparser.resolution.UnsolvedSymbolException",
        "detection": false,
        "justification": "Not detected as Hub-like Modularization: the class has 0 outgoing dependencies and only 3 incoming dependents (JarTypeSolver, CombinedTypeSolver, TypeSolver). Hub-like modularization requires an abstraction to have dependencies both incoming and outgoing with a large number of other abstractions. Here outgoing_dependencies = [] and incoming_dependencies count = 3 (each of JarTypeSolver, CombinedTypeSolver, and TypeSolver list com.github.javaparser.resolution.UnsolvedSymbolException in their dependency lists), which is insufficient to classify it as a hub."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.resolution.typesolvers.TypeSolverBuilder",
        "detection": false,
        "justification": "TypeSolverBuilder has multiple outgoing dependencies (6): com.github.javaparser.resolution.TypeSolver, JavaParserTypeSolver, ReflectionTypeSolver, AarTypeSolver, ClassLoaderTypeSolver, JarTypeSolver, but it has zero incoming dependencies. Hub-like Modularization requires an abstraction to have dependencies both incoming and outgoing with a large number of other abstractions. The absence of incoming dependencies prevents this class from being a hub."
    },
    {
        "identifier": "main.Parent.ParentNested",
        "detection": false,
        "justification": "The class has 0 incoming dependencies and 0 outgoing dependencies (incoming_dependencies and outgoing_dependencies are empty), so it does not have dependencies with a large number of other abstractions and is not a hub."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.contexts.ClassOrInterfaceDeclarationContext",
        "detection": false,
        "justification": "Hub-like Modularization requires an abstraction to have dependencies both incoming and outgoing with a large number of other abstractions. The analyzed class has outgoing dependencies to 8 distinct abstractions: com.github.javaparser.resolution.model.SymbolReference, com.github.javaparser.symbolsolver.javaparsermodel.contexts.JavaParserTypeDeclarationAdapter, com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade, com.github.javaparser.resolution.TypeSolver, com.github.javaparser.ast.body.ClassOrInterfaceDeclaration, com.github.javaparser.ast.Node, com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration, and com.github.javaparser.resolution.model.Value. However, it has zero incoming dependencies (incoming_dependencies is empty). Because it lacks incoming dependencies, it does not exhibit the bidirectional, high-degree coupling characteristic of a hub, so the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javassistmodel.JavassistInterfaceDeclaration",
        "detection": false,
        "justification": "Outgoing (fan-out) = 12 distinct dependencies: com.github.javaparser.resolution.Context, com.github.javaparser.resolution.model.SymbolReference, com.github.javaparser.ast.AccessSpecifier, com.github.javaparser.resolution.types.ResolvedType, com.github.javaparser.resolution.TypeSolver, com.github.javaparser.resolution.declarations.ResolvedInterfaceDeclaration, com.github.javaparser.symbolsolver.javassistmodel.JavassistFactory, com.github.javaparser.symbolsolver.javassistmodel.JavassistUtils, com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration, com.github.javaparser.symbolsolver.javassistmodel.JavassistClassDeclaration, com.github.javaparser.resolution.types.ResolvedReferenceType, com.github.javaparser.symbolsolver.javassistmodel.JavassistTypeDeclarationAdapter. Incoming (fan-in) = 2 distinct dependents: com.github.javaparser.symbolsolver.javassistmodel.JavassistUtils and com.github.javaparser.symbolsolver.javassistmodel.JavassistClassDeclaration. Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; while fan-out is relatively large, fan-in is small (only 2), so the class does not meet the definition of a hub in the provided data."
    },
    {
        "identifier": "com.github.javaparser.generator.core.node.GetMetaModelGenerator",
        "detection": false,
        "justification": "Not detected: the class has no incoming dependencies (incoming_dependencies is empty) and only six outgoing dependencies (StaticJavaParser, BaseNodeMetaModel, CompilationUnit, ClassOrInterfaceDeclaration, MethodDeclaration, SourceRoot). Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing relationships; this class lacks incoming links and the number of outgoing connections is not sufficiently large to qualify as a hub."
    },
    {
        "identifier": "(default package).ConvolutionLayer.Builder",
        "detection": false,
        "justification": "No incoming or outgoing dependencies: incoming_dependencies = [], outgoing_dependencies = []. Hub-like Modularization requires an abstraction to have dependencies (both incoming and outgoing) with a large number of other abstractions; with zero dependencies this class does not exhibit the smell."
    },
    {
        "identifier": "com.github.javaparser.ast.Node.ObserverRegistrationMode",
        "detection": false,
        "justification": "The class com.github.javaparser.ast.Node.ObserverRegistrationMode has 0 outgoing dependencies and only 1 incoming dependent (com.github.javaparser.ast.Node). Although that incoming class (Node) references many types (24 different dependencies), the analyzed class itself does not have a large number of incoming and outgoing connections. Hub-like Modularization requires an abstraction to have many incoming and outgoing dependencies; this class does not meet that criterion."
    },
    {
        "identifier": "com.github.javaparser.javasymbolsolver.javassist_symbols.main_jar.InterfaceUserOwnJar",
        "detection": false,
        "justification": "The class has 0 incoming dependencies and 0 outgoing dependencies. Hub-like Modularization requires an abstraction to have many incoming and outgoing dependencies; since both counts are zero, the smell is not present."
    },
    {
        "identifier": "com.github.javaparser.metamodel.TryStmtMetaModel",
        "detection": false,
        "justification": "TryStmtMetaModel has only one outgoing dependency (com.github.javaparser.metamodel.PropertyMetaModel) and only two incoming dependencies (com.github.javaparser.ast.stmt.TryStmt and com.github.javaparser.metamodel.JavaParserMetaModel). Total incoming = 2, outgoing = 1, which is a low-degree interaction and does not constitute a hub (no large number of both incoming and outgoing dependencies). Although JavaParserMetaModel itself references many meta-models (including TryStmtMetaModel), TryStmtMetaModel in isolation does not have many incoming/outgoing links, so Hub-like Modularization is not detected."
    },
    {
        "identifier": "(default package).ComponentBase",
        "detection": false,
        "justification": "ComponentBase has 0 outgoing dependencies and 0 incoming dependencies (both outgoing_dependencies and incoming_dependencies arrays are empty), so it does not interact with a large number of other abstractions and therefore does not exhibit Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.printer.configuration.imports.EclipseImportOrderingStrategy",
        "detection": false,
        "justification": "Hub-like modularization requires an abstraction to have many incoming and outgoing dependencies. EclipseImportOrderingStrategy has 0 incoming dependencies and only 1 outgoing dependency (com.github.javaparser.ast.NodeList). Although NodeList itself depends on four other abstractions, those are dependencies of NodeList, not direct incoming/outgoing relations of EclipseImportOrderingStrategy. Therefore it is not a hub-like modularization."
    },
    {
        "identifier": "com.github.javaparser.printer.lexicalpreservation.PeekingIterator",
        "detection": false,
        "justification": "PeekingIterator is not a hub: it has 0 outgoing dependencies and only 1 incoming dependency (com.github.javaparser.printer.lexicalpreservation.ReshuffledDiffElementExtractor). Hub-like Modularization requires an abstraction to have both incoming and outgoing dependencies with a large number of other abstractions; PeekingIterator does not meet this (incoming count = 1, outgoing count = 0)."
    },
    {
        "identifier": "com.github.javaparser.ast.body.CallableDeclaration.Signature",
        "detection": false,
        "justification": "CallableDeclaration.Signature has 0 outgoing dependencies (dependencies list is empty) and only 1 incoming dependency (from com.github.javaparser.ast.body.CallableDeclaration). A hub-like modularization requires an abstraction to have dependencies both incoming and outgoing with a large number of other abstractions; this class does not meet that criteria."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.contexts.VariableDeclarationExprContext",
        "detection": false,
        "justification": "Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies. The analyzed class has 0 incoming dependencies and 3 outgoing dependencies: com.github.javaparser.resolution.TypeSolver (outgoing deps: 3), com.github.javaparser.ast.expr.VariableDeclarationExpr (outgoing deps: 12), and com.github.javaparser.ast.Node (outgoing deps: 24). Because there are no incoming dependencies and the incoming degree is zero, the class does not meet the requirement of having many dependencies in both directions and therefore is not a hub."
    },
    {
        "identifier": "com.github.javaparser.resolution.declarations.ResolvedDeclaration",
        "detection": false,
        "justification": "ResolvedDeclaration has outgoing dependencies to 6 other abstractions: com.github.javaparser.resolution.declarations.ResolvedFieldDeclaration, com.github.javaparser.resolution.declarations.ResolvedParameterDeclaration, com.github.javaparser.resolution.declarations.ResolvedEnumConstantDeclaration, com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration, com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration, com.github.javaparser.resolution.declarations.ResolvedTypePatternDeclaration. It has 0 incoming dependencies. Hub-like Modularization requires an abstraction to have many incoming and outgoing dependencies; because incoming dependencies are absent (0), ResolvedDeclaration does not qualify as a hub. (Note: some of its outgoing targets themselves depend on additional types, e.g., ResolvedTypeDeclaration depends on several declarations and ResolvedMethodDeclaration depends on ResolvedType, but those do not create incoming edges to ResolvedDeclaration.)"
    },
    {
        "identifier": "com.github.javaparser.ast.Node.BreadthFirstIterator",
        "detection": false,
        "justification": "The class has no incoming or outgoing dependencies (dependencies = [], outgoing_dependencies = [], incoming_dependencies = []). Hub-like Modularization requires an abstraction to have dependencies both incoming and outgoing with a large number of other abstractions; here incoming count = 0 and outgoing count = 0, so the smell is not present."
    },
    {
        "identifier": "com.github.javaparser.ast.nodeTypes.NodeWithTraversableScope",
        "detection": false,
        "justification": "The class has no incoming dependencies and no outgoing dependencies (incoming_dependencies = [], outgoing_dependencies = []). Since Hub-like Modularization requires an abstraction to have dependencies with a large number of other abstractions in both directions, this class does not exhibit the smell."
    },
    {
        "identifier": "com.github.javaparser.ast.nodeTypes.NodeWithStatements",
        "detection": false,
        "justification": "Outgoing dependencies are limited (5): com.github.javaparser.ast.stmt.ExpressionStmt, com.github.javaparser.ast.stmt.Statement, com.github.javaparser.ast.expr.Expression, com.github.javaparser.ast.NodeList, com.github.javaparser.StaticJavaParser. Incoming dependencies are minimal (1): com.github.javaparser.symbolsolver.javaparsermodel.contexts.StatementContext. Hub-like Modularization is characterized by an abstraction having many incoming and outgoing dependencies; NodeWithStatements shows only a small, domain-coherent set of connections, so it is not a hub."
    },
    {
        "identifier": "com.github.javaparser.printer.configuration.ImportOrderingStrategy",
        "detection": false,
        "justification": "ImportOrderingStrategy has only one direct outgoing dependency (com.github.javaparser.ast.NodeList) and only one incoming dependent class (com.github.javaparser.printer.DefaultPrettyPrinterVisitor). Although the incoming class and the outgoing NodeList themselves reference many other types, ImportOrderingStrategy itself does not have a large number of distinct incoming and outgoing dependencies, so it does not meet the Hub-like Modularization smell criteria."
    },
    {
        "identifier": "com.github.javaparser.printer.DefaultPrettyPrinterVisitor",
        "detection": false,
        "justification": "Hub-like Modularization requires an abstraction to have dependencies both incoming and outgoing with a large number of other abstractions. DefaultPrettyPrinterVisitor has a large number of outgoing dependencies (117 distinct outgoing dependencies, e.g. com.github.javaparser.ast.Node, com.github.javaparser.ast.expr.Expression, com.github.javaparser.printer.SourcePrinter, com.github.javaparser.printer.configuration.PrinterConfiguration, com.github.javaparser.ast.body.MethodDeclaration), but it has 0 incoming dependencies in the provided data. Because the incoming dependency count is zero, the condition of having both many incoming and many outgoing dependencies is not met, so the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.javasymbolsolver.javassist_symbols.main_jar.SubInterfaceExcludedJar",
        "detection": false,
        "justification": "Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies. This class has no incoming dependencies (incoming_dependencies: []) and no outgoing dependencies (outgoing_dependencies: []), so it does not meet the criteria."
    },
    {
        "identifier": "com.packageName.ClassInPackage",
        "detection": false,
        "justification": "Not detected: the class has only 1 incoming dependency ((default package).PackageDotExpressions) and 0 outgoing dependencies. Hub-like Modularization requires an abstraction to have many incoming and outgoing dependencies; this class has minimal incoming and no outgoing dependencies."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserInterfaceDeclaration",
        "detection": false,
        "justification": "The class has many outgoing dependencies (18 unique dependencies, e.g. com.github.javaparser.resolution.TypeSolver, com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade, com.github.javaparser.resolution.types.ResolvedType, com.github.javaparser.ast.Node, com.github.javaparser.symbolsolver.javaparsermodel.declarations.AstResolutionUtils), but it has no incoming dependencies (incoming_dependencies: 0). Hub-like Modularization requires a large number of both incoming and outgoing relationships; the absence of incoming dependencies means this class does not meet the hub-like criterion."
    },
    {
        "identifier": "com.github.javaparser.ast.nodeTypes.NodeWithExpression",
        "detection": false,
        "justification": "NodeWithExpression has no incoming dependencies (incoming_dependencies = []), and only two direct outgoing dependencies (StaticJavaParser and Expression). Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing relationships. Although the two depended-on classes (StaticJavaParser and Expression) themselves reference many other types, NodeWithExpression itself does not exhibit a large number of incoming or outgoing dependencies, so it is not a hub."
    },
    {
        "identifier": "com.github.javaparser.printer.DefaultPrettyPrinter",
        "detection": false,
        "justification": "DefaultPrettyPrinter has a small number of direct outgoing dependencies (4: com.github.javaparser.printer.Printer, com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.printer.configuration.PrinterConfiguration, com.github.javaparser.ast.Node) and a single incoming dependency (1: com.github.javaparser.generator.metamodel.MetaModelGenerator). Although some of those target types (notably VoidVisitor and Node) themselves reference many other abstractions, the provided data shows DefaultPrettyPrinter does not directly depend on a large number of different abstractions. Therefore it does not meet the definition of a hub-like modularization (which requires many incoming and outgoing relationships)."
    },
    {
        "identifier": "com.github.javaparser.ast.nodeTypes.NodeWithSimpleName",
        "detection": false,
        "justification": "NodeWithSimpleName is not a hub. Incoming dependencies are empty (no classes depend on it) and it has only three direct outgoing dependencies: com.github.javaparser.ast.expr.NameExpr, com.github.javaparser.ast.expr.SimpleName, and com.github.javaparser.utils.Utils. Hub-like Modularization requires many incoming and outgoing links; these counts are low. (Although the outgoing targets themselves have many dependencies, that does not make NodeWithSimpleName a hub because it lacks numerous direct incoming/outgoing relationships.)"
    },
    {
        "identifier": "com.github.javaparser.ast.stmt.ExpressionStmt",
        "detection": true,
        "justification": "ExpressionStmt has a high number of incoming dependencies (25 distinct clients in the provided data) including many visitor and printer classes (examples: com.github.javaparser.ast.visitor.VoidVisitor, GenericVisitor, HashCodeVisitor, EqualsVisitor, VoidVisitorAdapter, PrettyPrintVisitor, DefaultPrettyPrinterVisitor, GeneratedJavaParser). It also has multiple outgoing dependencies (9) to core/metamodel and AST types (examples: com.github.javaparser.ast.expr.Expression, com.github.javaparser.ast.Node, com.github.javaparser.TokenRange, com.github.javaparser.Range, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.metamodel.ExpressionStmtMetaModel, com.github.javaparser.ast.observer.ObservableProperty). The combination of many incoming connectors across different subsystems (visitors, printers, symbol solver, parsers) and several outgoing connections to fundamental AST and meta-model abstractions indicates ExpressionStmt acts as a hub-like abstraction."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.contexts.BinaryExprContext",
        "detection": false,
        "justification": "BinaryExprContext has outgoing dependencies to 5 distinct abstractions (PatternVariableResult, TypeSolver, PatternVariableVisitor, Node, BinaryExpr) but has zero incoming dependencies. Hub-like Modularization requires an abstraction to have both many incoming and many outgoing dependencies. Because there are no incoming dependencies in the provided data, BinaryExprContext is not a hub-like module."
    },
    {
        "identifier": "(default package).B.innerClassInB",
        "detection": false,
        "justification": "No hub-like modularization: incoming_dependencies = 0, outgoing_dependencies = 0. A hub requires many incoming and outgoing dependencies; this class has none."
    },
    {
        "identifier": "com.github.javaparser.ast.validator.language_level_validations.chunks.UnderscoreKeywordValidator",
        "detection": false,
        "justification": "The class has 0 incoming dependencies (incoming_dependencies is empty) and only 4 outgoing dependencies: com.github.javaparser.ast.expr.Name, com.github.javaparser.ast.validator.ProblemReporter, com.github.javaparser.ast.Node, and com.github.javaparser.ast.expr.SimpleName. Hub-like Modularization requires an abstraction to have both many incoming and many outgoing relationships. Because there are no incoming dependencies and the outgoing count is small, this class does not meet the hub-like criteria."
    },
    {
        "identifier": "com.github.javaparser.printer.lexicalpreservation.PhantomNodeLogic",
        "detection": false,
        "justification": "PhantomNodeLogic has only 2 direct outgoing dependencies (com.github.javaparser.ast.observer.AstObserver and com.github.javaparser.ast.Node) and 0 incoming dependencies. Hub-like Modularization requires an abstraction to have dependencies (both incoming and outgoing) with a large number of other abstractions. The observed low outgoing count (2) and absence of incoming dependencies do not meet that criterion. Although one of its targets (Node) itself depends on many classes, that transitive connectivity does not make PhantomNodeLogic a hub when considered in isolation."
    },
    {
        "identifier": "com.github.javaparser.JavaToken",
        "detection": true,
        "justification": "JavaToken has outgoing dependencies to 7 distinct abstractions (TokenTypes, JavaToken.Category, TokenRange, GeneratedJavaParserConstants, LineSeparator, Range, Token) and receives incoming dependencies from 16 distinct abstractions (TokenRange, TokenTypes, GeneratedJavaParserBase, TokenBase, RangedList, ModifierHolder, GeneratedJavaParserTokenManagerBase, GeneratedJavaParser, GeneratedJavaParserTokenManager, LexicalPreservingPrinter, LexicalPreservingPrinter.Observer, TokenTextElement, Difference, RemovedGroup, JavaParserJsonDeserializer, JavaParserJsonSerializer). Several dependencies are bidirectional (e.g., TokenRange, TokenTypes, Token), and clients span multiple subsystems (parser generator, token managers, lexical-preservation printer, serialization). The presence of many incoming and outgoing relationships indicates a hub-like modularization smell."
    },
    {
        "identifier": "(default package).Test.InnerClass",
        "detection": false,
        "justification": "incoming_dependencies count = 0; outgoing_dependencies count = 0. The class has no incoming or outgoing dependencies, so it does not have dependencies with a large number of other abstractions and is not a hub."
    },
    {
        "identifier": "com.github.javaparser.ast.validator.language_level_validations.Java17Validator",
        "detection": false,
        "justification": "Java17Validator has 0 incoming dependencies and only 2 outgoing dependencies (com.github.javaparser.ast.validator.Validator and com.github.javaparser.ParserConfiguration). Hub-like Modularization requires an abstraction to have dependencies (both incoming and outgoing) with a large number of other abstractions. Because this class has no incoming dependencies and a very small number of outgoing dependencies, it does not meet the criteria for a hub-like module. Note: although ParserConfiguration (one outgoing target) has many dependencies itself, the analysis is limited to the examined class in isolation and therefore only the Java17Validator's direct incoming/outgoing counts are relevant."
    },
    {
        "identifier": "japa.bdd.samples.JavaConcepts.X",
        "detection": false,
        "justification": "The class has 0 incoming dependencies and 0 outgoing dependencies (both dependency lists are empty, and analyzed_package.dependencies is empty), so it does not have dependencies with a large number of other abstractions and therefore is not a hub."
    },
    {
        "identifier": "com.github.javaparser.ast.nodeTypes.NodeWithOptionalScope",
        "detection": false,
        "justification": "Incoming dependencies: 0 (none). Direct outgoing dependencies: 1 -> com.github.javaparser.ast.expr.Expression. Hub-like Modularization requires an abstraction to have many incoming and outgoing dependencies. NodeWithOptionalScope has only a single direct outgoing dependency and no incoming dependencies. (Note: com.github.javaparser.ast.expr.Expression itself lists many dependent types, but those are indirect; per the requirement to consider the class in isolation, they do not make NodeWithOptionalScope a hub.)"
    },
    {
        "identifier": "com.github.javaparser.ast.validator.language_level_validations.chunks.RecordDeclarationValidator",
        "detection": false,
        "justification": "Not detected: the class has no incoming dependencies (incoming_dependencies is empty) and only three outgoing dependencies (com.github.javaparser.ast.body.RecordDeclaration, com.github.javaparser.ast.validator.ProblemReporter, com.github.javaparser.ast.Modifier). Although those three target classes themselves reference many other abstractions (RecordDeclaration -> 11 deps, ProblemReporter -> 3 deps, Modifier -> 9 deps), the analyzed class does not exhibit both large incoming and large outgoing coupling required for Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.resolution.typeinference.TypeInferenceCache",
        "detection": false,
        "justification": "TypeInferenceCache has a small number of direct outgoing dependencies (3: com.github.javaparser.resolution.types.ResolvedType, com.github.javaparser.resolution.TypeSolver, com.github.javaparser.ast.expr.LambdaExpr) and only two incoming dependents (com.github.javaparser.symbolsolver.resolution.typeinference.TypeInference and com.github.javaparser.symbolsolver.resolution.typeinference.constraintformulas.ExpressionCompatibleWithType). Hub-like Modularization requires an abstraction to have dependencies both incoming and outgoing with a large number of other abstractions; the provided data shows limited incoming (2) and outgoing (3) connections. Per the constraint to consider the class in isolation, this connectivity is not large enough to classify it as a hub."
    },
    {
        "identifier": "aPackage.comment",
        "detection": false,
        "justification": "The class has 0 outgoing dependencies and 0 incoming dependencies according to the provided data. Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; since both counts are zero, the smell is not present."
    },
    {
        "identifier": "(default package).ClassA",
        "detection": false,
        "justification": "ClassA has 0 incoming dependencies and 1 outgoing dependency ((default package).ClassB). Hub-like Modularization requires an abstraction to have many incoming and outgoing connections; ClassA does not exhibit a large number of dependencies in either direction."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserEnumDeclaration.ValuesMethod",
        "detection": false,
        "justification": "The class does not exhibit Hub-like Modularization: it has 0 incoming dependencies (incoming_dependencies is empty) and only 2 outgoing dependencies (to com.github.javaparser.resolution.TypeSolver and com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserEnumDeclaration). Hub-like Modularization requires a large number of both incoming and outgoing dependencies, which is not the case here."
    },
    {
        "identifier": "com.github.javaparser.metamodel.ForEachStmtMetaModel",
        "detection": false,
        "justification": "ForEachStmtMetaModel has only 2 incoming dependencies (com.github.javaparser.ast.stmt.ForEachStmt and com.github.javaparser.metamodel.JavaParserMetaModel) and 1 outgoing dependency (com.github.javaparser.metamodel.PropertyMetaModel). These low counts (incoming=2, outgoing=1) do not constitute a hub-like modularization, which requires an abstraction to have dependencies with a large number of other abstractions."
    },
    {
        "identifier": "com.github.javaparser.ast.Node.PreOrderIterator",
        "detection": false,
        "justification": "No incoming or outgoing dependencies were detected (incoming_dependencies = 0, outgoing_dependencies = 0). Hub-like Modularization requires an abstraction to have dependencies with a large number of other abstractions on both incoming and outgoing sides; this class has neither, so it is not a hub."
    },
    {
        "identifier": "(default package).EnumWithAncestor",
        "detection": false,
        "justification": "The class has 0 outgoing dependencies and 0 incoming dependencies (both dependency lists are empty). Hub-like Modularization requires an abstraction to have dependencies with a large number of other abstractions; with incoming=0 and outgoing=0 (total degree=0) this class is not a hub."
    },
    {
        "identifier": "com.github.javaparser.metamodel.BooleanLiteralExprMetaModel",
        "detection": false,
        "justification": "This class has only 1 outgoing dependency (com.github.javaparser.metamodel.PropertyMetaModel) and only 2 incoming dependencies (com.github.javaparser.ast.expr.BooleanLiteralExpr and com.github.javaparser.metamodel.JavaParserMetaModel). Hub-like modularization requires an abstraction to have incoming and outgoing links with a large number of other abstractions; the observed counts are low. Note: although JavaParserMetaModel lists many dependencies, it constitutes a single incoming dependency to this class."
    },
    {
        "identifier": "com.github.javaparser.metamodel.RecordPatternExprMetaModel",
        "detection": false,
        "justification": "RecordPatternExprMetaModel has only 1 outgoing dependency (com.github.javaparser.metamodel.PropertyMetaModel) and only 2 incoming dependents (com.github.javaparser.ast.expr.RecordPatternExpr and com.github.javaparser.metamodel.JavaParserMetaModel). The total number of direct dependency relationships is small and does not constitute a hub with many incoming and outgoing connections."
    },
    {
        "identifier": "com.github.javaparser.printer.configuration.DefaultPrinterConfiguration",
        "detection": false,
        "justification": "DefaultPrinterConfiguration has 4 outgoing dependencies (DefaultPrinterConfiguration.ConfigOption, ConfigurationOption, PrinterConfiguration, LineSeparator) and 2 incoming dependents (PrettyPrinterConfiguration, MetaModelGenerator). These counts are small and do not indicate an abstraction acting as a hub with many incoming and outgoing relationships, so it does not meet the Hub-like Modularization smell criteria."
    },
    {
        "identifier": "com.github.javaparser.utils.Log.StandardOutStandardErrorAdapter",
        "detection": false,
        "justification": "The class has 0 outgoing dependencies and 0 incoming dependencies (both dependency lists are empty). Hub-like Modularization requires an abstraction to have a large number of incoming and outgoing dependencies; this class has none, so the smell is not present."
    },
    {
        "identifier": "com.github.javaparser.printer.lexicalpreservation.TextElementIteratorsFactory.ComposedIterator",
        "detection": false,
        "justification": "The class has no incoming or outgoing dependencies (incoming_dependencies = 0, outgoing_dependencies = 0, dependencies = []). Since Hub-like Modularization requires many incoming and outgoing connections to other abstractions, this class does not exhibit that smell."
    },
    {
        "identifier": "com.github.javaparser.ast.nodeTypes.NodeWithModifiers",
        "detection": false,
        "justification": "NodeWithModifiers has 0 incoming dependencies (incoming_dependencies is empty) and only 3 outgoing dependencies: com.github.javaparser.ast.AccessSpecifier, com.github.javaparser.ast.NodeList, and com.github.javaparser.ast.Modifier. Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; here incoming links are absent and outgoing links are few. Although some of the outgoing targets themselves have multiple dependencies, by the provided data and the requirement to consider the class in isolation, NodeWithModifiers does not meet the hub-like criteria."
    },
    {
        "identifier": "com.github.javaparser.printer.lexicalpreservation.RemovedGroup",
        "detection": false,
        "justification": "RemovedGroup has a modest number of outgoing dependencies (6): com.github.javaparser.printer.lexicalpreservation.Removed, com.github.javaparser.printer.concretesyntaxmodel.CsmToken, com.github.javaparser.TokenTypes, com.github.javaparser.ast.Node, com.github.javaparser.printer.lexicalpreservation.LexicalDifferenceCalculator, com.github.javaparser.JavaToken. In the provided data it has only one incoming dependency: com.github.javaparser.printer.lexicalpreservation.Difference. Because hub-like modularization requires an abstraction to have many incoming and outgoing links to a large number of other abstractions, the limited incoming count (1) and the modest, domain-local outgoing set indicate this class does not exhibit the hub-like modularization smell."
    },
    {
        "identifier": "com.github.javaparser.serialization.JavaParserJsonSerializer.JsonRange",
        "detection": false,
        "justification": "The class has no outgoing dependencies (analyzed_package.dependencies = [] and outgoing_dependencies = []). It has a single incoming dependency entry (from com.github.javaparser.serialization.JavaParserJsonSerializer). Although that incoming class depends on many abstractions, JsonRange itself is depended on by only one other abstraction and does not depend on others. Hub-like Modularization requires an abstraction to have both many incoming and many outgoing relationships; JsonRange does not meet this (incoming count = 1, outgoing count = 0)."
    },
    {
        "identifier": "com.github.javaparser.ast.validator.SingleNodeTypeValidator",
        "detection": false,
        "justification": "Incoming dependencies (3): com.github.javaparser.ast.validator.language_level_validations.Java1_0Validator, com.github.javaparser.ast.validator.language_level_validations.Java9Validator, com.github.javaparser.ast.validator.language_level_validations.Java7Validator. Outgoing dependencies (3): com.github.javaparser.ast.validator.TypedValidator, com.github.javaparser.ast.validator.ProblemReporter, com.github.javaparser.ast.Node. Both the number of incoming (3) and outgoing (3) connections are low and do not indicate dependencies with a large number of other abstractions. Although com.github.javaparser.ast.Node (one outgoing) is itself highly connected in the provided data, SingleNodeTypeValidator only depends on it as a single abstraction; therefore it does not exhibit a hub-like modularization smell."
    },
    {
        "identifier": "com.github.javaparser.ast.nodeTypes.NodeWithExtends",
        "detection": false,
        "justification": "NodeWithExtends has a small number of outgoing dependencies (3: com.github.javaparser.ast.type.ClassOrInterfaceType, com.github.javaparser.StaticJavaParser, com.github.javaparser.ast.NodeList) and only one incoming dependency (1: com.github.javaparser.symbolsolver.javaparsermodel.contexts.JavaParserTypeDeclarationAdapter). It therefore does not have dependencies with a large number of other abstractions in both directions and does not qualify as Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.generator.NodeGenerator",
        "detection": false,
        "justification": "NodeGenerator has 0 incoming dependencies and 7 outgoing dependencies (BaseNodeMetaModel, CompilationUnit, ClassOrInterfaceDeclaration, MethodDeclaration, JavaParserMetaModel, Pair, SourceRoot). Hub-like Modularization requires an abstraction to have both many incoming and many outgoing connections. Because incoming_dependencies is empty (no incoming links) and the number of direct outgoing dependencies is limited (7), NodeGenerator does not meet the 'both incoming and outgoing with a large number of other abstractions' condition. Note: some outgoing targets themselves have many dependencies, but per the isolation constraint those transitive/delegate counts do not change NodeGenerator's lack of incoming dependencies."
    },
    {
        "identifier": "com.github.javaparser.printer.concretesyntaxmodel.CsmUnindent",
        "detection": false,
        "justification": "CsmUnindent has 0 incoming dependencies and only 2 direct outgoing dependencies (com.github.javaparser.printer.SourcePrinter and com.github.javaparser.ast.Node). Hub-like Modularization requires an abstraction to have many incoming and outgoing dependency links to a large number of other abstractions. Although the outgoing classes (SourcePrinter and Node) themselves reference many types, those are transitive dependencies of CsmUnindent and do not change the fact that CsmUnindent has few direct incoming/outgoing links. Therefore it is not a hub."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.resolution.typeinference.constraintformulas.MethodReferenceThrowsCompatibleWithType",
        "detection": false,
        "justification": "The class has 0 incoming dependencies and only 3 outgoing dependencies (com.github.javaparser.ast.expr.MethodReferenceExpr, com.github.javaparser.symbolsolver.resolution.typeinference.BoundSet, com.github.javaparser.resolution.types.ResolvedType). Hub-like Modularization requires an abstraction to have many incoming and outgoing connections; here incoming_count=0 and outgoing_count=3, so it is not a hub. While the outgoing targets themselves have many dependencies, that does not make the analyzed class a hub in isolation."
    },
    {
        "identifier": "com.github.javaparser.javasymbolsolver.javassist_symbols.excluded_jar.SuperClassExcludedJar",
        "detection": false,
        "justification": "The class has 0 outgoing dependencies and 0 incoming dependencies (analyzed_package.dependencies is empty, outgoing_dependencies is empty, incoming_dependencies is empty). Hub-like Modularization requires an abstraction to have many incoming and outgoing dependencies; this class has none, so it is not a hub."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.resolution.typesolvers.AarTypeSolver",
        "detection": false,
        "justification": "AarTypeSolver has a small number of outgoing dependencies (3: com.github.javaparser.resolution.model.SymbolReference, com.github.javaparser.resolution.TypeSolver, com.github.javaparser.symbolsolver.resolution.typesolvers.JarTypeSolver) and a single incoming dependency (1: com.github.javaparser.symbolsolver.resolution.typesolvers.TypeSolverBuilder). Hub-like Modularization requires an abstraction to have dependencies (both incoming and outgoing) with a large number of other abstractions; the provided data shows low incoming and outgoing counts, so the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.ast.nodeTypes.NodeWithRange",
        "detection": false,
        "justification": "NodeWithRange has no incoming dependencies (incoming_dependencies is empty) and only two direct outgoing dependencies: com.github.javaparser.Range and com.github.javaparser.ast.Node. Hub-like Modularization requires an abstraction to have many incoming and outgoing links; here incoming = 0 and outgoing = 2. Although the outgoing target com.github.javaparser.ast.Node itself lists many dependencies, those are transitive and, per the constraint to analyze the class in isolation, do not make NodeWithRange a hub."
    },
    {
        "identifier": "javaparser.GenericClass.NestedBar",
        "detection": false,
        "justification": "The analyzed class javaparser.GenericClass.NestedBar has 0 incoming dependencies and 0 outgoing dependencies (incoming_dependencies and outgoing_dependencies arrays are empty). Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; since both counts are zero, this smell is not present."
    },
    {
        "identifier": "com.github.javaparser.HasParentNode",
        "detection": false,
        "justification": "HasParentNode has only one outgoing dependency: com.github.javaparser.ast.Node, and there are no incoming dependencies. Hub-like Modularization requires an abstraction to have many incoming and outgoing connections. Although the Node class (which HasParentNode depends on) has many outgoing dependencies (e.g., com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.Position, com.github.javaparser.printer.Printer, com.github.javaparser.Range, etc.), HasParentNode itself does not have a large number of incoming or outgoing dependencies and therefore is not a hub."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.reflectionmodel.ReflectionConstructorDeclaration",
        "detection": false,
        "justification": "ReflectionConstructorDeclaration has 7 outgoing dependencies (com.github.javaparser.ast.AccessSpecifier, com.github.javaparser.resolution.declarations.ResolvedParameterDeclaration, com.github.javaparser.resolution.types.ResolvedType, com.github.javaparser.symbolsolver.logic.AbstractTypeDeclaration, com.github.javaparser.resolution.TypeSolver, com.github.javaparser.symbolsolver.reflectionmodel.ReflectionFactory, com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration) and only 1 incoming dependency (com.github.javaparser.symbolsolver.reflectionmodel.ReflectionTypeParameter). Hub-like modularization requires an abstraction to have many both incoming and outgoing connections; here the incoming fan-in is minimal, so this class is not a hub."
    },
    {
        "identifier": "com.github.javaparser.utils.ProjectRoot",
        "detection": false,
        "justification": "ProjectRoot has 4 incoming dependencies (SymbolSolverCollectionStrategy, CollectionStrategy, ParserCollectionStrategy, demo.Main) but only 1 outgoing dependency (com.github.javaparser.ParserConfiguration). Hub-like Modularization requires many incoming AND many outgoing dependencies. Here incoming count = 4 and outgoing count = 1, so ProjectRoot does not exhibit a hub-like dependency pattern."
    },
    {
        "identifier": "com.github.javaparser.metamodel.LambdaExprMetaModel",
        "detection": false,
        "justification": "LambdaExprMetaModel has only one outgoing dependency (com.github.javaparser.metamodel.PropertyMetaModel) and only two incoming dependents (com.github.javaparser.ast.expr.LambdaExpr and com.github.javaparser.metamodel.JavaParserMetaModel). The counts of incoming and outgoing connections are small and do not show dependencies with a large number of other abstractions, so it does not exhibit Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.utils.StringEscapeUtils.LookupTranslator",
        "detection": false,
        "justification": "The class has 0 outgoing dependencies and only 1 incoming dependency (from com.github.javaparser.utils.StringEscapeUtils). Hub-like Modularization requires a large number of both incoming and outgoing relationships; this class does not exhibit that pattern."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.declarators.VariableSymbolDeclarator",
        "detection": false,
        "justification": "Incoming dependencies are empty (no other abstractions depend on this class). Outgoing dependencies are limited to three abstractions: com.github.javaparser.resolution.TypeSolver, com.github.javaparser.ast.expr.VariableDeclarationExpr, and com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserSymbolDeclaration. Hub-like Modularization requires many incoming and outgoing dependencies; this class has neither a large number of incoming nor outgoing connections, so it is not a hub."
    },
    {
        "identifier": "com.github.javaparser.ast.expr.NullLiteralExpr",
        "detection": false,
        "justification": "NullLiteralExpr has a large number of incoming dependencies (21 distinct callers include: com.github.javaparser.symbolsolver.javaparsermodel.DefaultVisitorAdapter, com.github.javaparser.symbolsolver.javaparsermodel.TypeExtractor, com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.ast.visitor.ModifierVisitor, com.github.javaparser.ast.visitor.CloneVisitor, com.github.javaparser.ast.expr.Expression, com.github.javaparser.printer.PrettyPrintVisitor, com.github.javaparser.printer.DefaultPrettyPrinterVisitor, etc.), but only 6 outgoing dependencies (com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.metamodel.NullLiteralExprMetaModel, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.TokenRange, com.github.javaparser.Range). Because Hub-like Modularization requires an abstraction to have many incoming AND many outgoing dependencies, and NullLiteralExpr shows high incoming but relatively few outgoing dependencies, the hub-like smell is not detected for this class."
    },
    {
        "identifier": "com.github.javaparser.resolution.SymbolDeclarator",
        "detection": false,
        "justification": "SymbolDeclarator is referenced by multiple other classes (7 incoming dependencies: com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFactory, com.github.javaparser.symbolsolver.javaparsermodel.contexts.StatementContext, com.github.javaparser.symbolsolver.javaparsermodel.contexts.LambdaExprContext, com.github.javaparser.symbolsolver.javaparsermodel.contexts.CatchClauseContext, com.github.javaparser.symbolsolver.javaparsermodel.contexts.AbstractMethodLikeDeclarationContext, com.github.javaparser.symbolsolver.javaparsermodel.contexts.AbstractJavaParserContext, com.github.javaparser.symbolsolver.javaparsermodel.contexts.SwitchEntryContext) but has 0 outgoing dependencies. Hub-like Modularization requires an abstraction to have many both incoming and outgoing dependencies; because outgoing dependencies are absent, the hub-like smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.ast.validator.language_level_validations.Java23Validator",
        "detection": false,
        "justification": "No incoming or outgoing dependencies (incoming_dependencies = 0, outgoing_dependencies = 0). Hub-like Modularization requires an abstraction to have dependencies with a large number of other abstractions; with zero incoming and outgoing links this class does not meet that criterion."
    },
    {
        "identifier": "com.github.javaparser.ast.DataKey",
        "detection": false,
        "justification": "DataKey is referenced by multiple other classes (incoming dependencies from com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade, com.github.javaparser.ast.Node, com.github.javaparser.printer.lexicalpreservation.LexicalPreservingPrinter — each lists 'com.github.javaparser.ast.DataKey' in their dependency lists). However, DataKey has no outgoing dependencies (outgoing_dependencies is empty). The Hub-like Modularization smell requires an abstraction to have many incoming AND many outgoing dependencies; since outgoing dependency count = 0, the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.ast.nodeTypes.NodeWithOptionalBlockStmt",
        "detection": false,
        "justification": "The class has only 1 outgoing dependency (com.github.javaparser.ast.stmt.BlockStmt) and 0 incoming dependencies. Hub-like Modularization requires an abstraction to have many incoming and outgoing relationships; this class does not exhibit that pattern."
    },
    {
        "identifier": "com.github.javaparser.JavaParserBuild",
        "detection": false,
        "justification": "No incoming or outgoing dependencies detected (incoming_dependencies = 0, outgoing_dependencies = 0). Hub-like Modularization requires an abstraction to have dependencies with a large number of other abstractions; this class has none, so it is not a hub."
    },
    {
        "identifier": "com.github.javaparser.printer.lexicalpreservation.Kept",
        "detection": false,
        "justification": "Kept has a small set of outgoing dependencies (4): com.github.javaparser.TokenTypes, com.github.javaparser.printer.lexicalpreservation.LexicalDifferenceCalculator, com.github.javaparser.printer.concretesyntaxmodel.CsmToken, com.github.javaparser.printer.concretesyntaxmodel.CsmElement. It has a single incoming dependency in the provided data (com.github.javaparser.printer.lexicalpreservation.Difference). Because the class only participates in a few incoming and outgoing relationships in the given data, it does not exhibit hub-like modularization."
    },
    {
        "identifier": "com.github.javaparser.utils.Log.SilentAdapter",
        "detection": false,
        "justification": "Both incoming and outgoing dependency lists are empty (incoming_dependencies = 0, outgoing_dependencies = 0). Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; this class has none, so it is not a hub."
    },
    {
        "identifier": "com.github.javaparser.metamodel.ModuleDirectiveMetaModel",
        "detection": false,
        "justification": "ModuleDirectiveMetaModel has 0 outgoing dependencies and only 2 incoming dependents: com.github.javaparser.ast.modules.ModuleDirective and com.github.javaparser.metamodel.JavaParserMetaModel. There is no evidence of dependencies (incoming + outgoing) with a large number of other abstractions, so the Hub-like Modularization smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.resolution.declarations.ResolvedRecordDeclaration",
        "detection": false,
        "justification": "ResolvedRecordDeclaration has 0 outgoing dependencies and only 1 incoming dependency (from com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration). A hub-like module would have many incoming and outgoing relationships; this class does not exhibit a large number of both incoming and outgoing dependencies."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserRecordDeclaration.CanonicalRecordConstructor",
        "detection": false,
        "justification": "The class has 0 incoming dependencies and only 3 direct outgoing dependencies: com.github.javaparser.ast.AccessSpecifier, com.github.javaparser.ast.body.RecordDeclaration, and com.github.javaparser.resolution.TypeSolver. Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; this class lacks incoming links and has a small number of outgoing links, so it is not a hub."
    },
    {
        "identifier": "com.github.javaparser.printer.lexicalpreservation.TextElementIteratorsFactory.SingleElementIterator",
        "detection": false,
        "justification": "The class has 0 incoming dependencies and 0 outgoing dependencies (both dependency lists are empty). Hub-like Modularization requires an abstraction to have many incoming and outgoing relationships; this class has none, so it is not a hub."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserRecordDeclaration.ImplicitGetterMethod",
        "detection": false,
        "justification": "The class has 0 incoming dependencies and only 4 outgoing dependencies (com.github.javaparser.ast.AccessSpecifier, com.github.javaparser.ast.body.RecordDeclaration, com.github.javaparser.resolution.TypeSolver, com.github.javaparser.ast.body.Parameter). Hub-like modularization requires an abstraction to have many incoming and outgoing relationships; since incoming is absent and outgoing is small, this is not a hub."
    },
    {
        "identifier": "com.github.javaparser.ast.validator.language_level_validations.Java1_3Validator",
        "detection": false,
        "justification": "Incoming dependencies: 0; Outgoing dependencies: 0. The class has no incoming or outgoing dependencies with other abstractions, so it does not exhibit Hub-like Modularization (no large number of incoming/outgoing dependencies)."
    },
    {
        "identifier": "com.github.javaparser.ast.body.EnumConstantDeclaration",
        "detection": true,
        "justification": "EnumConstantDeclaration participates in many dependencies on both sides: it has outgoing dependencies to 12 distinct abstractions (examples: com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.resolution.declarations.ResolvedEnumConstantDeclaration, com.github.javaparser.metamodel.EnumConstantDeclarationMetaModel, com.github.javaparser.Range, com.github.javaparser.ast.NodeList, com.github.javaparser.ast.comments.JavadocComment, com.github.javaparser.ast.expr.SimpleName, com.github.javaparser.TokenRange, com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.ast.Node, com.github.javaparser.ast.visitor.GenericVisitor) and is referenced by a large number of other abstractions (at least 26 incoming dependents) including many visitor implementations and utilities (examples: com.github.javaparser.symbolsolver.javaparsermodel.DefaultVisitorAdapter, com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserFieldDeclaration, com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserEnumConstantDeclaration, com.github.javaparser.ast.body.EnumDeclaration, com.github.javaparser.ast.body.BodyDeclaration, multiple visitor classes such as com.github.javaparser.ast.visitor.VoidVisitor, GenericVisitor, HashCodeVisitor, EqualsVisitor, CloneVisitor, PrettyPrintVisitor, DefaultPrettyPrinterVisitor, and generators like com.github.javaparser.generator.core.node.PropertyGenerator). The class therefore has many incoming and outgoing relationships across diverse subsystems (visitors, printers, resolution, metamodel, generators), which matches the Hub-like Modularization smell."
    },
    {
        "identifier": "a.b.c.DataObject",
        "detection": false,
        "justification": "The class has 1 incoming dependency (from a.b.c.ExampleClass) and 0 outgoing dependencies. incoming_dependencies lists a.b.c.ExampleClass (which depends on a.b.c.DataObject and a.b.c.DataObjectFactory); outgoing_dependencies is empty. Hub-like Modularization requires many incoming and outgoing relationships, which is not the case here."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFactory",
        "detection": true,
        "justification": "JavaParserFactory has a large number of incoming dependencies (≈27 distinct classes across com.github.javaparser.symbolsolver, .javaparsermodel, .javaparsermodel.declarations, .javaparsermodel.contexts, .resolution, etc.) — examples include JavaParserFacade, TypeExtractor, JavaParserClassDeclaration, JavaParserMethodDeclaration, numerous context classes (BlockStmtContext, StatementContext, LambdaExprContext, AnonymousClassDeclarationContext), NameLogic, SymbolSolver and JavaSymbolSolver. It also has multiple outgoing dependencies (9 distinct classes) to core AST and resolution types such as com.github.javaparser.ast.Node, com.github.javaparser.resolution.Navigator, com.github.javaparser.resolution.TypeSolver, com.github.javaparser.ast.body.ClassOrInterfaceDeclaration, ForStmt, ForEachStmt, ExpressionStmt, Context and SymbolDeclarator. The presence of many incoming relationships from varied modules combined with multiple outgoing links to core abstractions indicates the class functions as a central connector (hub) between many other abstractions, satisfying the Hub-like Modularization smell."
    },
    {
        "identifier": "com.github.javaparser.javasymbolsolver.javassist_symbols.main_jar.InterfaceOwnJar",
        "detection": false,
        "justification": "Both incoming_dependencies and outgoing_dependencies are empty (0 incoming, 0 outgoing). Hub-like Modularization requires an abstraction to have dependencies with a large number of other abstractions; this class has no incoming or outgoing dependencies, so it is not a hub."
    },
    {
        "identifier": "com.github.javaparser.ast.stmt.LabeledStmt",
        "detection": false,
        "justification": "LabeledStmt has many incoming dependencies (approximately 23 distinct clients including com.github.javaparser.symbolsolver.javaparsermodel.DefaultVisitorAdapter, com.github.javaparser.symbolsolver.javaparsermodel.NormalCompletionVisitor, multiple visitor classes in com.github.javaparser.ast.visitor such as VoidVisitor, GenericVisitor, HashCodeVisitor, EqualsVisitor, CloneVisitor, PrettyPrintVisitor, DefaultPrettyPrinterVisitor, NodeFinderVisitor, etc.), but its outgoing dependency set is small (10 direct dependencies: com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.stmt.Statement, com.github.javaparser.Range, com.github.javaparser.ast.expr.SimpleName, com.github.javaparser.TokenRange, com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.metamodel.LabeledStmtMetaModel, com.github.javaparser.ast.Node, com.github.javaparser.ast.visitor.GenericVisitor). Hub-like Modularization requires a large number of both incoming and outgoing links; LabeledStmt exhibits many incoming but not a large number of outgoing dependencies, so it is not classified as hub-like."
    },
    {
        "identifier": "main.Parent",
        "detection": false,
        "justification": "The class main.Parent has 0 incoming dependencies and 0 outgoing dependencies (incoming_dependencies and outgoing_dependencies are empty). Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; since both counts are zero, this class does not exhibit the smell."
    },
    {
        "identifier": "com.github.javaparser.resolution.declarations.ResolvedClassDeclaration",
        "detection": false,
        "justification": "ResolvedClassDeclaration has 0 outgoing dependencies and only 2 incoming dependencies (from com.github.javaparser.symbolsolver.logic.AbstractClassDeclaration and com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration). A hub-like modularization requires many incoming and outgoing connections; this class does not exhibit a large number of dependencies in either direction."
    },
    {
        "identifier": "com.github.javaparser.metamodel.CallableDeclarationMetaModel",
        "detection": false,
        "justification": "Not a hub: the class has only one outgoing dependency (com.github.javaparser.metamodel.PropertyMetaModel) and only two incoming dependents (com.github.javaparser.ast.body.CallableDeclaration and com.github.javaparser.metamodel.JavaParserMetaModel). Although JavaParserMetaModel references many meta-models, that counts as a single incoming dependency to CallableDeclarationMetaModel. There is not a large number of distinct incoming and outgoing dependencies required for Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.ast.stmt.SwitchEntry.Type",
        "detection": false,
        "justification": "The class has no outgoing dependencies (outgoing_dependencies = []). It has a single incoming dependency from com.github.javaparser.ast.stmt.SwitchEntry only. Hub-like modularization requires an abstraction to have incoming and outgoing relationships with a large number of other abstractions; here there is only one incoming and zero outgoing relationships, so it is not a hub."
    },
    {
        "identifier": "com.github.javaparser.metamodel.PackageDeclarationMetaModel",
        "detection": false,
        "justification": "PackageDeclarationMetaModel has only one outgoing dependency (com.github.javaparser.metamodel.PropertyMetaModel) and only two incoming dependencies (com.github.javaparser.ast.PackageDeclaration and com.github.javaparser.metamodel.JavaParserMetaModel). The number of direct incoming+outgoing relationships (3 distinct abstractions) is small and does not constitute a hub-like modularization."
    },
    {
        "identifier": "(default package).Ancestor",
        "detection": false,
        "justification": "The class has 0 outgoing dependencies and 0 incoming dependencies (both lists empty). Since it has no incoming or outgoing links to other abstractions, it cannot be a hub-like module."
    },
    {
        "identifier": "com.github.javaparser.generator.CompilationUnitGenerator",
        "detection": false,
        "justification": "The class has no incoming dependencies (incoming_dependencies is empty) and only two direct outgoing dependencies: com.github.javaparser.ast.CompilationUnit and com.github.javaparser.utils.SourceRoot. Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing couplings. Although the two outgoing targets themselves reference many types (CompilationUnit -> ~25 types, SourceRoot -> ~9 types), those are not direct incoming dependencies of CompilationUnitGenerator, so the class does not exhibit a hub-like modularization smell."
    },
    {
        "identifier": "com.github.javaparser.printer.configuration.imports.IntelliJImportOrderingStrategy",
        "detection": false,
        "justification": "The class has no incoming dependencies (incoming_dependencies is empty) and only one outgoing dependency: com.github.javaparser.ast.NodeList. Hub-like Modularization requires an abstraction to have many incoming and outgoing dependencies. Although NodeList itself depends on several types (com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.ast.observer.AstObserver, com.github.javaparser.ast.Node), those are indirect; considering the class in isolation, it does not exhibit hub-like dependency characteristics."
    },
    {
        "identifier": "com.github.javaparser.ast.nodeTypes.NodeWithType",
        "detection": false,
        "justification": "Not detected: the class has no incoming dependencies (incoming_dependencies is empty) and only 4 outgoing dependencies (com.github.javaparser.ast.type.ClassOrInterfaceType, com.github.javaparser.StaticJavaParser, com.github.javaparser.ast.type.Type, com.github.javaparser.utils.Utils). Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; the absence of incoming dependencies and the small outgoing set indicate the smell is not present."
    },
    {
        "identifier": "(default package).InnerClassDotExpressions",
        "detection": false,
        "justification": "No incoming dependencies (incoming_dependencies length = 0) and no outgoing dependencies (outgoing_dependencies length = 0); analyzed_package.dependencies is empty. Hub-like Modularization requires many incoming and outgoing connections, which are absent here."
    },
    {
        "identifier": "com.github.javaparser.ast.validator.language_level_validations.Java15Validator",
        "detection": false,
        "justification": "The class has 0 outgoing dependencies and 0 incoming dependencies (both dependency lists are empty). Hub-like Modularization requires an abstraction to have dependencies with a large number of other abstractions; this class has none, so it is not a hub."
    },
    {
        "identifier": "com.github.javaparser.ast.observer.ObservableProperty",
        "detection": false,
        "justification": "ObservableProperty has a very large number of incoming dependencies from many packages and classes (examples: com.github.javaparser.ast.Node, com.github.javaparser.ast.CompilationUnit, com.github.javaparser.ast.type.Type, com.github.javaparser.ast.body.MethodDeclaration, many com.github.javaparser.ast.expr.* classes like MethodCallExpr and Name, and printer/lexicalpreservation classes such as com.github.javaparser.printer.ConcreteSyntaxModel and com.github.javaparser.printer.lexicalpreservation.LexicalPreservingPrinter), indicating it is widely used. However, its outgoing dependency set is small (only 4 listed: com.github.javaparser.ast.observer.ObservableProperty.Type, com.github.javaparser.ast.Node, com.github.javaparser.ast.NodeList, com.github.javaparser.utils.Utils). Because hub-like modularization requires an abstraction to have a large number of dependencies in both directions (many incoming and many outgoing), ObservableProperty does not meet the definition: incoming dependencies are numerous but outgoing dependencies are limited."
    },
    {
        "identifier": "a.RefCycleEnum",
        "detection": false,
        "justification": "a.RefCycleEnum has 1 incoming dependency (from a.RefCycleClass) and 0 outgoing dependencies. Hub-like Modularization requires an abstraction to have many incoming and many outgoing dependencies; this class does not meet that criterion."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.contexts.JavaParserTypeDeclarationAdapter",
        "detection": true,
        "justification": "The class has a large number of outgoing dependencies (17 distinct abstractions) spanning core resolution and AST components (examples: com.github.javaparser.resolution.TypeSolver, com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade, com.github.javaparser.resolution.logic.MethodResolutionLogic, com.github.javaparser.resolution.logic.ConstructorResolutionLogic, com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration, com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration, com.github.javaparser.resolution.model.SymbolReference, and multiple AST node types). At the same time it has multiple incoming dependencies (4 different context classes depend on it: EnumDeclarationContext, ClassOrInterfaceDeclarationContext, AnnotationDeclarationContext, RecordDeclarationContext). Because it both depends on many core abstractions across several responsibility areas and is referenced by multiple other contexts, it functions as a central hub linking many modules and therefore exhibits Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.ast.stmt.TryStmt",
        "detection": true,
        "justification": "TryStmt exhibits hub-like modularization: it has numerous outgoing dependencies (10) to core abstractions such as com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.ast.Node, com.github.javaparser.ast.NodeList, com.github.javaparser.Range, com.github.javaparser.TokenRange, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.metamodel.TryStmtMetaModel, com.github.javaparser.ast.observer.ObservableProperty and com.github.javaparser.ast.stmt.BlockStmt. It also has a large number of incoming dependencies (23) from many different visitors, printers and context classes (for example: com.github.javaparser.ast.visitor.VoidVisitor, GenericVisitor, EqualsVisitor, HashCodeVisitor, ModifierVisitor, various VisitorAdapter classes, com.github.javaparser.printer.PrettyPrintVisitor, com.github.javaparser.printer.DefaultPrettyPrinterVisitor, com.github.javaparser.GeneratedJavaParser, and symbol-solver classes like DefaultVisitorAdapter and TryWithResourceContext). The combination of a high out-degree to core AST/meta/visitor abstractions and a high in-degree from many unrelated modules (visitors, printers, symbol-solver, parser generator) qualifies TryStmt as a hub: it is highly connected both incoming and outgoing to many other abstractions."
    },
    {
        "identifier": "com.github.javaparser.printer.lexicalpreservation.Difference",
        "detection": false,
        "justification": "Difference has many outgoing dependencies (20 distinct abstractions, e.g. ChildTextElement, LexicalPreservingPrinter, NodeText, TokenTypes, JavaToken, TextElement, CsmElement, RemovedGroup, ReshuffledDiffElementExtractor) but only two incoming dependencies (from LexicalDifferenceCalculator and LexicalPreservingPrinter). Because the number of incoming dependents is small while outgoing references are many, the class does not exhibit the bidirectional 'hub' characteristic required for Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.resolution.naming.NameRole",
        "detection": false,
        "justification": "NameRole has 0 outgoing dependencies and only 1 incoming dependency (from com.github.javaparser.symbolsolver.resolution.naming.NameLogic). A hub-like modularization requires an abstraction to have many incoming and many outgoing dependencies; NameRole does not meet this criterion."
    },
    {
        "identifier": "com.github.javaparser.GeneratedJavaParserConstants",
        "detection": false,
        "justification": "GeneratedJavaParserConstants is referenced by 8 other classes (com.github.javaparser.JavaToken, com.github.javaparser.printer.ConcreteSyntaxModel, com.github.javaparser.printer.concretesyntaxmodel.CsmAttribute, com.github.javaparser.printer.concretesyntaxmodel.CsmToken, com.github.javaparser.printer.concretesyntaxmodel.CsmElement, com.github.javaparser.printer.lexicalpreservation.LexicalDifferenceCalculator, com.github.javaparser.printer.lexicalpreservation.Difference, com.github.javaparser.printer.lexicalpreservation.TextElement) but has 0 outgoing dependencies. The Hub-like Modularization smell requires an abstraction to have a large number of both incoming and outgoing dependencies; because outgoing dependencies are absent, this class does not meet the definition."
    },
    {
        "identifier": "com.github.javaparser.quality.Preconditions",
        "detection": false,
        "justification": "Preconditions is not hub-like: it has 0 outgoing dependencies and only 4 incoming dependencies (A, B, com.github.javaparser.StaticJavaParser, com.example.ConstructorParameterTest). Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; here outgoing=0, so the smell does not apply."
    },
    {
        "identifier": "japa.bdd.samples.JavaConcepts",
        "detection": false,
        "justification": "Incoming dependencies: 0 (no classes depend on japa.bdd.samples.JavaConcepts). Outgoing dependencies: 3 — com.github.javaparser.ast.CompilationUnit, japa.bdd.samples.JavaConcepts.A, japa.bdd.samples.JavaConcepts.QWE. Although com.github.javaparser.ast.CompilationUnit itself references many types, JavaConcepts has only a single direct dependency on that type and only two additional direct internal dependencies. Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; here incoming = 0 and outgoing is small, so the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.printer.concretesyntaxmodel.CsmConditional.Condition",
        "detection": false,
        "justification": "The class has no outgoing dependencies and only a single incoming dependency from com.github.javaparser.printer.concretesyntaxmodel.CsmConditional. Hub-like Modularization requires an abstraction to have dependencies (both incoming and outgoing) with a large number of other abstractions; here the analyzed class interacts with very few other abstractions (0 outgoing, 1 incoming), so it is not a hub."
    },
    {
        "identifier": "com.github.javaparser.metamodel.LiteralStringValueExprMetaModel",
        "detection": false,
        "justification": "LiteralStringValueExprMetaModel has a single outgoing dependency (com.github.javaparser.metamodel.PropertyMetaModel) and only two incoming dependencies in the provided data (com.github.javaparser.ast.expr.LiteralStringValueExpr and com.github.javaparser.metamodel.JavaParserMetaModel). Although JavaParserMetaModel lists many other meta-models, those are dependencies of JavaParserMetaModel, not direct incoming/outgoing ties of LiteralStringValueExprMetaModel. Given the analysis constraint to treat the class in isolation, the class does not exhibit a large number of incoming and outgoing dependencies and therefore is not a hub-like modularization."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.contexts.BlockStmtContext",
        "detection": false,
        "justification": "Hub-like Modularization requires an abstraction to have many incoming and many outgoing dependencies. BlockStmtContext has many outgoing dependencies (10 distinct targets: com.github.javaparser.ast.stmt.ExpressionStmt, com.github.javaparser.resolution.Context, com.github.javaparser.resolution.model.SymbolReference, com.github.javaparser.ast.stmt.Statement, com.github.javaparser.resolution.TypeSolver, com.github.javaparser.ast.Node, com.github.javaparser.ast.expr.VariableDeclarationExpr, com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserSymbolDeclaration, com.github.javaparser.ast.stmt.BlockStmt, com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFactory) but has zero incoming dependencies (incoming_dependencies is empty). Because it lacks the required large number of incoming dependencies, it should not be classified as a hub."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.contexts.AnonymousClassDeclarationContext",
        "detection": false,
        "justification": "Not detected: the class has 0 incoming dependencies (incoming_dependencies is empty) and 10 outgoing dependencies (SymbolReference, JavaParserAnonymousClassDeclaration, JavaParserFacade, TypeSolver, NodeList, ObjectCreationExpr, ReflectionClassDeclaration, ResolvedReferenceTypeDeclaration, JavaParserFactory, MethodResolutionLogic). Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing relationships; here the incoming degree is zero, so the hub-like smell is not present."
    },
    {
        "identifier": "com.github.javaparser.ast.stmt.ReturnStmt",
        "detection": false,
        "justification": "ReturnStmt has many incoming dependencies from numerous visitors and utilities (e.g. com.github.javaparser.ast.visitor.VoidVisitor, GenericVisitor, HashCodeVisitor, PrettyPrintVisitor, many other visitor/adapters and symbol-solver/context classes), indicating a high in-degree. However, its outgoing dependency set is small (9 direct dependencies: com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.Range, com.github.javaparser.ast.expr.Expression, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.TokenRange, com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.ast.Node, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.metamodel.ReturnStmtMetaModel). Because Hub-like Modularization requires large numbers of both incoming and outgoing dependencies, ReturnStmt does not meet the definition (high in-degree but limited out-degree), so the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.ast.nodeTypes.NodeWithTypeArguments",
        "detection": false,
        "justification": "NodeWithTypeArguments has only 2 outgoing dependencies: com.github.javaparser.ast.type.Type and com.github.javaparser.ast.NodeList, and only 3 incoming dependents: com.github.javaparser.ast.expr.Expression, com.github.javaparser.printer.PrettyPrintVisitor, and com.github.javaparser.printer.DefaultPrettyPrinterVisitor. These counts indicate limited bi-directional connectivity; therefore it does not exhibit hub-like modularization based on the provided data."
    },
    {
        "identifier": "com.github.javaparser.printer.lexicalpreservation.PrintableTextElement",
        "detection": false,
        "justification": "PrintableTextElement has no incoming dependencies and only one outgoing dependency (com.github.javaparser.printer.lexicalpreservation.LexicalPreservingVisitor). Hub-like Modularization requires an abstraction to have many incoming and outgoing dependencies; these counts do not meet that criterion."
    },
    {
        "identifier": "com.github.javaparser.printer.concretesyntaxmodel.CsmNone",
        "detection": false,
        "justification": "CsmNone has 0 incoming dependencies and 2 outgoing dependencies (com.github.javaparser.printer.SourcePrinter, com.github.javaparser.ast.Node). Hub-like Modularization requires an abstraction to have both many incoming and many outgoing relationships. With no incoming dependencies and only two outgoing dependencies, CsmNone does not meet the criteria for a hub-like module. (Note: the outgoing target classes have many dependencies themselves, but the smell is evaluated for CsmNone in isolation.)"
    },
    {
        "identifier": "com.github.javaparser.generator.core.visitor.ModifierVisitorGenerator",
        "detection": false,
        "justification": "Incoming dependencies: 0. Outgoing dependencies: 7 (com.github.javaparser.metamodel.BaseNodeMetaModel, com.github.javaparser.ast.stmt.BlockStmt, com.github.javaparser.ast.CompilationUnit, com.github.javaparser.utils.SeparatedItemStringBuilder, com.github.javaparser.ast.body.MethodDeclaration, com.github.javaparser.metamodel.PropertyMetaModel, com.github.javaparser.utils.SourceRoot). Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; this class has multiple outgoing dependencies but no incoming dependencies, so the smell is not present."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.contexts.RecordDeclarationContext",
        "detection": false,
        "justification": "RecordDeclarationContext has many outgoing dependencies (10): com.github.javaparser.resolution.model.SymbolReference, com.github.javaparser.symbolsolver.javaparsermodel.contexts.JavaParserTypeDeclarationAdapter, com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade, com.github.javaparser.resolution.TypeSolver, com.github.javaparser.ast.body.RecordDeclaration, com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration, com.github.javaparser.ast.Node, com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration, com.github.javaparser.resolution.model.Value, com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserRecordDeclaration; however it has no incoming dependencies (incoming_dependencies is empty). Hub-like Modularization requires an abstraction to have both a large number of incoming and outgoing dependencies. Because there are zero incoming dependencies, this class does not meet the hub-like smell criteria."
    },
    {
        "identifier": "com.github.javaparser.ast.validator.postprocessors.Java22PostProcessor",
        "detection": false,
        "justification": "The class has no incoming or outgoing dependencies (incoming_dependencies: [], outgoing_dependencies: []), so it does not depend on or is depended on by a large number of other abstractions. Under the given isolated analysis data, it cannot be classified as Hub-like Modularization."
    },
    {
        "identifier": "(default package).EnumWithInnerType",
        "detection": false,
        "justification": "Incoming dependencies: 0; Outgoing dependencies: 0. The class has no incoming or outgoing links to other abstractions, so it does not exhibit hub-like modularization (no large number of incoming and outgoing dependencies)."
    },
    {
        "identifier": "com.github.javaparser.utils.SourceRoot.VisitFileCallback",
        "detection": false,
        "justification": "The class has 0 outgoing dependencies and only 1 incoming dependency (from com.github.javaparser.utils.SourceRoot). Hub-like Modularization requires an abstraction to have many incoming and outgoing connections. Although the incoming class (com.github.javaparser.utils.SourceRoot) lists multiple dependencies (com.github.javaparser.ParserConfiguration, com.github.javaparser.utils.CodeGenerationUtils, com.github.javaparser.utils.SourceRoot.VisitFileCallback, com.github.javaparser.utils.SourceRoot.Callback, com.github.javaparser.ast.CompilationUnit, com.github.javaparser.JavaParser, com.github.javaparser.utils.SourceRoot.ParallelParse, com.github.javaparser.utils.Log, com.github.javaparser.ParseResult), the analyzed class itself does not exhibit many incoming/outgoing relationships and therefore is not a hub."
    },
    {
        "identifier": "com.github.javaparser.ast.validator.TypedValidator",
        "detection": false,
        "justification": "TypedValidator has 4 outgoing dependencies (com.github.javaparser.Processor, com.github.javaparser.ast.validator.ProblemReporter, com.github.javaparser.ParseResult, com.github.javaparser.ParserConfiguration) and only 1 incoming dependency (com.github.javaparser.ast.validator.SingleNodeTypeValidator). Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; the provided counts are small, so the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.ast.modules.ModuleExportsDirective",
        "detection": false,
        "justification": "Incoming vs outgoing counts: ModuleExportsDirective has a large number of incoming dependents (≈21 distinct classes reference it — e.g. com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.visitor.GenericVisitor, DefaultVisitorAdapter, HashCodeVisitor, ModifierVisitor, GeneratedJavaParser, PrettyPrintVisitor, DefaultPrettyPrinterVisitor, NodeFinderVisitor, etc.) but only a modest set of outgoing dependencies (10 reported — e.g. com.github.javaparser.ast.expr.Name, com.github.javaparser.ast.Node, com.github.javaparser.ast.NodeList, com.github.javaparser.TokenRange, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.StaticJavaParser, com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.metamodel.ModuleExportsDirectiveMetaModel). The Hub-like Modularization smell requires an abstraction to have a large number of both incoming and outgoing dependency relationships. Although ModuleExportsDirective is widely referenced (high incoming), its outgoing coupling is limited, so it does not meet the definition of a hub."
    },
    {
        "identifier": "com.github.javaparser.metamodel.PropertyMetaModel",
        "detection": false,
        "justification": "PropertyMetaModel has a very large number of incoming dependencies (~99 distinct classes depend on it, e.g. PackageDeclarationMetaModel, ImportDeclarationMetaModel, JavaParserMetaModel, JavaParserJsonDeserializer, PropertyGenerator, ModifierVisitorGenerator, RemoveMethodGenerator, ReplaceMethodGenerator), but a small number of outgoing dependencies (3: com.github.javaparser.utils.CodeGenerationUtils, com.github.javaparser.ast.Node, com.github.javaparser.metamodel.BaseNodeMetaModel). The definition of Hub-like Modularization requires an abstraction to have both many incoming and many outgoing dependencies. Because PropertyMetaModel has many incoming but only few outgoing dependencies, it does not meet the definition and is not classified as hub-like."
    },
    {
        "identifier": "com.github.javaparser.metamodel.WildcardTypeMetaModel",
        "detection": false,
        "justification": "WildcardTypeMetaModel has only one outgoing dependency (com.github.javaparser.metamodel.PropertyMetaModel) and only two incoming dependents in the provided data (com.github.javaparser.ast.type.WildcardType and com.github.javaparser.metamodel.JavaParserMetaModel). Although JavaParserMetaModel itself references many meta-model classes, that still counts as a single incoming abstraction. Because both the number of distinct incoming and outgoing dependencies for WildcardTypeMetaModel are low, it does not meet the criteria for Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.resolution.types.ResolvedIntersectionType",
        "detection": false,
        "justification": "ResolvedIntersectionType has only 2 outgoing dependencies (com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration, com.github.javaparser.resolution.types.ResolvedType) and only 1 incoming dependency (com.github.javaparser.ast.type.IntersectionType). While one outgoing dependency (ResolvedType) itself depends on many types, ResolvedIntersectionType does not exhibit a large number of direct incoming and outgoing relationships required to classify it as a hub."
    },
    {
        "identifier": "com.github.javaparser.printer.lexicalpreservation.LexicalPreservingPrinter.Observer",
        "detection": false,
        "justification": "Hub-like Modularization requires an abstraction to have dependencies (both incoming and outgoing) with a large number of other abstractions. This class has outgoing dependencies to 4 classes: com.github.javaparser.ast.observer.AstObserver, com.github.javaparser.JavaToken, com.github.javaparser.ast.observer.ObservableProperty, and com.github.javaparser.utils.LineSeparator, and has 0 incoming dependencies (incoming_dependencies is empty). Because it lacks incoming dependencies and the outgoing count is not large, the hub-like modularization smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.resolution.typeinference.bounds.CapturesBound",
        "detection": false,
        "justification": "CapturesBound has only 1 outgoing dependency (to com.github.javaparser.symbolsolver.resolution.typeinference.InferenceVariableSubstitution) and only 1 incoming dependency source (referenced by com.github.javaparser.symbolsolver.resolution.typeinference.BoundSet). Although BoundSet itself depends on many classes, CapturesBound is referenced by a single other abstraction and directly depends on just one abstraction. Therefore it does not exhibit hub-like modularization (no large number of incoming and outgoing dependencies)."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserMethodDeclaration",
        "detection": false,
        "justification": "False because the class has many outgoing dependencies (14 distinct external abstractions: com.github.javaparser.resolution.MethodUsage, com.github.javaparser.resolution.Context, com.github.javaparser.ast.AccessSpecifier, com.github.javaparser.resolution.SymbolResolver, com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade, com.github.javaparser.resolution.declarations.ResolvedParameterDeclaration, com.github.javaparser.resolution.types.ResolvedType, com.github.javaparser.ast.body.MethodDeclaration, com.github.javaparser.resolution.TypeSolver, com.github.javaparser.ast.expr.ObjectCreationExpr, com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration, com.github.javaparser.ast.Node, com.github.javaparser.resolution.Navigator, com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFactory) but has no incoming dependencies (incoming_dependencies is empty). The Hub-like Modularization smell requires an abstraction to have a large number of both incoming and outgoing dependencies; the absence of incoming dependencies means this class does not meet the definition."
    },
    {
        "identifier": "(default package).X.A",
        "detection": false,
        "justification": "The class has 0 incoming dependencies and 0 outgoing dependencies. Hub-like Modularization requires an abstraction to have dependencies (both incoming and outgoing) with a large number of other abstractions; since both dependency counts are zero, the smell is not present."
    },
    {
        "identifier": "com.github.javaparser.ast.validator.language_level_validations.Java22Validator",
        "detection": false,
        "justification": "Java22Validator has outgoing dependencies to 3 abstractions (com.github.javaparser.ast.validator.ProblemReporter, com.github.javaparser.ast.validator.Validator, com.github.javaparser.ast.Node) and has 0 incoming dependencies. Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies. Because incoming dependencies are absent and the outgoing count is small, the smell is not detected for this class."
    },
    {
        "identifier": "com.github.javaparser.ast.body.VariableDeclarator",
        "detection": true,
        "justification": "VariableDeclarator exhibits hub-like modularization: it has a large number of incoming dependents (≈37 distinct classes/modules reference it) including many visitor implementations (e.g. com.github.javaparser.ast.visitor.VoidVisitor, GenericVisitor, VoidVisitorAdapter, ModifierVisitor, EqualsVisitor, HashCodeVisitor, PrettyPrintVisitor), symbol-solver / context classes (e.g. com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade, TypeExtractor, JavaParserVariableDeclaration, VariableDeclaratorContext), printers (PrettyPrintVisitor, LexicalPreservingPrinter) and many AST node classes (FieldDeclaration, VariableDeclarationExpr, ForEachStmt, Navigator). It also has a substantial outgoing dependency set (17 entries) on a wide variety of core abstractions such as com.github.javaparser.ast.expr.NameExpr, com.github.javaparser.ast.expr.Expression, com.github.javaparser.ast.type.Type and ArrayType, com.github.javaparser.ast.Node, com.github.javaparser.TokenRange, com.github.javaparser.Range, metamodels (JavaParserMetaModel, VariableDeclaratorMetaModel), resolution types (ResolvedValueDeclaration) and utilities (com.github.javaparser.utils.Utils, Pair, ObservableProperty). The combination of high fan-in (many diverse callers) and significant fan-out (many diverse collaborators) supports the detection of a hub-like abstraction."
    },
    {
        "identifier": "main.Clazz",
        "detection": false,
        "justification": "Class has 0 incoming dependencies and 0 outgoing dependencies. Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; since both counts are zero, the smell is not present."
    },
    {
        "identifier": "com.github.javaparser.metamodel.CompactConstructorDeclarationMetaModel",
        "detection": false,
        "justification": "The class has only 1 outgoing dependency (com.github.javaparser.metamodel.PropertyMetaModel) and 2 incoming dependencies (com.github.javaparser.ast.body.CompactConstructorDeclaration and com.github.javaparser.metamodel.JavaParserMetaModel). These counts are low and do not show the class having dependencies with a large number of other abstractions, so it does not exhibit Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver.ExceptionHandlers",
        "detection": false,
        "justification": "The class has 0 outgoing dependencies (outgoing_dependencies is empty) and only 1 incoming dependency (from com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver, as shown in incoming_dependencies). Hub-like Modularization requires an abstraction to have incoming and outgoing relationships with a large number of other abstractions; this class does not meet that criterion."
    },
    {
        "identifier": "com.github.javaparser.ast.type.IntersectionType",
        "detection": true,
        "justification": "IntersectionType has a large number of incoming dependencies (≈21 distinct clients) including many visitor and utility classes (e.g., com.github.javaparser.symbolsolver.javaparsermodel.DefaultVisitorAdapter, multiple com.github.javaparser.ast.visitor classes such as GenericVisitor, VoidVisitor, HashCodeVisitor, EqualsVisitor, CloneVisitor, PrettyPrintVisitor, GeneratedJavaParser, DefaultPrettyPrinterVisitor, NodeFinderVisitor). It also has a non-trivial set of outgoing dependencies (13) on core/central abstractions (e.g., com.github.javaparser.ast.Node, com.github.javaparser.ast.NodeList, com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.metamodel.IntersectionTypeMetaModel, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.resolution.types.ResolvedIntersectionType, com.github.javaparser.resolution.types.ResolvedType, com.github.javaparser.Range). The combination of many incoming references from diverse visitors/tools and multiple outgoing ties to core AST, meta-model and resolution types indicates IntersectionType acts as a hub-like abstraction."
    },
    {
        "identifier": "com.github.javaparser.ast.expr.NormalAnnotationExpr",
        "detection": true,
        "justification": "NormalAnnotationExpr has many outgoing dependencies (13 distinct abstractions listed in the analyzed package: NameExpr, VoidVisitor, Name, NormalAnnotationExprMetaModel, Range, Expression, NodeList, JavaParserMetaModel, TokenRange, ObservableProperty, Node, GenericVisitor, MemberValuePair) and is heavily referenced by a large number of other abstractions (at least 22 incoming dependents in the provided data, e.g. DefaultVisitorAdapter, NodeWithAnnotations, VoidVisitor, HashCodeVisitor, GenericVisitor, ModifierVisitor, EqualsVisitor, CloneVisitor, VoidVisitorAdapter, GeneratedJavaParser, PrettyPrintVisitor, DefaultPrettyPrinterVisitor, NodeFinderVisitor, Expression, etc.). The presence of both high outgoing fan-out (13) and high incoming fan-in (≈22 distinct callers/visitors) indicates the class serves as a hub and therefore exhibits the Hub-like Modularization smell."
    },
    {
        "identifier": "com.github.javaparser.metamodel.ModuleRequiresDirectiveMetaModel",
        "detection": false,
        "justification": "ModuleRequiresDirectiveMetaModel has only one outgoing dependency (com.github.javaparser.metamodel.PropertyMetaModel) and only two incoming dependencies (com.github.javaparser.ast.modules.ModuleRequiresDirective and com.github.javaparser.metamodel.JavaParserMetaModel). Hub-like Modularization requires an abstraction to have dependencies (both incoming and outgoing) with a large number of other abstractions; the provided data shows low fan-in (2) and low fan-out (1), so this class is not a hub."
    },
    {
        "identifier": "com.github.javaparser.GeneratedJavaParser",
        "detection": false,
        "justification": "Although GeneratedJavaParser has a very large number of outgoing dependencies (the outgoing_dependencies list includes dozens of distinct AST node, expression, statement, type and utility classes such as com.github.javaparser.ast.stmt.IfStmt, com.github.javaparser.ast.expr.MethodCallExpr, com.github.javaparser.TokenRange, com.github.javaparser.JavaToken, com.github.javaparser.GeneratedJavaParserTokenManager, com.github.javaparser.ast.NodeList, com.github.javaparser.ast.expr.Expression, com.github.javaparser.utils.Pair, etc.), it has very few incoming dependencies in the provided data. Only two classes are shown as depending on it (com.github.javaparser.JavaParser and com.github.javaparser.ParseStart). The Hub-like Modularization smell requires an abstraction to have many incoming and many outgoing dependencies; here the outgoing side is large but the incoming side is small, so the smell is not detected."
    },
    {
        "identifier": "com.example.Alpha",
        "detection": false,
        "justification": "Alpha has 0 outgoing dependencies and only 1 incoming dependency (from com.example.Beta). Hub-like Modularization requires an abstraction to have many incoming and outgoing dependencies; Alpha does not meet that condition."
    },
    {
        "identifier": "com.github.javaparser.ast.comments.BlockComment",
        "detection": false,
        "justification": "Incoming references are numerous: 21 different classes/modules in the provided incoming_dependencies reference BlockComment (examples: com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.symbolsolver.javaparsermodel.DefaultVisitorAdapter, com.github.javaparser.printer.PrettyPrintVisitor, com.github.javaparser.ast.comments.CommentsCollection, com.github.javaparser.ast.comments.Comment, etc.). Outgoing dependencies from BlockComment are limited: it depends on 6 abstractions (com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.metamodel.BlockCommentMetaModel, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.TokenRange, com.github.javaparser.Range). The Hub-like Modularization smell requires an abstraction to have a large number of both incoming and outgoing dependencies; here BlockComment has many incoming but only a small set of outgoing dependencies, so it does not qualify as a hub-like module."
    },
    {
        "identifier": "foo.bar.BinaryExpr.Operator",
        "detection": false,
        "justification": "Not detected: incoming_dependencies = 0 and outgoing_dependencies = 0 (no dependencies listed for the class), so it does not have a large number of incoming and outgoing relationships required for Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.ast.body.AnnotationMemberDeclaration",
        "detection": true,
        "justification": "The class has a large number of both outgoing and incoming dependencies. Outgoing: 15 direct dependencies (e.g. com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.Range, com.github.javaparser.metamodel.AnnotationMemberDeclarationMetaModel, com.github.javaparser.ast.expr.Expression, com.github.javaparser.ast.comments.JavadocComment, com.github.javaparser.ast.NodeList, com.github.javaparser.ast.expr.SimpleName, com.github.javaparser.TokenRange, com.github.javaparser.resolution.declarations.ResolvedAnnotationMemberDeclaration, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.ast.type.Type, com.github.javaparser.ast.Node, com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.ast.visitor.GenericVisitor). Incoming: 23 distinct dependents (many visitor and tooling classes such as com.github.javaparser.ast.visitor.VoidVisitor, GenericVisitor, HashCodeVisitor, EqualsVisitor, PrettyPrintVisitor, DefaultPrettyPrinterVisitor, multiple visitor adapters and validators, com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserAnnotationMemberDeclaration, com.github.javaparser.GeneratedJavaParser, etc.). Because it centrally connects to many other abstractions on both ends (numerous classes depend on it and it depends on many), it matches the Hub-like Modularization smell."
    },
    {
        "identifier": "com.github.javaparser.ast.validator.language_level_validations.Java19Validator",
        "detection": false,
        "justification": "Hub-like Modularization is characterized by an abstraction having dependencies (both incoming and outgoing) with a large number of other abstractions. This class has 0 outgoing dependencies and 0 incoming dependencies (both dependency lists are empty), so it does not act as a hub."
    },
    {
        "identifier": "com.github.javaparser.ast.validator.postprocessors.Java24PostProcessor",
        "detection": false,
        "justification": "Incoming dependencies: 0; Outgoing dependencies: 0. The class has no incoming or outgoing links to other abstractions in the provided data, so it does not exhibit hub-like modularization (no large number of dependencies). Analysis performed considering the class in isolation."
    },
    {
        "identifier": "com.github.javaparser.ast.nodeTypes.NodeWithTypeParameters",
        "detection": false,
        "justification": "NodeWithTypeParameters has only 3 outgoing dependencies (com.github.javaparser.ast.type.TypeParameter, com.github.javaparser.StaticJavaParser, com.github.javaparser.ast.NodeList) and a single incoming dependency (com.github.javaparser.symbolsolver.javaparsermodel.contexts.JavaParserTypeDeclarationAdapter). Hub-like Modularization requires an abstraction to have dependencies with a large number of other abstractions in both directions; the provided data shows only a small number of incoming and outgoing relationships, so this is not a hub."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.contexts.ObjectCreationContext",
        "detection": false,
        "justification": "Outgoing dependencies (10): com.github.javaparser.resolution.model.SymbolReference, com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade, com.github.javaparser.resolution.types.ResolvedType, com.github.javaparser.resolution.TypeSolver, com.github.javaparser.ast.expr.Expression, com.github.javaparser.ast.expr.ObjectCreationExpr, com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration, com.github.javaparser.ast.Node, com.github.javaparser.resolution.Navigator, com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFactory. Incoming dependencies (1): com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserAnonymousClassDeclaration. Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing relationships; here outgoing is relatively high (10) but incoming is very low (1), so this class does not qualify as a hub."
    },
    {
        "identifier": "foo.C",
        "detection": false,
        "justification": "Class foo.C has a single outgoing dependency (foo.A) and no incoming dependencies. Hub-like Modularization requires many incoming and outgoing dependencies to numerous other abstractions; the provided data shows only one outgoing and zero incoming, so the smell is not present."
    },
    {
        "identifier": "com.github.javaparser.ast.type.UnknownType",
        "detection": true,
        "justification": "UnknownType has a large number of incoming relationships (20 distinct classes reference it: e.g. com.github.javaparser.symbolsolver.javaparsermodel.DefaultVisitorAdapter, com.github.javaparser.ast.type.Type, com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.printer.PrettyPrintVisitor, com.github.javaparser.printer.DefaultPrettyPrinterVisitor, plus many other visitor/adapter/hash/equality/clone classes) while also depending on multiple core abstractions (8 outgoing dependencies: com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.resolution.Context, com.github.javaparser.metamodel.UnknownTypeMetaModel, com.github.javaparser.resolution.types.ResolvedType, com.github.javaparser.ast.NodeList, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.TokenRange, com.github.javaparser.ast.visitor.GenericVisitor). Because it has numerous incoming and outgoing ties to many different abstractions, it functions as a hub-like module and thus exhibits the Hub-like Modularization smell."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.contexts.ConditionalExprContext",
        "detection": false,
        "justification": "Not detected: Hub-like Modularization requires an abstraction to have many incoming and outgoing dependencies. ConditionalExprContext has no incoming dependencies (incoming_dependencies is empty) and only five outgoing dependencies: com.github.javaparser.symbolsolver.javaparsermodel.PatternVariableResult, com.github.javaparser.resolution.TypeSolver, com.github.javaparser.symbolsolver.javaparsermodel.PatternVariableVisitor, com.github.javaparser.ast.Node, and com.github.javaparser.ast.expr.ConditionalExpr. The absence of incoming links and the relatively small number of outgoing links means it does not meet the hub-like criteria."
    },
    {
        "identifier": "main.Clazz.MyEnum",
        "detection": false,
        "justification": "Hub-like Modularization is not detected because the class has 0 incoming dependencies and 0 outgoing dependencies. The smell requires an abstraction to have a large number of both incoming and outgoing dependencies, which is not the case here."
    },
    {
        "identifier": "com.github.javaparser.metamodel.ArrayCreationExprMetaModel",
        "detection": false,
        "justification": "Outgoing dependencies are minimal: only com.github.javaparser.metamodel.PropertyMetaModel (1 outgoing). Incoming dependencies are limited to two distinct classes: com.github.javaparser.ast.expr.ArrayCreationExpr and com.github.javaparser.metamodel.JavaParserMetaModel (2 incoming). Although JavaParserMetaModel itself lists many meta-models, that represents a single incoming dependency from JavaParserMetaModel to ArrayCreationExprMetaModel, not many independent incoming connections. Because the analyzed class has only 1 outgoing and 2 incoming dependencies (not a large number on both sides), it does not exhibit Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.resolution.typeinference.ConstraintFormulaSet",
        "detection": false,
        "justification": "ConstraintFormulaSet has a small number of relationships: 3 outgoing dependencies (com.github.javaparser.resolution.TypeSolver, com.github.javaparser.symbolsolver.resolution.typeinference.ConstraintFormula, com.github.javaparser.symbolsolver.resolution.typeinference.BoundSet) and 2 incoming dependencies (com.github.javaparser.symbolsolver.resolution.typeinference.TypeInference, com.github.javaparser.symbolsolver.resolution.typeinference.BoundSet). Hub-like Modularization requires an abstraction to have incoming and outgoing dependencies with a large number of other abstractions; the observed in-degree and out-degree here are low. Although BoundSet appears both as incoming and outgoing (reciprocal dependency), the overall coupling cardinality is not large enough to qualify as a hub."
    },
    {
        "identifier": "com.github.javaparser.generator.core.node.CloneGenerator",
        "detection": false,
        "justification": "CloneGenerator has no incoming dependencies (incoming_dependencies is empty) and only six direct outgoing dependencies (com.github.javaparser.StaticJavaParser, com.github.javaparser.metamodel.BaseNodeMetaModel, com.github.javaparser.ast.CompilationUnit, com.github.javaparser.ast.body.ClassOrInterfaceDeclaration, com.github.javaparser.ast.body.MethodDeclaration, com.github.javaparser.utils.SourceRoot). Hub-like Modularization requires an abstraction to have many incoming and outgoing relationships; CloneGenerator does not meet that criterion."
    },
    {
        "identifier": "extends_duplicate.A.DuplicateTypeName",
        "detection": false,
        "justification": "The class has 0 incoming dependencies and 0 outgoing dependencies (incoming_dependencies and outgoing_dependencies are empty), so it does not interact with a large number of other abstractions and therefore does not exhibit hub-like modularization."
    },
    {
        "identifier": "com.github.javaparser.ast.AccessSpecifier",
        "detection": false,
        "justification": "AccessSpecifier has a large number of incoming dependencies (37 distinct classes reference it, e.g. com.github.javaparser.symbolsolver.reflectionmodel.ReflectionMethodDeclaration, com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserMethodDeclaration, com.github.javaparser.ast.Modifier, com.github.javaparser.ast.body.MethodDeclaration, com.github.javaparser.resolution.declarations.HasAccessSpecifier), but it has no outgoing dependencies (outgoing_dependencies is empty). Hub-like Modularization requires an abstraction to have both many incoming and many outgoing dependencies; because AccessSpecifier lacks outgoing dependencies, it is not a hub-like module."
    },
    {
        "identifier": "com.github.javaparser.printer.lexicalpreservation.Reshuffled",
        "detection": false,
        "justification": "Reshuffled has a small set of connections: 3 outgoing dependencies (com.github.javaparser.printer.concretesyntaxmodel.CsmElement, com.github.javaparser.printer.lexicalpreservation.DifferenceElement, com.github.javaparser.printer.concretesyntaxmodel.CsmMix) and only 1 incoming dependency (com.github.javaparser.printer.lexicalpreservation.ReshuffledDiffElementExtractor). Hub-like Modularization requires an abstraction to have many incoming and outgoing relationships with other abstractions; the counts and listed dependencies here are limited, so the smell is not present."
    },
    {
        "identifier": "com.github.javaparser.resolution.declarations.ResolvedMethodLikeDeclaration",
        "detection": false,
        "justification": "ResolvedMethodLikeDeclaration has a small number of direct outgoing dependencies (3: ResolvedReferenceTypeDeclaration, ResolvedParameterDeclaration, ResolvedType) and a small number of incoming dependents (3: JavaSymbolSolver, JavassistMethodLikeDeclarationAdapter, MethodResolutionLogic). Although one outgoing neighbor (ResolvedType) itself depends on many types, the smell definition requires the abstraction itself to have many incoming and outgoing relationships. Given only 3 incoming and 3 outgoing direct relationships in the provided data, this class does not qualify as hub-like modularization."
    },
    {
        "identifier": "com.github.javaparser.metamodel.ModuleProvidesDirectiveMetaModel",
        "detection": false,
        "justification": "Incoming dependencies are limited to 2 classes: com.github.javaparser.ast.modules.ModuleProvidesDirective and com.github.javaparser.metamodel.JavaParserMetaModel. Outgoing dependencies are limited to 1 class: com.github.javaparser.metamodel.PropertyMetaModel. With only 2 incoming and 1 outgoing dependency, this abstraction does not have dependencies with a large number of other abstractions and therefore does not exhibit Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.printer.Stringable",
        "detection": false,
        "justification": "The provided data shows 0 incoming dependencies and 0 outgoing dependencies for com.github.javaparser.printer.Stringable, so it does not have dependencies with a large number of other abstractions and therefore is not a hub-like module."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.resolution.typeinference.LeastUpperBoundLogic.TypeSubstitution",
        "detection": false,
        "justification": "The class has 0 outgoing dependencies and only 1 incoming dependency (from com.github.javaparser.symbolsolver.resolution.typeinference.LeastUpperBoundLogic). Hub-like Modularization requires an abstraction to have incoming and/or outgoing ties with a large number of other abstractions; this class does not meet that condition."
    },
    {
        "identifier": "com.github.javaparser.resolution.cache.CacheStats",
        "detection": false,
        "justification": "CacheStats has 0 outgoing dependencies and 5 incoming dependencies (com.github.javaparser.symbolsolver.cache.InMemoryCache, com.github.javaparser.symbolsolver.cache.NoCache, com.github.javaparser.symbolsolver.cache.GuavaCache, com.github.javaparser.symbolsolver.cache.DefaultCacheStats, com.github.javaparser.resolution.cache.Cache). Hub-like Modularization requires an abstraction to have many both incoming and outgoing dependencies; since CacheStats has no outgoing dependencies and only a small number of incoming dependents, it does not meet the hub-like criteria."
    },
    {
        "identifier": "com.github.javaparser.Range",
        "detection": false,
        "justification": "The provided data shows that Range has a very large number of incoming dependencies from many AST and utility classes (examples: com.github.javaparser.ast.Node, com.github.javaparser.ast.CompilationUnit, com.github.javaparser.ast.type.Type, com.github.javaparser.ast.body.MethodDeclaration, com.github.javaparser.ast.expr.Expression, com.github.javaparser.ast.stmt.Statement, com.github.javaparser.ast.comments.Comment, com.github.javaparser.utils.PositionUtils, com.github.javaparser.printer.lexicalpreservation.LexicalPreservingPrinter, com.github.javaparser.serialization.JavaParserJsonSerializer, etc.). However, Range has only a single outgoing dependency in the provided data: com.github.javaparser.Position (and Position itself depends on Node). Because the definition of Hub-like Modularization requires an abstraction to have dependencies in both directions with a large number of other abstractions, Range does not qualify: it has high incoming coupling but low outgoing coupling (outgoing degree = 1), so the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.ast.nodeTypes.NodeWithThrownExceptions",
        "detection": false,
        "justification": "Hub-like Modularization requires an abstraction to have many incoming and outgoing dependencies. This class has 0 incoming dependencies (incoming_dependencies is empty) and only 3 outgoing dependencies: com.github.javaparser.ast.type.ReferenceType, com.github.javaparser.StaticJavaParser, com.github.javaparser.ast.NodeList. Therefore it does not exhibit the hub-like modularization smell."
    },
    {
        "identifier": "(default package).InnerClassContainer",
        "detection": false,
        "justification": "Incoming dependencies = 0 and outgoing dependencies = 0. The class has no dependencies (neither incoming nor outgoing) with other abstractions, so it does not exhibit Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.resolution.typeinference.bounds.SameAsBound",
        "detection": false,
        "justification": "SameAsBound has only 3 outgoing dependencies (InferenceVariableSubstitution, TypeHelper, ResolvedType) and only 1 incoming dependency (BoundSet). The class does not have dependencies (incoming and outgoing) with a large number of other abstractions, so it does not meet the Hub-like Modularization smell criteria."
    },
    {
        "identifier": "com.github.javaparser.ast.expr.LambdaExpr",
        "detection": true,
        "justification": "LambdaExpr has a high incoming degree (31 different abstractions depend on it, e.g. JavaParserFacade, TypeExtractor, TypeInference, TypeHelper, many visitor implementations such as VoidVisitor, GenericVisitor, ModifierVisitor, CloneVisitor, PrettyPrintVisitor, GeneratedJavaParser/GeneratedJavaParserBase, DefaultPrettyPrinterVisitor) while also having multiple outgoing dependencies (13) to core AST and meta classes (e.g. com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.stmt.Statement, com.github.javaparser.Range, com.github.javaparser.ast.expr.Expression, com.github.javaparser.ast.NodeList, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.TokenRange, com.github.javaparser.metamodel.LambdaExprMetaModel, com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.ast.Node, com.github.javaparser.ast.body.Parameter, com.github.javaparser.ast.stmt.BlockStmt). The combination of many incoming and many outgoing dependencies matches the Hub-like Modularization smell."
    },
    {
        "identifier": "com.github.javaparser.printer.lexicalpreservation.DifferenceElementCalculator",
        "detection": true,
        "justification": "The class has a large set of outgoing dependencies (9): com.github.javaparser.printer.concretesyntaxmodel.CsmToken, com.github.javaparser.printer.lexicalpreservation.NodeText, com.github.javaparser.printer.lexicalpreservation.DifferenceElementCalculator.ChildPositionInfo, com.github.javaparser.printer.lexicalpreservation.TokenTextElement, com.github.javaparser.printer.concretesyntaxmodel.CsmElement, com.github.javaparser.ast.Node, com.github.javaparser.printer.lexicalpreservation.ChildTextElement, com.github.javaparser.printer.lexicalpreservation.LexicalPreservingPrinter, com.github.javaparser.printer.lexicalpreservation.LexicalDifferenceCalculator. It also has multiple incoming dependencies (2) from: com.github.javaparser.printer.lexicalpreservation.LexicalDifferenceCalculator and com.github.javaparser.printer.lexicalpreservation.ReshuffledDiffElementExtractor. Notably, there is a bidirectional relationship with LexicalDifferenceCalculator (it appears in both outgoing and incoming lists). The combination of many outgoing ties to core AST and concrete-syntax classes (e.g., Node, CsmElement, CsmToken) together with multiple incoming callers indicates the class functions as a central hub connecting many abstractions, satisfying the Hub-like Modularization smell."
    },
    {
        "identifier": "com.github.javaparser.ast.expr.UnaryExpr.Operator",
        "detection": false,
        "justification": "The class has only 1 incoming dependency (from com.github.javaparser.ast.expr.UnaryExpr) and 0 outgoing dependencies. Hub-like Modularization requires an abstraction to have dependencies (both incoming and outgoing) with a large number of other abstractions. Although the incoming class (com.github.javaparser.ast.expr.UnaryExpr) references many other types, the analyzed class itself does not exhibit multiple incoming/outgoing connections, so the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.printer.configuration.PrinterConfiguration",
        "detection": false,
        "justification": "PrinterConfiguration has many incoming dependencies (10 distinct classes reference it: com.github.javaparser.ast.CompilationUnit, com.github.javaparser.ast.Node, com.github.javaparser.printer.ConfigurablePrinter, com.github.javaparser.printer.SourcePrinter, com.github.javaparser.printer.DefaultPrettyPrinter, com.github.javaparser.printer.PrettyPrinter, com.github.javaparser.printer.DefaultPrettyPrinterVisitor, com.github.javaparser.printer.configuration.DefaultPrinterConfiguration, com.github.javaparser.printer.configuration.PrettyPrinterConfiguration, com.github.javaparser.generator.metamodel.MetaModelGenerator) but only a single outgoing dependency (com.github.javaparser.printer.configuration.ConfigurationOption). Hub-like Modularization requires an abstraction to have dependencies (both incoming and outgoing) with a large number of other abstractions; the low outgoing degree prevents this from being classified as hub-like."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserAnonymousClassDeclaration",
        "detection": false,
        "justification": "The class has a moderate number of outgoing dependencies (≈15 distinct types such as TypeSolver, ResolvedTypeDeclaration, SymbolReference, ResolvedReferenceType, JavaParserFacade, AstResolutionUtils, ResolvedType, Context, ObjectCreationExpr, AccessSpecifier, ObjectCreationContext, ResolvedReferenceTypeDeclaration, ClassOrInterfaceType, JavaParserFactory) but only two incoming dependents are listed (JavaParserFacade and AnonymousClassDeclarationContext). Hub-like Modularization requires an abstraction to have dependencies both incoming and outgoing with a large number of other abstractions. Because incoming coupling is low (2) despite multiple outgoing links, this class does not meet the criterion for a hub-like module."
    },
    {
        "identifier": "com.github.javaparser.metamodel.ComponentPatternExprMetaModel",
        "detection": false,
        "justification": "ComponentPatternExprMetaModel has no outgoing dependencies (dependencies: []). It has only two incoming references recorded: com.github.javaparser.ast.expr.ComponentPatternExpr and com.github.javaparser.metamodel.JavaParserMetaModel. Although JavaParserMetaModel itself references many meta-model classes, ComponentPatternExprMetaModel is referenced by only these two classes and does not depend on many others. Hub-like Modularization requires an abstraction to have both a large number of incoming and outgoing dependencies; this class lacks that pattern (no outgoing deps and only minimal incoming refs), so it is not a hub."
    },
    {
        "identifier": "com.github.javaparser.metamodel.ConstructorDeclarationMetaModel",
        "detection": false,
        "justification": "ConstructorDeclarationMetaModel has only 1 outgoing dependency (com.github.javaparser.metamodel.PropertyMetaModel) and 2 incoming dependencies (com.github.javaparser.ast.body.ConstructorDeclaration and com.github.javaparser.metamodel.JavaParserMetaModel). A hub-like module would show a large number of both incoming and outgoing connections; here the direct incoming and outgoing counts are low, so the smell is not present."
    },
    {
        "identifier": "com.github.javaparser.JavaParser",
        "detection": true,
        "justification": "JavaParser has a large set of outgoing dependencies (20 distinct types in the provided data) across many subsystems (examples: com.github.javaparser.ast.expr.Expression, com.github.javaparser.ast.comments.Comment / LineComment / CommentsCollection, com.github.javaparser.ast.CompilationUnit, com.github.javaparser.ParserConfiguration, com.github.javaparser.GeneratedJavaParser, com.github.javaparser.ParseResult, com.github.javaparser.ast.Node). It also has multiple incoming dependents from different packages (at least 6 provided: com.github.javaparser.symbolsolver.resolution.typesolvers.JavaParserTypeSolver, com.github.javaparser.StaticJavaParser, com.github.javaparser.JavaParserAdapter, com.github.javaparser.utils.SourceRoot, com.github.javaparser.utils.CollectionStrategy, com.github.javaparser.utils.SourceZip). Because the class both depends on many other abstractions and is depended upon by many other abstractions, it exhibits the Hub-like Modularization smell."
    },
    {
        "identifier": "main.Main",
        "detection": false,
        "justification": "The class has outgoing dependencies to main.Main.NestedEnum, main.Child, and main.A (3 outgoing), but has no incoming dependencies. Hub-like Modularization requires many both incoming and outgoing dependencies; because incoming_dependencies = 0, this class is not a hub."
    },
    {
        "identifier": "com.github.javaparser.ast.modules.ModuleDirective",
        "detection": true,
        "justification": "ModuleDirective has outgoing dependencies to 8 distinct abstractions (com.github.javaparser.ast.modules.ModuleUsesDirective, com.github.javaparser.ast.modules.ModuleExportsDirective, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.TokenRange, com.github.javaparser.metamodel.ModuleDirectiveMetaModel, com.github.javaparser.ast.modules.ModuleProvidesDirective, com.github.javaparser.ast.modules.ModuleOpensDirective, com.github.javaparser.ast.modules.ModuleRequiresDirective) and receives incoming dependencies from 4 distinct abstractions (com.github.javaparser.ast.modules.ModuleDeclaration, com.github.javaparser.StaticJavaParser, com.github.javaparser.JavaParserAdapter, com.github.javaparser.GeneratedJavaParser). Because it both depends on many module-related directive/meta-model classes and is referenced by multiple parser and module-declaration classes, it acts as a central hub connecting numerous abstractions, matching the Hub-like Modularization smell."
    },
    {
        "identifier": "com.github.javaparser.metamodel.LiteralExprMetaModel",
        "detection": false,
        "justification": "LiteralExprMetaModel has no outgoing dependencies (outgoing_dependencies = []). It has only two incoming dependencies: com.github.javaparser.ast.expr.LiteralExpr and com.github.javaparser.metamodel.JavaParserMetaModel. A hub-like modularization requires an abstraction to have a large number of both incoming and outgoing ties. Here incoming count is small (2) and outgoing count is zero, so it does not meet the hub-like criteria. Note: JavaParserMetaModel depends on many meta-model classes (including LiteralExprMetaModel), but that makes JavaParserMetaModel highly connected rather than making LiteralExprMetaModel a hub."
    },
    {
        "identifier": "com.github.javaparser.ast.validator.language_level_validations.chunks.VarValidator",
        "detection": false,
        "justification": "VarValidator has only outgoing dependencies to 3 abstractions (ProblemReporter, VariableDeclarationExpr, VarType) and has no incoming dependencies (incoming_dependencies is empty). Hub-like Modularization requires an abstraction to have both many incoming and many outgoing dependencies; VarValidator lacks incoming edges and only references three classes, so it does not meet the hub-like criteria. Note: the detailed dependency lists of the three outgoing classes do not create incoming dependencies to VarValidator and therefore do not make it a hub."
    },
    {
        "identifier": "com.github.javaparser.ast.expr.VariableDeclarationExpr",
        "detection": true,
        "justification": "VariableDeclarationExpr exhibits hub-like modularization: it has a large incoming fan-in (referenced by many distinct abstractions — e.g. numerous visitor and visitor-adapter classes such as com.github.javaparser.ast.visitor.VoidVisitor, GenericVisitor, VoidVisitorAdapter, GenericVisitorAdapter, HashCodeVisitor, EqualsVisitor, PrettyPrintVisitor, DefaultPrettyPrinterVisitor, GenericListVisitorAdapter, CloneVisitor, NodeFinderVisitor; symbol-solver and context classes such as com.github.javaparser.symbolsolver.javaparsermodel.DefaultVisitorAdapter, TypeExtractor, VariableSymbolDeclarator, JavaParserVariableDeclaration, BlockStmtContext, ForStatementContext, VariableDeclarationExprContext, ControlFlowLogic; parsers/adapters like GeneratedJavaParser, StaticJavaParser, JavaParserAdapter; and validators like ModifierValidator and VarValidator), totaling on the order of dozens of incoming dependents. It also has a non-trivial outgoing fan-out (it depends on many core abstractions: com.github.javaparser.ast.Node, com.github.javaparser.ast.type.Type, com.github.javaparser.ast.body.VariableDeclarator, com.github.javaparser.ast.NodeList, com.github.javaparser.ast.Modifier, com.github.javaparser.metamodel.JavaParserMetaModel and VariableDeclarationExprMetaModel, com.github.javaparser.TokenRange, com.github.javaparser.Range, com.github.javaparser.ast.observer.ObservableProperty, etc.). The combination of many incoming references from diverse subsystems and multiple outgoing dependencies to core AST and meta-model types qualifies this class as a hub-like abstraction."
    },
    {
        "identifier": "com.github.javaparser.metamodel.FieldDeclarationMetaModel",
        "detection": false,
        "justification": "FieldDeclarationMetaModel has low connectivity: only 1 outgoing dependency (com.github.javaparser.metamodel.PropertyMetaModel) and only 2 incoming dependencies (com.github.javaparser.ast.body.FieldDeclaration and com.github.javaparser.metamodel.JavaParserMetaModel). A hub-like modularization would show many incoming and outgoing dependencies; these counts are small and do not indicate a hub."
    },
    {
        "identifier": "com.github.javaparser.ast.Node",
        "detection": true,
        "justification": "The class has both a large set of outgoing dependencies and a very large set of incoming dependencies, matching the Hub-like Modularization smell. Outgoing dependencies (explicit in the analyzed_package) include many unrelated abstractions such as com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.Position, com.github.javaparser.printer.Printer, com.github.javaparser.ast.comments.Comment, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.TokenRange, com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.ast.NodeList, com.github.javaparser.resolution.SymbolResolver, com.github.javaparser.Range, com.github.javaparser.ast.Node.Parsedness and others (24 distinct outgoing entries). Incoming dependencies show that dozens of other classes across many packages depend on Node (for example com.github.javaparser.symbolsolver.JavaSymbolSolver, many symbolsolver.* classes, com.github.javaparser.ast.type.* classes such as UnionType, ArrayType, TypeParameter, ClassOrInterfaceType, many ast.body.* classes like MethodDeclaration, ClassOrInterfaceDeclaration, VariableDeclarator, numerous ast.stmt.* classes, many visitor implementations, printers, lexical-preservation and serialization components, observers and validators). Because Node both depends on many other abstractions and is depended upon by a very large number of other abstractions across the codebase, it functions as a central hub and therefore exhibits Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.ParserConfiguration.LanguageLevel",
        "detection": false,
        "justification": "The class has only 2 outgoing dependencies (com.github.javaparser.ast.validator.Validator, com.github.javaparser.ast.validator.postprocessors.PostProcessors) and a single incoming dependency (from com.github.javaparser.ParserConfiguration). Hub-like modularization requires many incoming and outgoing relationships; the provided data shows low fan-in and fan-out, so this is not a hub."
    },
    {
        "identifier": "com.github.javaparser.metamodel.CommentMetaModel",
        "detection": false,
        "justification": "CommentMetaModel has only 1 outgoing dependency (com.github.javaparser.metamodel.PropertyMetaModel) and only 2 incoming dependencies listed (com.github.javaparser.ast.comments.Comment and com.github.javaparser.metamodel.JavaParserMetaModel). The definition of Hub-like Modularization requires an abstraction to have dependencies (both incoming and outgoing) with a large number of other abstractions; the provided data shows only a small number of incoming/outgoing relationships, so the smell is not detected."
    },
    {
        "identifier": "(default package).a",
        "detection": false,
        "justification": "Class (default package).a has 0 incoming dependencies and 0 outgoing dependencies (incoming_dependencies: [], outgoing_dependencies: []). It does not depend on, nor is depended upon by, a large number of other abstractions, so it does not exhibit Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.metamodel.TypePatternExprMetaModel",
        "detection": false,
        "justification": "Outgoing dependencies: only 1 (com.github.javaparser.metamodel.PropertyMetaModel). Incoming dependents: only 2 (com.github.javaparser.ast.expr.TypePatternExpr and com.github.javaparser.metamodel.JavaParserMetaModel). The class does not have a large number of incoming and outgoing relationships, so it does not exhibit Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.resolution.naming.NameLogic.PredicateOnParentAndChild",
        "detection": false,
        "justification": "PredicateOnParentAndChild has 0 outgoing dependencies (empty dependencies list) and only 1 incoming dependency (NameLogic). Although NameLogic depends on many types, the analyzed class itself does not have a large number of incoming and outgoing relationships; therefore it does not meet the Hub-like Modularization smell criteria."
    },
    {
        "identifier": "com.github.javaparser.ast.type.PrimitiveType",
        "detection": true,
        "justification": "PrimitiveType has a relatively large number of outgoing dependencies (13 distinct abstractions in the provided data: com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.resolution.Context, com.github.javaparser.ast.type.PrimitiveType.Primitive, com.github.javaparser.resolution.types.ResolvedType, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.ast.NodeList, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.TokenRange, com.github.javaparser.resolution.types.ResolvedPrimitiveType, com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.ast.type.ClassOrInterfaceType, com.github.javaparser.Range, com.github.javaparser.metamodel.PrimitiveTypeMetaModel) and is referenced by many incoming abstractions (≈25 distinct clients in the provided data, including numerous visitor implementations and utilities such as VoidVisitor, GenericVisitor, HashCodeVisitor, EqualsVisitor, CloneVisitor, PrettyPrintVisitor, DefaultPrettyPrinterVisitor, GeneratedJavaParser, JavaParserMetaModel, and symbol-solver classes like JavaParserFacade and TypeExtractor). Because it both depends on many other abstractions and is depended upon by a large number of other abstractions, PrimitiveType exhibits the hub-like modularization smell."
    },
    {
        "identifier": "main.Main.NestedEnum",
        "detection": false,
        "justification": "The class has 0 outgoing dependencies and only 1 incoming dependency (from main.Main). Hub-like Modularization requires an abstraction to have many incoming and outgoing connections; with only a single incoming link and no outgoing links, this class does not meet that criterion."
    },
    {
        "identifier": "com.github.javaparser.generator.core.node.AcceptGenerator",
        "detection": false,
        "justification": "AcceptGenerator has 0 incoming dependencies and 6 outgoing dependencies (StaticJavaParser, BaseNodeMetaModel, CompilationUnit, ClassOrInterfaceDeclaration, MethodDeclaration, SourceRoot). Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies. In isolation, AcceptGenerator does not exhibit a large number of incoming dependencies and its outgoing count (6) is not indicative of a hub, so the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.metamodel.MethodReferenceExprMetaModel",
        "detection": false,
        "justification": "MethodReferenceExprMetaModel has low direct coupling: 1 outgoing dependency (com.github.javaparser.metamodel.PropertyMetaModel) and 2 incoming dependencies (com.github.javaparser.ast.expr.MethodReferenceExpr and com.github.javaparser.metamodel.JavaParserMetaModel). Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; this class does not exhibit that. (Although JavaParserMetaModel references many meta-model classes, that reflects JavaParserMetaModel's high connectivity, not many direct connections of MethodReferenceExprMetaModel itself.)"
    },
    {
        "identifier": "com.github.javaparser.metamodel.ArrayCreationLevelMetaModel",
        "detection": false,
        "justification": "ArrayCreationLevelMetaModel has only 1 outgoing dependency (com.github.javaparser.metamodel.PropertyMetaModel) and only 2 incoming dependents (com.github.javaparser.ast.ArrayCreationLevel and com.github.javaparser.metamodel.JavaParserMetaModel). The number of distinct incoming and outgoing connections is small, so it does not meet the 'hub-like' criteria of having dependencies with a large number of other abstractions."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.resolution.typeinference.constraintformulas.LambdaThrowsCompatibleWithType",
        "detection": false,
        "justification": "The class has outgoing dependencies to 3 distinct abstractions (com.github.javaparser.resolution.types.ResolvedType, com.github.javaparser.symbolsolver.resolution.typeinference.BoundSet, com.github.javaparser.ast.expr.LambdaExpr) but has 0 incoming dependencies. Hub-like Modularization requires an abstraction to have both a large number of incoming and outgoing dependencies; the absence of incoming dependencies means this class does not exhibit a hub-like modularization smell."
    },
    {
        "identifier": "com.github.javaparser.resolution.types.ResolvedWildcard.BoundType",
        "detection": false,
        "justification": "ResolvedWildcard.BoundType has 0 outgoing dependencies and only 1 incoming dependency (from com.github.javaparser.resolution.types.ResolvedWildcard). Hub-like Modularization requires an abstraction to have dependencies with a large number of other abstractions (many incoming and/or outgoing links); the provided data shows minimal connections, so the smell is not present."
    },
    {
        "identifier": "com.github.javaparser.ast.Node.TreeTraversal",
        "detection": false,
        "justification": "Not detected: Node.TreeTraversal has 0 outgoing dependencies and only 1 incoming dependency (from com.github.javaparser.ast.Node). Hub-like Modularization requires an abstraction to have many incoming and many outgoing dependencies; the provided dependency counts are low and do not meet that criterion."
    },
    {
        "identifier": "com.github.javaparser.ast.PackageDeclaration",
        "detection": true,
        "justification": "PackageDeclaration has a high number of both incoming and outgoing dependencies within the provided data. Outgoing dependencies (12) include core/runtime and meta-model types such as com.github.javaparser.ast.expr.NameExpr, com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.expr.Name, com.github.javaparser.Range, com.github.javaparser.ast.NodeList, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.TokenRange, com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.ast.Node, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.metamodel.PackageDeclarationMetaModel and com.github.javaparser.utils.Utils — showing it depends on many different abstractions. Incoming dependencies are numerous (examples include com.github.javaparser.symbolsolver.javaparsermodel.DefaultVisitorAdapter, com.github.javaparser.ast.CompilationUnit, many visitor implementations such as com.github.javaparser.ast.visitor.VoidVisitor, GenericVisitor, EqualsVisitor, HashCodeVisitor, ModifierVisitor, CloneVisitor, PrettyPrintVisitor, DefaultPrettyPrinterVisitor, and framework entry points like com.github.javaparser.StaticJavaParser and com.github.javaparser.GeneratedJavaParser). The class therefore acts as a hub with many distinct modules depending on it and depending on many modules itself, matching the Hub-like Modularization smell."
    },
    {
        "identifier": "(default package).Main",
        "detection": false,
        "justification": "Incoming dependencies count = 0 (incoming_dependencies: []). Outgoing dependencies count = 0 (outgoing_dependencies: []). With no incoming or outgoing links to other abstractions, the class does not exhibit hub-like modularization."
    },
    {
        "identifier": "com.github.javaparser.ast.stmt.EmptyStmt",
        "detection": false,
        "justification": "EmptyStmt has a large number of incoming dependencies (22 different classes depend on it, e.g. com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.GeneratedJavaParser, com.github.javaparser.printer.PrettyPrintVisitor, com.github.javaparser.ast.stmt.Statement), but a small set of outgoing dependencies (6: com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.TokenRange, com.github.javaparser.metamodel.EmptyStmtMetaModel, com.github.javaparser.Range). Since the smell 'Hub-like Modularization' requires an abstraction to have many dependencies both incoming and outgoing, EmptyStmt does not meet that criterion (many incoming but limited outgoing), so it is not detected as a hub."
    },
    {
        "identifier": "com.github.javaparser.ast.visitor.VoidVisitorAdapter",
        "detection": false,
        "justification": "Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies. VoidVisitorAdapter has a large number of outgoing dependencies (107 distinct dependent classes listed) but has 0 incoming dependencies (incoming_dependencies is empty). Because the incoming dependency count is zero, the criterion of having large dependencies in both directions is not met, so this is not detected as Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.contexts.MethodReferenceExprContext",
        "detection": false,
        "justification": "The class has a large number of outgoing dependencies (18 distinct dependencies: SymbolReference, MethodUsage, FunctionalInterfaceLogic, JavaParserFacade, ResolvedType, VariableDeclarator, ReturnStmt, TypeSolver, ObjectCreationExpr, MethodReferenceExpr, ResolvedMethodDeclaration, ResolvedConstructorDeclaration, ResolvedLambdaConstraintType, Navigator, InferenceContext, MethodResolutionLogic, MethodCallExpr, etc.) but has zero incoming dependencies (incoming_dependencies is empty). Hub-like Modularization requires an abstraction to have both many incoming and many outgoing dependencies; because there are no incoming dependencies, this class does not meet the definition of a hub."
    },
    {
        "identifier": "com.github.javaparser.printer.lexicalpreservation.changes.Change",
        "detection": false,
        "justification": "Direct outgoing dependencies count = 4 (com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.utils.Utils, com.github.javaparser.printer.concretesyntaxmodel.CsmConditional, com.github.javaparser.ast.Node). Direct incoming dependencies count = 1 (com.github.javaparser.printer.lexicalpreservation.LexicalDifferenceCalculator). Because Change has a small number of direct incoming and outgoing relationships, it does not exhibit Hub-like Modularization. Note: some target classes have many dependencies themselves, but per the isolation constraint the Change class is evaluated only by its own direct incoming/outgoing links."
    },
    {
        "identifier": "com.github.javaparser.generator.metamodel.MetaModelGenerator",
        "detection": false,
        "justification": "MetaModelGenerator has a significant number of outgoing dependencies (14 distinct targets, e.g. com.github.javaparser.ParserConfiguration, com.github.javaparser.StaticJavaParser, com.github.javaparser.ast.CompilationUnit, com.github.javaparser.generator.metamodel.NodeMetaModelGenerator, com.github.javaparser.utils.SourceRoot), but only 3 incoming dependents in the provided data (com.github.javaparser.generator.metamodel.NodeMetaModelGenerator, InitializeConstructorParametersStatementsGenerator, InitializePropertyMetaModelsStatementsGenerator). The Hub-like Modularization smell requires an abstraction to have dependencies with a large number of other abstractions in both directions (many incoming and many outgoing). Because incoming connections are few while outgoing are many, the class does not meet the definition of a hub-like module in the given dataset."
    },
    {
        "identifier": "com.github.javaparser.metamodel.ArrayAccessExprMetaModel",
        "detection": false,
        "justification": "ArrayAccessExprMetaModel has only 1 outgoing dependency (com.github.javaparser.metamodel.PropertyMetaModel) and only 2 incoming dependents (com.github.javaparser.ast.expr.ArrayAccessExpr and com.github.javaparser.metamodel.JavaParserMetaModel). A hub-like modularization requires an abstraction to have many incoming and many outgoing relationships; the provided data shows neither a large outgoing fan‑out nor a large incoming fan‑in for this class. Note: JavaParserMetaModel references many meta-model classes, but that represents one incoming link to ArrayAccessExprMetaModel rather than many bidirectional dependencies involving ArrayAccessExprMetaModel."
    },
    {
        "identifier": "groovy.transform.builder.DefaultStrategy",
        "detection": false,
        "justification": "Both incoming and outgoing dependency lists are empty (incoming_dependencies: [], outgoing_dependencies: []), and the analyzed_package dependencies are also empty. With no incoming or outgoing connections to other abstractions, the class cannot be a hub-like module."
    },
    {
        "identifier": "com.github.javaparser.utils.SourceRoot.ParallelParse",
        "detection": false,
        "justification": "The class has only one outgoing dependency (com.github.javaparser.utils.SourceRoot) and only one incoming dependency (com.github.javaparser.utils.SourceRoot). Hub-like Modularization requires many incoming and outgoing dependencies with many other abstractions. Although SourceRoot itself lists many dependencies (com.github.javaparser.ParserConfiguration, com.github.javaparser.utils.CodeGenerationUtils, com.github.javaparser.utils.SourceRoot.VisitFileCallback, com.github.javaparser.utils.SourceRoot.Callback, com.github.javaparser.ast.CompilationUnit, com.github.javaparser.JavaParser, com.github.javaparser.utils.SourceRoot.ParallelParse, com.github.javaparser.utils.Log, com.github.javaparser.ParseResult), those are not direct incoming/outgoing dependencies of the analyzed class per the provided data."
    },
    {
        "identifier": "(default package).Test1.Test2",
        "detection": false,
        "justification": "The class has no incoming or outgoing dependencies (incoming_dependencies = [], outgoing_dependencies = []). analyzed_package.dependencies is also []. Hub-like Modularization requires many incoming and outgoing connections; since both dependency lists are empty, this class is not a hub."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.resolution.typeinference.BoundSet.Processor",
        "detection": false,
        "justification": "Outgoing dependencies for this class are empty (no outgoing edges). There is a single incoming dependency entry (from com.github.javaparser.symbolsolver.resolution.typeinference.BoundSet). Although BoundSet's dependency list references many types, BoundSet.Processor itself has only one incoming relationship and zero outgoing relationships in the provided data, so it does not exhibit a hub-like pattern of having many incoming and outgoing dependencies."
    },
    {
        "identifier": "com.github.javaparser.metamodel.NameExprMetaModel",
        "detection": false,
        "justification": "NameExprMetaModel has only 1 outgoing dependency (com.github.javaparser.metamodel.PropertyMetaModel) and 2 incoming dependents (com.github.javaparser.ast.expr.NameExpr and com.github.javaparser.metamodel.JavaParserMetaModel). The counts of both incoming and outgoing connections are small, so it does not exhibit hub-like modularization. (Although JavaParserMetaModel references many meta-models, that only indicates a single incoming dependency to NameExprMetaModel, not many incoming/outgoing links for NameExprMetaModel itself.)"
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.resolution.typeinference.BoundSet",
        "detection": true,
        "justification": "BoundSet exhibits hub-like modularization: it has a high fan-out (19 outgoing dependencies) to many abstractions such as InferenceVariable, TypeHelper, InstantiationSet, Bound, Substitution, ConstraintFormulaSet, TypeSameAsType, TypeSubtypeOfType, various bounds (SubtypeOfBound, CapturesBound, SameAsBound), Pair, and others; and a high fan-in (12 incoming dependencies) where many other classes depend on it, including TypeInference, ConstraintFormulaSet, ConstraintFormula, ConstraintFormula.ReductionResult, InstantiationSet, and multiple constraint-formula classes (ExpressionCompatibleWithType, TypeSubtypeOfType, TypeSameAsType, TypeCompatibleWithType, TypeContainedByType, LambdaThrowsCompatibleWithType, MethodReferenceThrowsCompatibleWithType). The combination of many incoming and outgoing relationships makes BoundSet a central hub between many abstractions."
    },
    {
        "identifier": "com.github.javaparser.ast.validator.language_level_validations.Java9Validator",
        "detection": false,
        "justification": "Hub-like Modularization requires an abstraction to have both incoming and outgoing dependencies with a large number of other abstractions. Java9Validator has no incoming dependencies (incoming_dependencies is empty) and only two outgoing dependencies (com.github.javaparser.ast.validator.Validator and com.github.javaparser.ast.validator.SingleNodeTypeValidator). Because there are no incoming links and the number of outgoing links is small, the conditions for a hub-like modularization smell are not met."
    },
    {
        "identifier": "com.github.javaparser.ast.comments.MarkdownComment",
        "detection": true,
        "justification": "MarkdownComment has a large number of incoming dependencies (21 distinct classes reference it, including many visitor and utility classes such as com.github.javaparser.ast.visitor.VoidVisitor, GenericVisitor, HashCodeVisitor, EqualsVisitor, PrettyPrintVisitor, Comment, GeneratedJavaParserTokenManager, GeneratedJavaParserTokenManagerBase) while also having multiple outgoing dependencies (6 distinct classes: com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.metamodel.MarkdownCommentMetaModel, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.TokenRange, com.github.javaparser.utils.LineSeparator, com.github.javaparser.ast.visitor.GenericVisitor). The presence of many incoming links from diverse visitors/token managers plus several outgoing links to meta-models, visitors and token/token-range utilities indicates a hub-like role, satisfying the Hub-like Modularization smell."
    },
    {
        "identifier": "com.github.javaparser.ast.validator.postprocessors.Java15PostProcessor",
        "detection": false,
        "justification": "Incoming dependencies: 0; Outgoing dependencies: 0. Hub-like Modularization requires an abstraction to have dependencies (both incoming and outgoing) with a large number of other abstractions. With zero incoming and zero outgoing dependencies, this class does not exhibit hub-like modularization."
    },
    {
        "identifier": "com.github.javaparser.ast.validator.postprocessors.Java10PostProcessor",
        "detection": false,
        "justification": "Java10PostProcessor has outgoing dependencies to 4 abstractions (com.github.javaparser.Processor, com.github.javaparser.ast.type.ClassOrInterfaceType, com.github.javaparser.ParseResult, com.github.javaparser.ParserConfiguration) and has 0 incoming dependencies. Hub-like Modularization requires an abstraction to have dependencies (both incoming and outgoing) with a large number of other abstractions; here the outgoing set is small (4) and there are no incoming dependencies, so it is not a hub."
    },
    {
        "identifier": "extends_duplicate.A",
        "detection": false,
        "justification": "The class has no incoming or outgoing dependencies (incoming_dependencies = 0, outgoing_dependencies = 0). Hub-like Modularization requires an abstraction to have many incoming and outgoing dependencies; since both dependency lists are empty, the smell is not present."
    },
    {
        "identifier": "com.github.javaparser.metamodel.DoStmtMetaModel",
        "detection": false,
        "justification": "DoStmtMetaModel has only one outgoing dependency (com.github.javaparser.metamodel.PropertyMetaModel) and only two incoming dependents (com.github.javaparser.ast.stmt.DoStmt and com.github.javaparser.metamodel.JavaParserMetaModel). Hub-like modularization requires an abstraction to have many incoming and many outgoing dependencies. Although JavaParserMetaModel depends on many meta-model classes, that reflects JavaParserMetaModel being highly connected, not DoStmtMetaModel. The small number of direct incoming (2) and outgoing (1) relationships means DoStmtMetaModel is not a hub."
    },
    {
        "identifier": "com.github.javaparser.ast.expr.PatternExpr",
        "detection": false,
        "justification": "PatternExpr has a limited number of direct outgoing dependencies (8): com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.TokenRange, com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.ast.Node, com.github.javaparser.ast.type.Type, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.metamodel.PatternExprMetaModel. It is directly referenced by a small set of incoming classes (5): com.github.javaparser.ast.visitor.ModifierVisitor, com.github.javaparser.ast.visitor.CloneVisitor, com.github.javaparser.ast.expr.Expression, com.github.javaparser.ast.expr.InstanceOfExpr, com.github.javaparser.GeneratedJavaParser. Because the class, considered in isolation, exhibits only a modest number of direct incoming and outgoing couplings, it does not meet the criterion of having dependencies with a large number of other abstractions and therefore is not a hub-like modularization smell."
    },
    {
        "identifier": "(default package).ConstantA",
        "detection": false,
        "justification": "ConstantA has only 1 outgoing dependency ((default package).B) and 1 incoming dependency ((default package).StackOverflowTestCase). The class interacts with a very small number of other abstractions, so it does not exhibit Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.ast.validator.language_level_validations.Java8Validator",
        "detection": false,
        "justification": "Java8Validator has 0 incoming dependencies and only 1 outgoing dependency (to com.github.javaparser.ast.validator.Validator). Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; this class does not meet that criterion."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.contexts.InstanceOfExprContext",
        "detection": false,
        "justification": "InstanceOfExprContext has multiple outgoing dependencies (com.github.javaparser.resolution.model.SymbolReference; com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserTypePatternDeclaration; com.github.javaparser.resolution.Context; com.github.javaparser.resolution.TypeSolver; com.github.javaparser.ast.expr.TypePatternExpr; com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserSymbolDeclaration; com.github.javaparser.ast.expr.InstanceOfExpr) but has no incoming dependencies. Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; since incoming_dependencies = 0, this class does not meet the hub-like criterion."
    },
    {
        "identifier": "com.github.javaparser.metamodel.SwitchEntryMetaModel",
        "detection": false,
        "justification": "SwitchEntryMetaModel has a small number of dependencies: only one outgoing dependency (com.github.javaparser.metamodel.PropertyMetaModel) and two incoming dependents (com.github.javaparser.ast.stmt.SwitchEntry and com.github.javaparser.metamodel.JavaParserMetaModel). Hub-like Modularization is characterized by an abstraction having incoming and outgoing relationships with a large number of other abstractions; the provided data shows low incoming and outgoing counts, so the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.resolution.logic.ConstructorResolutionLogic",
        "detection": false,
        "justification": "ConstructorResolutionLogic has a small number of incoming and outgoing relationships: 2 incoming dependents (com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade, com.github.javaparser.symbolsolver.javaparsermodel.contexts.JavaParserTypeDeclarationAdapter) and 5 outgoing dependencies (com.github.javaparser.resolution.model.SymbolReference, com.github.javaparser.resolution.TypeSolver, com.github.javaparser.resolution.logic.MethodResolutionLogic, com.github.javaparser.resolution.declarations.ResolvedConstructorDeclaration, com.github.javaparser.resolution.types.ResolvedType). Because the class does not exhibit dependencies with a large number of other abstractions on both incoming and outgoing sides, it does not meet the definition of Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.printer.lexicalpreservation.changes.ListAdditionChange",
        "detection": false,
        "justification": "Hub-like Modularization requires an abstraction to have dependencies both incoming and outgoing with a large number of other abstractions. The analyzed class has 0 incoming dependencies (incoming_dependencies is empty) and only 4 outgoing dependencies: com.github.javaparser.printer.lexicalpreservation.changes.NoChange, com.github.javaparser.ast.NodeList, com.github.javaparser.ast.observer.ObservableProperty, and com.github.javaparser.ast.Node. Because there are no incoming dependencies and only a small set of outgoing links, it does not meet the criteria for a hub-like module."
    },
    {
        "identifier": "com.github.javaparser.ast.visitor.HashCodeVisitor",
        "detection": false,
        "justification": "HashCodeVisitor has many outgoing dependencies to dozens of AST types and related classes (examples: TraditionalJavadocComment, WildcardType, UnaryExpr, TextBlockLiteralExpr, YieldStmt, ImportDeclaration, MethodDeclaration, ClassOrInterfaceDeclaration, CompilationUnit, ClassOrInterfaceType, Node, etc.), but it has only a single incoming dependency shown: com.github.javaparser.ast.Node lists HashCodeVisitor as a dependent. The Hub-like Modularization smell requires an abstraction to have a large number of both incoming and outgoing dependencies; here outgoing is large but incoming is minimal (only Node), so the class is not a hub by the given data."
    },
    {
        "identifier": "(default package).ConvolutionLayer",
        "detection": false,
        "justification": "Both incoming_dependencies and outgoing_dependencies are empty. ConvolutionLayer has 0 incoming and 0 outgoing dependencies, so it does not have dependencies with a large number of other abstractions and therefore is not a hub-like module."
    },
    {
        "identifier": "com.github.javaparser.ast.observer.AstObserverAdapter",
        "detection": false,
        "justification": "AstObserverAdapter has 3 outgoing dependencies (com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.ast.Node, com.github.javaparser.ast.NodeList) and 0 incoming dependencies. Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; here the incoming dependency count is zero and the outgoing count is small, so this class is not a hub."
    },
    {
        "identifier": "com.github.javaparser.printer.SourcePrinter",
        "detection": false,
        "justification": "SourcePrinter has many incoming dependencies (19 distinct classes depend on it: PrettyPrintVisitor, DefaultPrettyPrinterVisitor, ConcreteSyntaxModel, CsmTextBlock, CsmOrphanCommentsEnding, CsmMix, CsmChar, CsmSingleReference, CsmAttribute, CsmList, CsmConditional, CsmNone, CsmSequence, CsmString, CsmIndent, CsmComment, CsmUnindent, CsmToken, CsmElement) but only 5 outgoing dependencies (com.github.javaparser.utils.Utils, com.github.javaparser.printer.configuration.PrinterConfiguration, com.github.javaparser.printer.configuration.PrettyPrinterConfiguration, com.github.javaparser.Position, com.github.javaparser.printer.configuration.Indentation). The Hub-like Modularization smell requires an abstraction to have a large number of both incoming and outgoing dependency relationships; SourcePrinter exhibits high incoming but low outgoing coupling, so the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserTypeVariableDeclaration",
        "detection": false,
        "justification": "The class has many outgoing dependencies (12 distinct abstractions: Context, SymbolReference, ResolvedTypeParameterDeclaration, JavaParserFacade, AstResolutionUtils, ResolvedType, ResolvedFieldDeclaration, TypeSolver, ResolvedReferenceTypeDeclaration, Node, Type, TypeParameter) but only a single incoming dependency recorded (JavaParserFacade). Hub-like Modularization requires an abstraction to have both a large number of incoming and outgoing dependencies. Although there is bidirectional coupling with JavaParserFacade, the incoming coupling count is low (1) while outgoing is high (12), so the class does not meet the definition of a hub (many incoming and many outgoing)."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.resolution.typeinference.TypeHelper",
        "detection": true,
        "justification": "TypeHelper has a large number of both outgoing and incoming dependencies. Outgoing: TypeHelper depends on at least 15 distinct abstractions (examples: ResolvedType, TypeSolver, Expression, LambdaExpr, JavaParserFacade, MethodType, ResolvedWildcard, ResolvedPrimitiveType, ReferenceTypeImpl, ResolvedReferenceTypeDeclaration, FunctionalInterfaceLogic, LeastUpperBoundLogic, Pair, SymbolReference). Incoming: at least 10 distinct abstractions depend on TypeHelper (examples: BoundSet, LeastUpperBoundLogic, TypeContainedByType, ExpressionCompatibleWithType, TypeCompatibleWithType, TypeSubtypeOfType, TypeSameAsType, SubtypeOfBound, SameAsBound, ReferenceConditionalExprHandler). The presence of many callers from diverse type-inference constraint and bounds classes plus many core type/system dependencies indicates TypeHelper acts as a central hub, satisfying the Hub-like Modularization smell."
    },
    {
        "identifier": "com.github.javaparser.ast.expr.Expression",
        "detection": true,
        "justification": "The class has a large number of both outgoing and incoming dependencies. Outgoing: 47 distinct dependent abstractions (examples: com.github.javaparser.ast.expr.LiteralStringValueExpr, NameExpr, BinaryExpr, MethodCallExpr, CastExpr, com.github.javaparser.resolution.types.ResolvedType, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.TokenRange). Incoming: 76 distinct abstractions depend on Expression (examples: com.github.javaparser.symbolsolver.JavaSymbolSolver, com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade, com.github.javaparser.symbolsolver.javaparsermodel.TypeExtractor, com.github.javaparser.printer.PrettyPrintVisitor, com.github.javaparser.ast.visitor.ModifierVisitor, com.github.javaparser.ast.visitor.CloneVisitor, many AST node/statement types such as IfStmt, ForStmt, ReturnStmt, ExpressionStmt, SwitchStmt, and node types like NodeWithExpression/NodeWithArguments). The high counts of both incoming (≈76) and outgoing (≈47) couplings show Expression functions as a central hub, meeting the Hub-like Modularization smell criteria."
    },
    {
        "identifier": "com.github.javaparser.ast.expr.IntegerLiteralExpr",
        "detection": false,
        "justification": "IntegerLiteralExpr has a high number of incoming dependencies (≈25 different classes reference it, e.g. many visitor types such as VoidVisitor/GenericVisitor and their adapters/implementations, Expression, GeneratedJavaParser, PrettyPrintVisitor, TokenKindGenerator), indicating high fan-in. However, its outgoing dependency set is small (7 direct dependencies: com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.metamodel.IntegerLiteralExprMetaModel, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.TokenRange, com.github.javaparser.Range, com.github.javaparser.utils.Utils), i.e. low fan-out. The Hub-like Modularization smell requires large numbers of both incoming and outgoing dependencies; here only incoming is large while outgoing is modest, so the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.ast.expr.DoubleLiteralExpr",
        "detection": false,
        "justification": "DoubleLiteralExpr has a relatively small set of outgoing dependencies (6: com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.TokenRange, com.github.javaparser.metamodel.DoubleLiteralExprMetaModel, com.github.javaparser.Range) but a larger number of incoming dependencies (22 distinct classes depend on it, primarily many visitor and utility classes such as VoidVisitor, GenericVisitor, HashCodeVisitor, EqualsVisitor, CloneVisitor, Expression, GeneratedJavaParser, PrettyPrintVisitor, DefaultPrettyPrinterVisitor, etc.). Hub-like Modularization requires an abstraction to have both many incoming and many outgoing relationships. Because DoubleLiteralExpr exhibits many incoming but only few outgoing dependencies in the provided data, it does not meet the criterion for a hub-like module."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.declarators.AbstractSymbolDeclarator",
        "detection": false,
        "justification": "Not detected: the class has 0 incoming dependencies and only 1 outgoing dependency (to com.github.javaparser.resolution.TypeSolver). Although that outgoing target depends on 3 other abstractions, the analyzed class itself does not exhibit a large number of both incoming and outgoing dependencies required for Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.utils.ParserCollectionStrategy",
        "detection": false,
        "justification": "ParserCollectionStrategy has only 1 incoming dependency (demo.Main) and 2 outgoing dependencies (com.github.javaparser.ParserConfiguration, com.github.javaparser.utils.ProjectRoot). These counts do not indicate dependencies with a large number of other abstractions. Note: while ParserConfiguration itself depends on many classes, the analysis is limited to ParserCollectionStrategy in isolation."
    },
    {
        "identifier": "(default package).ObjectContext",
        "detection": false,
        "justification": "ObjectContext has 0 incoming dependencies and 0 outgoing dependencies (no links to other abstractions). Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; given the absence of dependencies in isolation, this class is not a hub."
    },
    {
        "identifier": "com.github.javaparser.generator.core.visitor.ObjectIdentityEqualsVisitorGenerator",
        "detection": false,
        "justification": "Incoming dependencies: 0 (no classes depend on this class). Outgoing dependencies: 5 distinct target classes (com.github.javaparser.metamodel.BaseNodeMetaModel, com.github.javaparser.ast.stmt.BlockStmt, com.github.javaparser.ast.CompilationUnit, com.github.javaparser.ast.body.MethodDeclaration, com.github.javaparser.utils.SourceRoot). Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; this class has no incoming dependencies and only a modest number of outgoing dependencies, so it does not exhibit the smell."
    },
    {
        "identifier": "com.github.javaparser.resolution.SymbolResolver",
        "detection": false,
        "justification": "SymbolResolver has a small number of direct outgoing dependencies (5): com.github.javaparser.ast.expr.Expression, com.github.javaparser.resolution.types.ResolvedType, com.github.javaparser.ast.Node, com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration, com.github.javaparser.ast.type.Type. It has a small number of direct incoming dependencies (4): com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade, com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserMethodDeclaration, com.github.javaparser.ast.Node, com.github.javaparser.ParserConfiguration. Although some of those referenced types (e.g., Expression, Node) themselves list many internal dependencies, the analysis must consider SymbolResolver in isolation and count its direct incoming/outgoing relationships — those counts are not large enough to qualify as Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.resolution.typeinference.constraintformulas.TypeCompatibleWithType",
        "detection": false,
        "justification": "TypeCompatibleWithType has multiple outgoing dependencies (ResolvedType, TypeSolver, ReflectionTypeSolver, ReferenceTypeImpl, BoundSet, TypeHelper) but has no incoming dependencies. Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing relationships; because incoming_dependencies is empty, the class does not exhibit the hub-like modularization smell in isolation."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javassistmodel.JavassistTypeParameter",
        "detection": false,
        "justification": "Hub-like modularization not detected: the class has 4 outgoing dependencies (com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration, com.github.javaparser.resolution.TypeSolver, com.github.javaparser.resolution.declarations.ResolvedTypeParametrizable, com.github.javaparser.resolution.types.ResolvedReferenceType) and 0 incoming dependencies. A hub requires a large number of both incoming and outgoing links; here incoming dependencies are absent and the outgoing count is small. Even though some outgoing targets themselves depend on many types, the analysis must consider the class in isolation, so it is not a hub."
    },
    {
        "identifier": "com.github.javaparser.ast.expr.TextBlockLiteralExpr",
        "detection": false,
        "justification": "Incoming dependencies are numerous: many visitor and utility classes depend on TextBlockLiteralExpr (examples include com.github.javaparser.ast.visitor.VoidVisitor, GenericVisitor, VoidVisitorAdapter, EqualsVisitor, HashCodeVisitor, PrettyPrintVisitor, DefaultPrettyPrinterVisitor, com.github.javaparser.GeneratedJavaParser, com.github.javaparser.symbolsolver.javaparsermodel.TypeExtractor, etc.), indicating high incoming coupling. However, outgoing dependencies from TextBlockLiteralExpr are limited (only 6 provided): com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.TokenRange, com.github.javaparser.metamodel.TextBlockLiteralExprMetaModel, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.utils.StringEscapeUtils. Because the class does not exhibit a large number of outgoing dependencies, it does not meet the definition requirement of having both large incoming and large outgoing dependency sets; therefore Hub-like Modularization is not detected."
    },
    {
        "identifier": "(default package).PackageDotExpressions",
        "detection": false,
        "justification": "The class has 1 outgoing dependency (com.packageName.ClassInPackage) and 0 incoming dependencies. Hub-like Modularization requires an abstraction to have many incoming and outgoing dependencies; the provided counts are low, so the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserAnnotationMemberDeclaration",
        "detection": false,
        "justification": "Hub-like Modularization requires the abstraction to have many incoming and many outgoing dependencies. The analyzed class has outgoing dependencies to 7 distinct abstractions: com.github.javaparser.resolution.Context, com.github.javaparser.ast.body.AnnotationMemberDeclaration, com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade, com.github.javaparser.resolution.types.ResolvedType, com.github.javaparser.resolution.TypeSolver, com.github.javaparser.ast.expr.Expression, and com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFactory (outgoing count = 7). However, it has zero incoming dependencies (incoming_dependencies is empty). Because it lacks the required large number of incoming dependencies, it does not meet the definition of a hub-like module."
    },
    {
        "identifier": "(default package).Test.InnerTest",
        "detection": false,
        "justification": "No hub-like modularization: incoming_dependencies is empty and outgoing_dependencies is empty (analyzed_package.dependencies is also empty), so the class has no incoming or outgoing relations with other abstractions and therefore cannot be a hub."
    },
    {
        "identifier": "com.github.javaparser.printer.configuration.DefaultConfigurationOption",
        "detection": false,
        "justification": "DefaultConfigurationOption has only 1 outgoing dependency: com.github.javaparser.printer.configuration.ConfigurationOption, and only 1 incoming dependency: com.github.javaparser.generator.metamodel.MetaModelGenerator. Hub-like Modularization requires an abstraction to have many incoming and many outgoing dependencies; this class does not exhibit that pattern."
    },
    {
        "identifier": "com.example.ConstructorParameterTest",
        "detection": false,
        "justification": "The class has 1 outgoing dependency (com.github.javaparser.quality.Preconditions) and 0 incoming dependencies. Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; this class does not meet that condition, so the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.utils.CodeGenerationUtils",
        "detection": false,
        "justification": "CodeGenerationUtils has incoming dependencies from 4 distinct abstractions: com.github.javaparser.metamodel.PropertyMetaModel, com.github.javaparser.utils.SourceRoot, com.github.javaparser.generator.metamodel.NodeMetaModelGenerator, com.github.javaparser.generator.metamodel.InitializePropertyMetaModelsStatementsGenerator. It has an outgoing dependency to only 1 abstraction: com.github.javaparser.utils.Utils. The Hub-like Modularization smell requires an abstraction to have both many incoming and many outgoing dependencies; here the outgoing fan-out is minimal (1), so the class does not meet the definition of a hub."
    },
    {
        "identifier": "(default package).InnerClassContainer.InnerClass",
        "detection": false,
        "justification": "The class has 0 incoming dependencies and 0 outgoing dependencies (both empty). Hub-like Modularization requires many incoming and outgoing connections to other abstractions; with no dependencies present, this class does not meet that criterion."
    },
    {
        "identifier": "com.github.javaparser.ast.expr.MemberValuePair",
        "detection": true,
        "justification": "MemberValuePair has a large number of incoming dependencies from many distinct abstractions (numerous visitor and printer classes and parsers — e.g. com.github.javaparser.symbolsolver.javaparsermodel.DefaultVisitorAdapter, com.github.javaparser.ast.visitor.VoidVisitor, GenericVisitor, HashCodeVisitor, EqualsVisitor, CloneVisitor, GeneratedJavaParser, PrettyPrintVisitor, DefaultPrettyPrinterVisitor, ModifierVisitor, etc.), and also has multiple outgoing dependencies to core/metamodel/node types (10 direct outgoing dependencies: com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.ast.expr.Expression, com.github.javaparser.metamodel.MemberValuePairMetaModel, com.github.javaparser.ast.expr.SimpleName, com.github.javaparser.TokenRange, com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.ast.Node, com.github.javaparser.Range). Because it simultaneously connects (incoming) from many other classes and (outgoing) to multiple core abstractions, it exhibits the hub-like modularization smell."
    },
    {
        "identifier": "com.github.javaparser.generator.core.CoreGenerator",
        "detection": false,
        "justification": "CoreGenerator has direct outgoing dependencies to 4 classes: com.github.javaparser.ParserConfiguration, com.github.javaparser.StaticJavaParser, com.github.javaparser.utils.Log, and com.github.javaparser.utils.SourceRoot (direct outgoing = 4). Those target classes themselves reference many other abstractions (e.g., StaticJavaParser -> 27 dependencies, ParserConfiguration -> 9, SourceRoot -> 9, Log -> 1), so CoreGenerator's transitive coupling footprint is large. However, incoming_dependencies = 0 (no incoming links). The Hub-like Modularization smell requires an abstraction to have many incoming and outgoing dependencies; because CoreGenerator has no incoming dependencies, the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserConstructorDeclaration",
        "detection": false,
        "justification": "Not detected: the class has 0 incoming dependencies and 6 direct outgoing dependencies (com.github.javaparser.ast.AccessSpecifier, com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade, com.github.javaparser.resolution.declarations.ResolvedParameterDeclaration, com.github.javaparser.resolution.types.ResolvedType, com.github.javaparser.resolution.TypeSolver, com.github.javaparser.ast.body.ConstructorDeclaration). Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies. Although one outgoing dependency (JavaParserFacade) itself lists many transitive dependencies, the analysis must consider the class in isolation and only direct incoming/outgoing links count; here incoming = 0 and outgoing = 6, so the hub smell is not present."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javassistmodel.JavassistFactory",
        "detection": true,
        "justification": "JavassistFactory has a large number of incoming dependencies (10 distinct client classes) and multiple outgoing dependencies (6 distinct abstractions), indicating bidirectional connectivity typical of a hub. Incoming dependents include JarTypeSolver and many package peers: JavassistEnumDeclaration, JavassistMethodDeclaration, JavassistInterfaceDeclaration, JavassistConstructorDeclaration, JavassistRecordDeclaration, JavassistFieldDeclaration, JavassistClassDeclaration, JavassistParameterDeclaration, and JavassistTypeDeclarationAdapter — showing many classes rely on this factory. Outgoing dependencies include core resolution and AST abstractions: com.github.javaparser.ast.AccessSpecifier, com.github.javaparser.resolution.types.ResolvedType, com.github.javaparser.resolution.TypeSolver, ResolvedPrimitiveType, ResolvedReferenceTypeDeclaration, and ResolvedVoidType. Because it both depends on and is depended on by many core types and many peers, it functions as a hub-like abstraction."
    },
    {
        "identifier": "com.github.javaparser.ast.stmt.ContinueStmt",
        "detection": false,
        "justification": "ContinueStmt has a large number of incoming dependencies (~23 distinct clients: e.g. com.github.javaparser.symbolsolver.javaparsermodel.DefaultVisitorAdapter, com.github.javaparser.symbolsolver.javaparsermodel.NormalCompletionVisitor, com.github.javaparser.symbolsolver.resolution.typeinference.ControlFlowLogic, com.github.javaparser.ast.stmt.Statement, many visitor classes such as com.github.javaparser.ast.visitor.VoidVisitor, GenericVisitor, HashCodeVisitor, ModifierVisitor, PrettyPrintVisitor, DefaultPrettyPrinterVisitor, GeneratedJavaParser, NodeFinderVisitor, etc.), but a small set of outgoing dependencies (9 listed: com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.Range, com.github.javaparser.ast.expr.SimpleName, com.github.javaparser.TokenRange, com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.ast.Node, com.github.javaparser.metamodel.ContinueStmtMetaModel, com.github.javaparser.ast.visitor.GenericVisitor). The Hub-like Modularization smell requires both many incoming and many outgoing connections; ContinueStmt shows high incoming coupling but limited outgoing coupling, so it does not meet the 'both directions large' criterion."
    },
    {
        "identifier": "com.github.javaparser.ast.validator.language_level_validations.Java18Validator",
        "detection": false,
        "justification": "Incoming dependencies: 0; Outgoing dependencies: 0. The class has no incoming or outgoing dependencies (dependencies: []), so it does not exhibit hub-like modularization which requires many incoming and/or outgoing connections."
    },
    {
        "identifier": "package_b.b",
        "detection": false,
        "justification": "The class has 0 incoming dependencies and 0 outgoing dependencies (both dependency lists are empty). It does not have a large number of incoming and outgoing relationships, so it is not a hub-like module."
    },
    {
        "identifier": "com.github.javaparser.ast.validator.language_level_validations.Java1_0Validator",
        "detection": false,
        "justification": "Not a hub: the class has only outgoing dependencies to four abstractions (com.github.javaparser.ParserConfiguration, com.github.javaparser.ast.validator.Validator, com.github.javaparser.ast.Modifier, com.github.javaparser.ast.validator.SingleNodeTypeValidator) and has no incoming dependencies. Hub-like modularization requires extensive both incoming and outgoing coupling; incoming_dependencies is empty, so the smell is not present."
    },
    {
        "identifier": "com.github.javaparser.javasymbolsolver.javassist_symbols.main_jar.EnumInterfaceUserIncludedJar",
        "detection": false,
        "justification": "Both incoming_dependencies and outgoing_dependencies are empty (0 incoming, 0 outgoing). Hub-like Modularization requires an abstraction to have dependencies with a large number of other abstractions; this class has no incoming or outgoing dependencies, so the smell is not present."
    },
    {
        "identifier": "com.github.javaparser.generator.core.node.RemoveMethodGenerator",
        "detection": false,
        "justification": "Incoming dependencies: 0 (incoming_dependencies is empty). Outgoing dependencies: 10 distinct abstractions: com.github.javaparser.StaticJavaParser, com.github.javaparser.metamodel.BaseNodeMetaModel, com.github.javaparser.ast.stmt.BlockStmt, com.github.javaparser.utils.Utils, com.github.javaparser.ast.CompilationUnit, com.github.javaparser.ast.body.ClassOrInterfaceDeclaration, com.github.javaparser.ast.body.MethodDeclaration, com.github.javaparser.metamodel.PropertyMetaModel, com.github.javaparser.utils.SourceRoot. Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; here RemoveMethodGenerator has no incoming dependencies (zero), so it does not meet the hub-like condition despite having several outgoing links."
    },
    {
        "identifier": "com.github.javaparser.generator.core.node.ReplaceMethodGenerator",
        "detection": false,
        "justification": "ReplaceMethodGenerator has outgoing dependencies to 8 distinct abstractions (StaticJavaParser, BaseNodeMetaModel, BlockStmt, CompilationUnit, ClassOrInterfaceDeclaration, MethodDeclaration, PropertyMetaModel, SourceRoot) but has no incoming dependencies (incoming_dependencies is empty). Hub-like Modularization requires an abstraction to have both many incoming and many outgoing dependencies; because this class has zero incoming dependencies despite multiple outgoing ones, the hub-like smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.resolution.typesolvers.MemoryTypeSolver",
        "detection": false,
        "justification": "Hub-like Modularization requires an abstraction to have many incoming and many outgoing dependencies. MemoryTypeSolver has 3 outgoing dependencies (com.github.javaparser.resolution.model.SymbolReference, com.github.javaparser.resolution.TypeSolver, com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration) and 0 incoming dependencies. Because there are no incoming dependencies, it does not meet the hub-like criterion."
    },
    {
        "identifier": "com.github.javaparser.generator.core.visitor.ObjectIdentityHashCodeVisitorGenerator",
        "detection": false,
        "justification": "The class has multiple outgoing dependencies (com.github.javaparser.metamodel.BaseNodeMetaModel, com.github.javaparser.ast.stmt.BlockStmt, com.github.javaparser.ast.CompilationUnit, com.github.javaparser.ast.body.MethodDeclaration, com.github.javaparser.utils.SourceRoot) but has no incoming dependencies (incoming_dependencies is empty). Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; the absence of incoming dependencies means the smell is not present."
    },
    {
        "identifier": "com.github.javaparser.metamodel.SingleMemberAnnotationExprMetaModel",
        "detection": false,
        "justification": "SingleMemberAnnotationExprMetaModel has only 1 outgoing dependency: com.github.javaparser.metamodel.PropertyMetaModel, and only 2 incoming dependencies: com.github.javaparser.ast.expr.SingleMemberAnnotationExpr and com.github.javaparser.metamodel.JavaParserMetaModel. Hub-like Modularization requires an abstraction to have dependencies (both incoming and outgoing) with a large number of other abstractions; these counts are low. (Note: JavaParserMetaModel references many meta-models, but that represents a single incoming dependency to SingleMemberAnnotationExprMetaModel, not many incoming/outgoing links for this class.)"
    },
    {
        "identifier": "com.github.javaparser.GeneratedJavaParserTokenManager",
        "detection": false,
        "justification": "Outgoing dependencies: 9 (com.github.javaparser.SimpleCharStream, com.github.javaparser.TokenTypes, com.github.javaparser.GeneratedJavaParserTokenManagerBase, com.github.javaparser.TokenMgrException, com.github.javaparser.ast.comments.CommentsCollection, com.github.javaparser.ast.comments.Comment, com.github.javaparser.Token, com.github.javaparser.ast.comments.MarkdownComment, com.github.javaparser.JavaToken). Incoming dependencies: 2 (com.github.javaparser.GeneratedJavaParserBase, com.github.javaparser.GeneratedJavaParser). Hub-like modularization requires a large number of both incoming and outgoing links. Here the outgoing degree is moderate and the incoming degree is low (only two classes depend on it), so it does not meet the definition of a hub (high coupling in both directions). The outgoing dependencies are domain-appropriate (token/stream/comment types) and therefore do not by themselves indicate a hub smell."
    },
    {
        "identifier": "com.github.javaparser.metamodel.InstanceOfExprMetaModel",
        "detection": false,
        "justification": "The class has only 1 outgoing dependency (com.github.javaparser.metamodel.PropertyMetaModel) and only 2 incoming dependencies (com.github.javaparser.ast.expr.InstanceOfExpr and com.github.javaparser.metamodel.JavaParserMetaModel). Hub-like Modularization requires an abstraction to have dependencies (both incoming and outgoing) with a large number of other abstractions; the provided counts are small, so this is not a hub."
    },
    {
        "identifier": "a.b.c.DataObjectFactory",
        "detection": false,
        "justification": "Not detected: DataObjectFactory has 0 outgoing dependencies and only 1 incoming dependency (a.b.c.ExampleClass). Hub-like Modularization requires an abstraction to have incoming and outgoing dependencies with a large number of other abstractions, which is not the case here."
    },
    {
        "identifier": "com.github.javaparser.ast.validator.language_level_validations.Java1_2Validator",
        "detection": false,
        "justification": "Hub-like Modularization requires an abstraction to have dependencies (both incoming and outgoing) with a large number of other abstractions. This class has only one outgoing dependency: com.github.javaparser.ast.validator.Validator, and zero incoming dependencies. Outgoing count = 1 (Validator). Incoming count = 0. Therefore it does not exhibit a hub-like dependency pattern."
    },
    {
        "identifier": "com.github.javaparser.metamodel.ModuleOpensDirectiveMetaModel",
        "detection": false,
        "justification": "ModuleOpensDirectiveMetaModel has only 1 outgoing dependency (com.github.javaparser.metamodel.PropertyMetaModel) and only 2 distinct incoming dependents (com.github.javaparser.ast.modules.ModuleOpensDirective and com.github.javaparser.metamodel.JavaParserMetaModel). Although JavaParserMetaModel itself references many meta-models, it constitutes a single incoming dependency. The counts of incoming and outgoing neighboring abstractions are low, so this class does not exhibit hub-like modularization."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.contexts.TryWithResourceContext",
        "detection": false,
        "justification": "TryWithResourceContext has a significant number of outgoing dependencies (10: com.github.javaparser.resolution.model.SymbolReference, com.github.javaparser.ast.stmt.TryStmt, com.github.javaparser.resolution.TypeSolver, com.github.javaparser.symbolsolver.javaparsermodel.contexts.StatementContext, com.github.javaparser.resolution.declarations.ResolvedValueDeclaration, com.github.javaparser.ast.NodeList, com.github.javaparser.resolution.model.Value, com.github.javaparser.ast.Node, com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserSymbolDeclaration, com.github.javaparser.resolution.Navigator) but has 0 incoming dependencies. The Hub-like Modularization smell requires an abstraction to have many incoming and many outgoing dependencies; because there are no incoming dependencies, TryWithResourceContext does not meet the definition of a hub."
    },
    {
        "identifier": "com.github.javaparser.Sample",
        "detection": false,
        "justification": "The class has no incoming dependencies (incoming_dependencies = []) and no outgoing dependencies (outgoing_dependencies = []); dependency counts are 0, so it does not exhibit hub-like modularization."
    },
    {
        "identifier": "com.github.javaparser.ast.NodeList",
        "detection": false,
        "justification": "NodeList has a very large number of incoming dependencies from many classes (examples: com.github.javaparser.symbolsolver.javaparsermodel.DefaultVisitorAdapter, JavaParserFacade, TypeExtractor; many ast.* types such as com.github.javaparser.ast.type.ClassOrInterfaceType, ArrayType, PrimitiveType, UnionType; numerous visitor and printer classes such as com.github.javaparser.ast.visitor.VoidVisitor, GenericVisitor, PrettyPrintVisitor; and many others across the input). However, NodeList's outgoing dependencies are small: only com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.ast.Node and com.github.javaparser.ast.observer.AstObserver are listed. The hub-like modularization smell requires an abstraction to have dependencies in both directions with a large number of other abstractions; here only the incoming side is large while the outgoing side is limited, so the smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.Processor",
        "detection": false,
        "justification": "Processor has 3 incoming dependencies (com.github.javaparser.ast.validator.TypedValidator, com.github.javaparser.ast.validator.postprocessors.PostProcessors, com.github.javaparser.ast.validator.postprocessors.Java10PostProcessor) and 3 outgoing dependencies (com.github.javaparser.ParserConfiguration, com.github.javaparser.Provider, com.github.javaparser.ParseResult). The number of distinct incoming and outgoing connections is small, so it does not exhibit the high-degree coupling characteristic of Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.wiki_samples.TestFile",
        "detection": false,
        "justification": "Not detected: incoming_dependencies = [] (0 incoming) and outgoing_dependencies = [] (0 outgoing). The class has no incoming or outgoing relationships with other abstractions, so it cannot be a hub."
    },
    {
        "identifier": "com.github.javaparser.printer.lexicalpreservation.changes.ListReplacementChange",
        "detection": false,
        "justification": "ListReplacementChange has no incoming dependencies (incoming_dependencies = 0) and only four direct outgoing dependencies: com.github.javaparser.printer.lexicalpreservation.changes.NoChange, com.github.javaparser.ast.NodeList, com.github.javaparser.ast.observer.ObservableProperty, and com.github.javaparser.ast.Node. Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing links; here incoming = 0 and outgoing = 4, so it does not qualify as a hub. (While some of those outgoing classes themselves have many dependencies, the analysis is constrained to the class in isolation.)"
    },
    {
        "identifier": "com.github.javaparser.javasymbolsolver.javassist_symbols.main_jar.InterfaceUserExcludedJar",
        "detection": false,
        "justification": "The analyzed class has no outgoing dependencies (outgoing_dependencies = []) and no incoming dependencies (incoming_dependencies = []). The analyzed_package.dependencies is also empty. Since Hub-like Modularization requires many incoming and outgoing dependencies, the absence of both means this class is not a hub."
    },
    {
        "identifier": "com.github.javaparser.ast.expr.SwitchExpr",
        "detection": true,
        "justification": "SwitchExpr exhibits hub-like modularization: it has many outgoing dependencies (10 distinct abstractions) such as com.github.javaparser.ast.Node, com.github.javaparser.ast.expr.Expression, com.github.javaparser.ast.NodeList, com.github.javaparser.ast.stmt.SwitchEntry, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.metamodel.SwitchExprMetaModel, com.github.javaparser.TokenRange, and com.github.javaparser.ast.observer.ObservableProperty, and it has a large number of incoming dependents (21 distinct classes) including numerous visitor and utility classes (e.g. com.github.javaparser.ast.visitor.VoidVisitor, GenericVisitor, HashCodeVisitor, EqualsVisitor, ModifierVisitor, PrettyPrintVisitor, DefaultPrettyPrinterVisitor, GeneratedJavaParser, various VoidVisitor adapters). The combination of many incoming clients and many outgoing collaborators indicates the class acts as a central hub connecting a large set of abstractions."
    },
    {
        "identifier": "com.github.javaparser.printer.lexicalpreservation.LexicalDifferenceCalculator",
        "detection": true,
        "justification": "The class has a high number of both outgoing and incoming dependencies in the provided data: 20 outgoing dependencies (examples: DifferenceElementCalculator, CsmConditional, CsmAttribute, CsmList, NodeText, CsmSingleReference, CsmSequence, CsmMix, ConcreteSyntaxModel, CsmElement, Node, Difference) and 8 incoming dependencies (examples: Kept, DifferenceElementCalculator, LexicalPreservingPrinter, Removed, Difference, RemovedGroup, DifferenceElement, Added). This bidirectional connectivity to many distinct abstractions (AST Node, concrete-syntax model classes, lexical-preservation classes, printers and tokens) matches the Hub-like Modularization smell, where the abstraction acts as a central hub with numerous incoming and outgoing relationships."
    },
    {
        "identifier": "com.github.javaparser.ast.observer.Observable",
        "detection": false,
        "justification": "Observable has only 1 outgoing dependency (com.github.javaparser.ast.observer.AstObserver) and 0 incoming dependencies. Hub-like Modularization requires an abstraction to have many incoming and outgoing dependencies; Observable does not meet this criterion."
    },
    {
        "identifier": "com.github.javaparser.metamodel.EnumDeclarationMetaModel",
        "detection": false,
        "justification": "EnumDeclarationMetaModel has only 1 outgoing dependency (PropertyMetaModel) and only 2 incoming dependents (com.github.javaparser.ast.body.EnumDeclaration and com.github.javaparser.metamodel.JavaParserMetaModel). Hub-like Modularization requires an abstraction to have incoming and outgoing dependencies with a large number of other abstractions; the counts here are small and do not indicate a hub."
    },
    {
        "identifier": "foo.Foo",
        "detection": false,
        "justification": "Foo has 1 incoming dependency (from foo.Main) and 0 outgoing dependencies. Hub-like Modularization requires an abstraction to have dependencies (both incoming and outgoing) with a large number of other abstractions; Foo does not meet that condition given the provided data."
    },
    {
        "identifier": "com.github.javaparser.symbolsolver.javaparsermodel.contexts.AbstractJavaParserContext",
        "detection": true,
        "justification": "The class has a high number of outgoing dependencies (20 distinct abstractions) including core and diverse concepts such as com.github.javaparser.resolution.TypeSolver, com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade, com.github.javaparser.ast.Node, com.github.javaparser.ast.expr.Expression, com.github.javaparser.resolution.types.ResolvedType, and com.github.javaparser.resolution.Navigator. It is also the target of multiple incoming dependencies from at least six different context classes (StatementContext, LambdaExprContext, IfStatementContext, CatchClauseContext, AbstractMethodLikeDeclarationContext, SwitchEntryContext). Having many incoming and many outgoing relationships indicates the class functions as a central hub connecting many abstractions, meeting the Hub-like Modularization smell criteria."
    },
    {
        "identifier": "com.github.javaparser.ast.body.InitializerDeclaration",
        "detection": true,
        "justification": "InitializerDeclaration has a large number of incoming dependencies (≈22 distinct clients) and a non-trivial set of outgoing dependencies (10). Incoming examples include many visitors and utilities from different packages: com.github.javaparser.ast.visitor.VoidVisitor, GenericVisitor, HashCodeVisitor, EqualsVisitor, CloneVisitor, VoidVisitorAdapter, GenericVisitorAdapter, PrettyPrintVisitor, DefaultPrettyPrinterVisitor, GeneratedJavaParser, com.github.javaparser.printer.PrettyPrintVisitor, and others. Outgoing dependencies include core AST and infrastructure types: com.github.javaparser.ast.Node, com.github.javaparser.ast.stmt.BlockStmt, com.github.javaparser.ast.comments.JavadocComment, com.github.javaparser.Range, com.github.javaparser.TokenRange, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.ast.visitor.GenericVisitor, and InitializerDeclarationMetaModel. Because it is both widely depended on by many other abstractions and itself depends on many core abstractions across packages, it exhibits the hub-like modularization smell."
    },
    {
        "identifier": "com.github.javaparser.printer.lexicalpreservation.changes.ListRemovalChange",
        "detection": false,
        "justification": "Incoming dependencies: 0 (no classes depend on ListRemovalChange). Outgoing dependencies: 5 (com.github.javaparser.ast.Node, com.github.javaparser.printer.lexicalpreservation.changes.NoChange, com.github.javaparser.ast.NodeList, com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.Range). Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; ListRemovalChange has no incoming dependencies and only five outgoing dependencies, so the hub-like smell is not present."
    },
    {
        "identifier": "com.github.javaparser.metamodel.IntersectionTypeMetaModel",
        "detection": false,
        "justification": "IntersectionTypeMetaModel has only 1 outgoing dependency: com.github.javaparser.metamodel.PropertyMetaModel, and only 2 incoming dependents: com.github.javaparser.ast.type.IntersectionType and com.github.javaparser.metamodel.JavaParserMetaModel. Hub-like Modularization requires an abstraction to have dependencies (both incoming and outgoing) with a large number of other abstractions; the provided counts are low, so this class is not a hub."
    },
    {
        "identifier": "com.github.javaparser.generator.core.visitor.CloneVisitorGenerator",
        "detection": false,
        "justification": "Hub-like Modularization requires an abstraction to have many incoming and many outgoing dependencies. CloneVisitorGenerator has 6 outgoing dependencies (com.github.javaparser.metamodel.BaseNodeMetaModel; com.github.javaparser.ast.stmt.BlockStmt; com.github.javaparser.ast.CompilationUnit; com.github.javaparser.utils.SeparatedItemStringBuilder; com.github.javaparser.ast.body.MethodDeclaration; com.github.javaparser.utils.SourceRoot) and 0 incoming dependencies. Because there are no incoming dependencies, it does not qualify as a hub."
    },
    {
        "identifier": "com.github.javaparser.metamodel.LineCommentMetaModel",
        "detection": false,
        "justification": "LineCommentMetaModel has no outgoing dependencies (outgoing_dependencies is empty) and only two incoming dependencies: com.github.javaparser.ast.comments.LineComment and com.github.javaparser.metamodel.JavaParserMetaModel. Hub-like Modularization requires an abstraction to have both many incoming and many outgoing relationships; LineCommentMetaModel does not meet that criterion."
    },
    {
        "identifier": "com.github.javaparser.utils.SeparatedItemStringBuilder",
        "detection": false,
        "justification": "SeparatedItemStringBuilder has 6 incoming dependencies from: com.github.javaparser.ast.validator.language_level_validations.chunks.ModifierValidator, com.github.javaparser.generator.core.visitor.ModifierVisitorGenerator, com.github.javaparser.generator.core.visitor.HashCodeVisitorGenerator, com.github.javaparser.generator.core.visitor.NoCommentHashCodeVisitorGenerator, com.github.javaparser.generator.core.visitor.CloneVisitorGenerator, and com.github.javaparser.generator.core.node.MainConstructorGenerator, but it has 0 outgoing dependencies. Hub-like Modularization requires an abstraction to have many incoming AND many outgoing dependencies; because outgoing dependencies are absent, the hub-like modularization smell is not detected."
    },
    {
        "identifier": "com.github.javaparser.printer.concretesyntaxmodel.CsmString",
        "detection": false,
        "justification": "CsmString has outgoing dependencies to only three abstractions (com.github.javaparser.printer.SourcePrinter, com.github.javaparser.ast.observer.ObservableProperty, com.github.javaparser.ast.Node) and has no incoming dependencies. Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; these conditions are not met for CsmString. (Although some referenced classes like Node have many dependencies, the analysis is limited to CsmString in isolation.)"
    },
    {
        "identifier": "(default package).InnerClassFieldContainer.InnerClass",
        "detection": false,
        "justification": "No incoming or outgoing dependencies (incoming_dependencies = 0, outgoing_dependencies = 0), so the class does not have dependencies with a large number of other abstractions and is not a hub."
    },
    {
        "identifier": "foo.Main",
        "detection": false,
        "justification": "The class foo.Main has only one outgoing dependency (foo.Foo) and no incoming dependencies. Hub-like Modularization requires an abstraction to have many incoming and outgoing dependencies; the provided data (one outgoing, zero incoming) does not meet that condition."
    },
    {
        "identifier": "(default package).MavenWrapperDownloader",
        "detection": false,
        "justification": "Incoming dependencies: 0; Outgoing dependencies: 0. Hub-like Modularization requires an abstraction to have many incoming and outgoing dependencies; with zero incoming and zero outgoing dependencies this class is not a hub."
    },
    {
        "identifier": "com.github.javaparser.metamodel.TraditionalJavadocCommentMetaModel",
        "detection": false,
        "justification": "Outgoing dependencies = 0 (no outgoing references). Incoming dependencies = 2 (referenced by com.github.javaparser.ast.comments.TraditionalJavadocComment and com.github.javaparser.metamodel.JavaParserMetaModel). The class does not have both a large number of incoming and outgoing dependencies; it is only referenced by two classes, so it does not exhibit Hub-like Modularization."
    },
    {
        "identifier": "com.github.javaparser.ast.visitor.Visitable",
        "detection": false,
        "justification": "Visitable has only two outgoing dependencies (com.github.javaparser.ast.visitor.VoidVisitor and com.github.javaparser.ast.visitor.GenericVisitor) while it has incoming dependencies from seven classes (ModifierVisitor, ObjectIdentityEqualsVisitor, EqualsVisitor, NoCommentEqualsVisitor, CloneVisitor, PrettyPrintVisitor, DefaultPrettyPrinterVisitor). Hub-like Modularization requires an abstraction to have dependencies with a large number of other abstractions in both directions; here the outgoing degree is small (2), so Visitable is not a hub despite having multiple incoming dependents."
    },
    {
        "identifier": "com.github.javaparser.metamodel.EmptyStmtMetaModel",
        "detection": false,
        "justification": "Outgoing dependencies are empty (no outgoing links). Incoming dependencies are only two classes: com.github.javaparser.ast.stmt.EmptyStmt and com.github.javaparser.metamodel.JavaParserMetaModel. Hub-like Modularization requires an abstraction to have both many incoming and many outgoing dependencies; EmptyStmtMetaModel has neither a large number of incoming nor any outgoing dependencies. Note: although JavaParserMetaModel lists many dependencies, that only indicates one incoming connection to EmptyStmtMetaModel, not many bidirectional links."
    },
    {
        "identifier": "com.github.javaparser.ast.expr.LongLiteralExpr",
        "detection": true,
        "justification": "LongLiteralExpr has outgoing dependencies to 7 distinct abstractions (com.github.javaparser.ast.visitor.VoidVisitor, com.github.javaparser.Range, com.github.javaparser.metamodel.JavaParserMetaModel, com.github.javaparser.TokenRange, com.github.javaparser.metamodel.LongLiteralExprMetaModel, com.github.javaparser.ast.visitor.GenericVisitor, com.github.javaparser.utils.Utils) and receives incoming dependencies from 24 distinct classes across multiple subsystems (e.g. many ast.visitor classes such as VoidVisitor, GenericVisitor, EqualsVisitor, HashCodeVisitor, ModifierVisitor, CloneVisitor, NodeFinderVisitor, also symbolsolver classes like DefaultVisitorAdapter and TypeExtractor, parser/printer classes like GeneratedJavaParser, PrettyPrintVisitor, DefaultPrettyPrinterVisitor, and validators). The presence of numerous incoming connections combined with multiple outgoing links makes LongLiteralExpr a hub-like abstraction in the provided dependency set."
    },
    {
        "identifier": "com.github.javaparser.printer.lexicalpreservation.Difference.ArrayIterator",
        "detection": false,
        "justification": "Difference.ArrayIterator has 0 outgoing dependencies (none listed) and only 1 incoming dependency (from com.github.javaparser.printer.lexicalpreservation.Difference). Hub-like Modularization requires an abstraction to have many incoming and outgoing dependencies; these conditions are not met for this class."
    },
    {
        "identifier": "com.github.javaparser.ast.validator.language_level_validations.Java12Validator",
        "detection": false,
        "justification": "No incoming dependencies (incoming_dependencies = []) and no outgoing dependencies (outgoing_dependencies = []). Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; here both counts are zero, so the smell is not present."
    },
    {
        "identifier": "com.github.javaparser.metamodel.RecordDeclarationMetaModel",
        "detection": false,
        "justification": "RecordDeclarationMetaModel has a very small number of dependencies: only 1 outgoing dependency (com.github.javaparser.metamodel.PropertyMetaModel) and only 2 incoming dependencies (com.github.javaparser.ast.body.RecordDeclaration and com.github.javaparser.metamodel.JavaParserMetaModel). Hub-like modularization requires an abstraction to have incoming and outgoing ties with a large number of other abstractions; here both incoming and outgoing dependency counts are low, so this class is not a hub."
    },
    {
        "identifier": "(default package).Issue300.A",
        "detection": false,
        "justification": "The class has 0 incoming dependencies and 0 outgoing dependencies (incoming_dependencies and outgoing_dependencies are empty). Hub-like Modularization requires an abstraction to have a large number of both incoming and outgoing dependencies; with no dependencies this class cannot be a hub."
    },
    {
        "identifier": "com.github.javaparser.printer.lexicalpreservation.changes.NoChange",
        "detection": false,
        "justification": "NoChange has 3 incoming dependencies from classes in the same package: ListAdditionChange, ListRemovalChange, ListReplacementChange, and 2 outgoing dependencies: com.github.javaparser.ast.observer.ObservableProperty and com.github.javaparser.ast.Node. This yields a total of 5 connected abstractions, a small number of incoming/outgoing relationships, so it does not exhibit Hub-like Modularization."
    }
]