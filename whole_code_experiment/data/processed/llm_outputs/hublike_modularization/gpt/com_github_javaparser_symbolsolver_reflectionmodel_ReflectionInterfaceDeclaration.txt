{
    "class": "com.github.javaparser.symbolsolver.reflectionmodel.ReflectionInterfaceDeclaration",
    "detection": true,
    "justification": "ReflectionInterfaceDeclaration has a large number of both outgoing and incoming dependencies. Outgoing: it directly depends on many abstractions from multiple packages (TypeSolver field; uses ReflectionClassAdapter field; uses ReferenceTypeImpl, ResolvedType, ResolvedReferenceType, ResolvedMethodDeclaration, MethodUsage, InferenceContext, ConflictingGenericTypesException, SymbolReference, ResolvedFieldDeclaration, ResolvedTypeParameterDeclaration, AccessSpecifier, Context, etc.). It delegates logic to and calls into ReflectionMethodResolutionLogic (solveMethod, solveMethodAsUsage), ReflectionClassAdapter (getField, getAllFields, getDeclaredMethods, getAncestors, containerType, getTypeParameters, hasDirectlyAnnotation), ReflectionFactory (internalTypes, accessSpecifier), and constructs other reflection declarations (new ReflectionInterfaceDeclaration, ReflectionClassDeclaration, ReflectionFieldDeclaration). Incoming: it is constructed and referenced by multiple other modules (ReflectionFactory.typeDeclarationFor returns it; ReflectionClassAdapter.getInterfaces/getAncestors create/use it; ReflectionMethodResolutionLogic and ReflectionClassAdapter create instances of ReflectionInterfaceDeclaration/ReflectionClassDeclaration; SymbolSolver.classToResolvedType uses it). The class therefore acts as a central hub connecting many type-resolution, reflection and symbol-resolution abstractions across packages, indicating a hub-like modularization smell."
}