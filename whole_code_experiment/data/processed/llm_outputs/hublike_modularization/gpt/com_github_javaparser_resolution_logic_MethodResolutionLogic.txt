{
    "class": "com.github.javaparser.resolution.logic.MethodResolutionLogic",
    "detection": true,
    "justification": "MethodResolutionLogic exhibits Hub-like Modularization. It is a central static utility referenced from many other abstractions (high incoming coupling): e.g. ReflectionClassDeclaration, ReflectionRecordDeclaration, ReflectionMethodResolutionLogic, ReflectionClassDeclaration.solveMethod/similar, JavaParserFacade, TypeExtractor, LambdaExprContext, MethodReferenceExprContext, AnonymousClassDeclarationContext, MethodCallExprContext, CompilationUnitContext, JavassistUtils, ConstructorResolutionLogic and others call its methods (findMostApplicable, solveMethodInType, isApplicable, isMoreSpecific, getMethodsExplicitAndVariadicParameterType, findMostApplicableUsage, inferTypes, replaceTypeParam, etc.). At the same time it depends on a large set of abstractions across packages (high outgoing coupling): ResolvedType/ResolvedReferenceType/ResolvedArrayType/ResolvedTypeVariable/ResolvedWildcard/ResolvedPrimitiveType, ResolvedMethodDeclaration, MethodUsage, TypeSolver, ResolvedTypeParameterDeclaration, SymbolReference, LambdaArgumentTypePlaceholder, ReferenceTypeImpl, FunctionalInterfaceLogic, etc. The class is large and provides many responsibilities around method/constructor resolution, making it a single concentrated hub used and relied upon by numerous modules â€” matching the Hub-like Modularization smell."
}