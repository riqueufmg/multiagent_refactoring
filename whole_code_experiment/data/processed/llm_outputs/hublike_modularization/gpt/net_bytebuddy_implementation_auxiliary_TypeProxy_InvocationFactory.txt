{
    "class": "net.bytebuddy.implementation.auxiliary.TypeProxy",
    "detection": true,
    "justification": "TypeProxy interacts with a large number of other abstractions (both outgoing and incoming). Outgoing dependencies: imports and usages include net.bytebuddy.ByteBuddy (make()), ClassFileVersion, net.bytebuddy.description.type.TypeDescription (field proxiedType, many uses), Implementation and Implementation.Target (fields and parameter types), MethodAccessorFactory (constructor param, used in MethodCall), ByteCodeAppender, many bytecode utilities (TypeCreation, Duplication, DefaultValue, FieldAccess, MethodInvocation, MethodReturn, MethodVariableAccess, StackManipulation, Throw), net.bytebuddy.dynamic.DynamicType/TargetType, InstrumentedType/TypeValidation, net.bytebuddy.matcher.ElementMatchers, org.objectweb.asm.MethodVisitor and Opcodes, java.io.Serializable and RandomString. These appear throughout methods and nested types (e.g., make(), SilentConstruction.Appender, MethodCall.Appender). Incoming dependencies: TypeProxy is used/registered as an AuxiliaryType by implementation contexts (e.g., ForSuperMethodByConstructor.apply: implementationContext.register(new TypeProxy(...)); ForSuperMethodByReflectionFactory.apply and ForDefaultMethod.apply perform the same registration), and it implements AuxiliaryType which is consumed by Implementation.Context.Default.register and related context code paths. The class therefore has many incoming registrations/usages as an auxiliary type and many outgoing references to diverse subsystems (implementation target, bytecode generation, ASM, utilities), making it a hub-like abstraction."
}