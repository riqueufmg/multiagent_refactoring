{
    "class": "net.bytebuddy.dynamic.ClassFileLocator.Compound",
    "detection": true,
    "justification": "Compound acts as a central hub: it is constructed by multiple factory methods across the codebase (e.g. ForJarFile.ofClassPath(...) -> \"return new Compound(classFileLocators);\", ForModuleFile.ofBootPath(...) -> \"return new Compound(classFileLocators);\", ForModuleFile.ofModulePath(...) -> \"return new Compound(classFileLocators);\"), showing many incoming dependencies. Compound also has outgoing dependencies to many other ClassFileLocator implementations: its constructor flattens/inspects arbitrary ClassFileLocator instances (code: \"if (classFileLocator instanceof Compound) { this.classFileLocators.addAll(((Compound) classFileLocator).classFileLocators); } else if (!(classFileLocator instanceof NoOp)) { this.classFileLocators.add(classFileLocator); }\") and its locate/close methods iterate over and delegate to each locator (code: \"for (ClassFileLocator classFileLocator : classFileLocators) { Resolution resolution = classFileLocator.locate(name); ... }\" and \"for (ClassFileLocator classFileLocator : classFileLocators) { classFileLocator.close(); }\"). These many incoming creators and outgoing delegations to many different locator abstractions constitute a hub-like modularization smell."
}