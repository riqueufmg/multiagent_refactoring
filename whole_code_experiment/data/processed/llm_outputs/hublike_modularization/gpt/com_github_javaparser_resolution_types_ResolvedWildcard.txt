{
    "class": "com.github.javaparser.resolution.types.ResolvedWildcard",
    "detection": true,
    "justification": "ResolvedWildcard acts as a central hub: many unrelated subsystems both depend on it (incoming) and it depends on multiple abstractions (outgoing). Incoming: referenced heavily by ReflectionFactory.typeUsageFor (constructing wildcards from java.lang.reflect.WildcardType), MethodCallExprContext.resolveMethodAsUsage (handling wildcard cases), LeastUpperBoundLogic (lcta, lcp and bound computations), TypeHelper (proper type checks, glb/lub logic), MethodResolutionLogic (type parameter substitution and applicability), InferenceContext / InferenceVariableType (inference and registration of equivalent types), WildcardType (AST-to-resolved conversion), JavassistUtils and other resolution utilities. Outgoing: ResolvedWildcard implements/uses ResolvedType and ResolvedType methods (isAssignableBy, replaceTypeVariables, erasure, solveGenericTypes), takes Context in solveGenericTypes, uses ResolvedTypeParameterDeclaration in replaceTypeVariables, and relies on collections (List/Map) and the BoundType enum. Its API (getBoundedType, isSuper/isExtends/isBounded/describe/erasure/replaceTypeVariables/solveGenericTypes) is central to many algorithms across the codebase. The high number of distinct callers across type resolution, inference, method resolution and reflection/model layers plus its multiple dependencies indicates a hub-like modularization smell."
}