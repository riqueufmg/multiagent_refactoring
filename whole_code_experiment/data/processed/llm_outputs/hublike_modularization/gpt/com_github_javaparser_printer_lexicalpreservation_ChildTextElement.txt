{
    "class": "com.github.javaparser.printer.lexicalpreservation.ChildTextElement",
    "detection": true,
    "justification": "ChildTextElement acts as a central glue/wrapper between many abstractions: outgoing dependencies include com.github.javaparser.ast.Node (field 'child' and many delegations: getChild(), getRange(), isNode(...), isComment() / instanceof Comment, isChildOfClass(...)), com.github.javaparser.printer.lexicalpreservation.LexicalPreservingPrinter (expand() -> LexicalPreservingPrinter.print(child), getNodeTextForWrappedNode() -> LexicalPreservingPrinter.getOrCreateNodeText(child)), com.github.javaparser.printer.lexicalpreservation.NodeText (used via getNodeTextForWrappedNode and by returning/producing ChildTextElement instances), and com.github.javaparser.printer.lexicalpreservation.LexicalPreservingVisitor (accept(visitor) iterates wrapped NodeText elements and forwards visitor.accept). Incoming dependencies (many classes construct/use ChildTextElement and inspect it): NodeText.addChild / addChild(index) creates new ChildTextElement(child); LexicalPreservingPrinter.storeInitialTextForOneNode builds Pair<Range, TextElement> with new ChildTextElement(child); DifferenceElementCalculator, Difference, TextElementIteratorsFactory and Observer code repeatedly cast/filter TextElement -> ChildTextElement (e.g. selectMatchingChildElements, findChildTextElementForComment, considerRemoval, reverseIterator) and rely on its methods (getChild(), getNodeTextForWrappedNode(), isComment(), matchByRange usage). Multiple unrelated components (LexicalPreservingPrinter, NodeText, Difference/DifferenceElementCalculator, TextElementIteratorsFactory, Observer, LexicalPreservingVisitor) both depend on and are depended-on by ChildTextElement. This high number of incoming and outgoing dependencies across distinct subsystems identifies ChildTextElement as a hub-like abstraction."
}