{
    "class": "org.apache.commons.io.function.Uncheck",
    "detection": true,
    "justification": "Uncheck is acting as a central hub: many other abstractions across the codebase both call into it (incoming) and it accepts/uses many different functional abstractions (outgoing). Examples of incoming dependencies: IOConsumer.asConsumer() -> Uncheck.accept, IOFunction.asFunction() -> Uncheck.apply, IOComparator.asComparator() -> Uncheck.compare, IOSupplier.getUnchecked() -> Uncheck.get, IOIntSupplier.asIntSupplier() -> Uncheck.getAsInt, IOBooleanSupplier.asBooleanSupplier() -> Uncheck.getAsBoolean, IOBiConsumer.asBiConsumer() -> Uncheck.accept, IOBiFunction.asBiFunction() -> Uncheck.apply, IORunnable.asRunnable() -> Uncheck.run, UncheckedIOIterator (uses Uncheck.get / getAsBoolean / run), UncheckedBufferedReader/UncheckedFilterReader/UncheckedFilterInputStream/UncheckedFilterWriter/UncheckedFilterOutputStream (many overrides delegate to Uncheck), and large utility users like FileUtils (multiple calls: Uncheck.apply, Uncheck.getAsBoolean, Uncheck.get, Uncheck.getAsLong, etc.). Examples of outgoing dependencies: Uncheck methods take/handle many different IO functional interfaces as parameters (IOConsumer, IOBiConsumer, IOIntConsumer, IOTriConsumer, IOBiFunction, IOFunction, IOQuadFunction, IOTriFunction, IOComparator, IOSupplier, IOIntSupplier, IOLongSupplier, IOBooleanSupplier, IORunnable, IOPredicate). Because it connects a large number of distinct abstractions across packages and is heavily referenced, it exhibits Hub-like Modularization (high coupling through a central utility)."
}