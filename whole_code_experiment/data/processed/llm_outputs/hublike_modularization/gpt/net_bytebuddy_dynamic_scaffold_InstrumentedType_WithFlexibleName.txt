{
    "class": "net.bytebuddy.dynamic.scaffold.InstrumentedType.WithFlexibleName",
    "detection": true,
    "justification": "InstrumentedType.WithFlexibleName (and its enclosing InstrumentedType) depends on a very large number of other abstractions and serves as a central hub. Evidence of high outgoing dependencies: its API methods reference many types (ModuleDescription, FieldDescription.Token, MethodDescription.Token, RecordComponentDescription.Token, TypeList.Generic, TypeVariableToken, AnnotationDescription, LoadedTypeInitializer, ByteCodeAppender, TypeDescription, MethodDescription.InDefinedShape, RecordComponentDescription, TargetType, Transformer, ElementMatcher, ParameterDescription, etc.). The Default implementation declares many fields and constructor parameters referencing dozens of abstractions (Generic, TypeDescription, TypeList, FieldDescription.Token, MethodDescription.Token, RecordComponentDescription.Token, AnnotationDescription, TypeInitializer, LoadedTypeInitializer, TypeVariableToken, ModuleDescription, etc.). It repeatedly composes and transforms tokens via Generic.Visitor.Substitutor.ForDetachment.of(this) showing tight coupling with type/token abstractions. Evidence of incoming hub behavior: Factory.Default.represent/subclass produce or return InstrumentedType instances and many other core descriptor classes (FieldDescription, MethodDescription, RecordComponentDescription, TypeList) interact with InstrumentedType tokens/visitors to attach/detach types. The concentration of many incoming/outgoing relationships across core description and token types indicates a hub-like modularization smell."
}