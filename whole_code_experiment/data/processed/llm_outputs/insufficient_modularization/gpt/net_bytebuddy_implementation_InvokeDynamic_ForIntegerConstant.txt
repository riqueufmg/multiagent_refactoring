{
    "smell": "Insufficient Modularization",
    "class": "net.bytebuddy.implementation.InvokeDynamic",
    "detection": true,
    "justification": "The InvokeDynamic class is very large and combines many distinct responsibilities that should be modularized: it defines the high-level DSL and factory methods (bootstrap, lambda, many withXxx methods), bytecode emission (inner Appender), invocation-target resolution (InvocationProvider and InvocationProvider.Default.Target), argument provisioning (InvocationProvider.ArgumentProvider and a large family of implementations: ForInterceptedMethodInstanceAndParameters, ForInterceptedMethodParameters, ConstantPoolWrapper and its WrappingArgumentProvider, ForThisInstance, ForInstance, ForField and WithExplicitType, ForMethodParameter and WithExplicitType, ForBooleanConstant, ForByteConstant, ForShortConstant, ForCharacterConstant, ForIntegerConstant, ForLongConstant, ForFloatConstant, ForDoubleConstant, ForStringConstant, ForClassConstant, ForEnumerationValue, ForNullValue, ForJavaConstant), name/return-type providers (NameProvider, ReturnTypeProvider), termination handling (TerminationHandler), and multiple configuration/delegation variants (AbstractDelegator, WithImplicitArguments, WithImplicitTarget, WithImplicitType and its OfInstance/OfArgument/OfField). This concentration of responsibilities, many nested types, and repeated patterns (numerous withXxx builders and constant-handling classes) indicate the class has not been adequately decomposed and would be easier to understand, test, and maintain if split into smaller, cohesive classes (e.g., separate argument-provider classes, invocation provider implementations, and bytecode appender)."
}