{
    "smell": "Insufficient Modularization",
    "class": "AnnotationValue",
    "detection": true,
    "justification": "The AnnotationValue type is very large and bundles many distinct responsibilities into a single top-level abstraction: it defines core API (AnnotationValue, State, Sort), platform-specific rendering logic (RenderingDispatcher with multiple VM variants), loading semantics (AnnotationValue.Loaded and many Loaded.* implementations), multiple concrete value representations (ForConstant, ForAnnotationDescription, ForEnumerationDescription, ForTypeDescription, ForDescriptionArray, ForMissingType, ForMismatchedType, ForMissingValue, ForIncompatibleType) and internal helpers (ForConstant.PropertyDelegate and its nested enums ForNonArrayType/ForArrayType). Examples of cross-cutting concerns: rendering behavior and VM-specific formatting is mixed into the same file (RenderingDispatcher and its variants); class-loading/error mapping logic (numerous load(...) implementations using Class.forName and mapping to specific loaded subclasses) is interleaved with representation and equality/hashCode implementations; array handling and property-copy/hash/equals logic are embedded inside nested enums (ForArrayType). The result is a single monolithic type with many nested classes, long factory methods (many ForConstant.of overloads and static factories for arrays/descriptions), and duplicated patterns scattered across nested types. This concentration of responsibilities makes the code harder to understand, test, and maintain and indicates it would benefit from decomposition (e.g. separate files/modules for rendering, loading, value-kind implementations, and property delegates)."
}