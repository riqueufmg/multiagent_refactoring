{
    "smell": "Insufficient Modularization",
    "class": "VoidVisitor",
    "detection": true,
    "justification": "The VoidVisitor interface centralizes a very large surface of responsibilities into a single type: it declares dozens of visit(...) methods that cover nearly every AST node category (expressions: ArrayAccessExpr, BinaryExpr, MethodCallExpr, LambdaExpr, etc.; statements: IfStmt, ForStmt, WhileStmt, SwitchStmt, ReturnStmt, TryStmt, etc.; declarations: ClassOrInterfaceDeclaration, MethodDeclaration, EnumDeclaration, AnnotationDeclaration, RecordDeclaration, etc.; types: ArrayType, PrimitiveType, UnionType, IntersectionType, VarType, UnknownType, etc.; comments: BlockComment, LineComment, MarkdownComment, TraditionalJavadocComment; modules/directives: ModuleDeclaration, ModuleRequiresDirective, ModuleExportsDirective, etc.; patterns and new constructs: RecordPatternExpr, TypePatternExpr, MatchAllPatternExpr, TextBlockLiteralExpr, SwitchExpr, YieldStmt, etc.). Because one interface must provide methods for many unrelated node kinds, implementers are forced to depend on and potentially implement a bloated API even when only a small subset is needed. This concentration of many separate concerns in one abstraction makes the API large, hard to understand and maintain, and indicates insufficient decomposition/modularization of visitor responsibilities."
}