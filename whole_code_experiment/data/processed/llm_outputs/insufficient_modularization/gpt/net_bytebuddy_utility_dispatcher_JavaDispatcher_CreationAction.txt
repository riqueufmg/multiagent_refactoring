{
    "smell": "Insufficient Modularization",
    "class": "JavaDispatcher",
    "detection": true,
    "justification": "The JavaDispatcher class concentrates many distinct responsibilities and is very large and complex: (1) Core dispatcher factory and resolution logic in run() (security checks, proxy selection, reflection-based method resolution and many branching conditions). (2) Definition of several nested annotation types (Proxied, IsStatic, IsConstructor, Instance, Container, Defaults) that could be separate. (3) A large Dispatcher interface with many concrete implementations (ForInstanceCheck, ForContainerCreation, ForDefaultValue and its nested enums/classes, ForConstructor, ForStaticMethod, ForNonStaticMethod, ForUnresolvedMethod) embedding invocation logic, bytecode emission logic (apply methods) and default-value handling. (4) Proxy invocation handling in ProxiedInvocationHandler. (5) A heavy DynamicClassLoader nested class that itself implements bytecode generation (proxy and invoker methods using ASM), dumping, class definition, and a Resolver subsystem for module adjustments including ForModuleSystem and NoOp. (6) Static creation and caching concerns (GENERATE, RESOLVER, INVOKER, InvokerCreationAction, DirectInvoker). These multiple orthogonal concerns (security, reflection/resolution, proxy creation, bytecode generation, class loading/module adjustment, invocation handling, default value semantics) are all implemented in one class rather than split into cohesive, focused modules. The size, nested types, and mixed responsibilities indicate insufficient modularization and a need to extract components (e.g., bytecode generation, dynamic class loader/resolver, dispatcher implementations, invocation handler and annotations) to reduce complexity and improve cohesion."
}