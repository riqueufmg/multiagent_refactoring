{
    "smell": "Insufficient Modularization",
    "class": ["VoidVisitorAdapter"],
    "detection": true,
    "justification": [
        "The class is very large and contains a separate visit(...) method for a very large number of AST node types (e.g., AnnotationDeclaration, ClassOrInterfaceDeclaration, MethodDeclaration, IfStmt, ForStmt, TryStmt, many LiteralExpr, Module* directives, RecordDeclaration, etc.). This centralizes the handling of many distinct node categories in one class instead of decomposing them into smaller, cohesive abstractions.\n\nMultiple indications of insufficient modularization:\n- Repetition of the same patterns across many methods (for example, almost every visit method ends with n.getComment().ifPresent(l -> l.accept(this, arg)); and many methods repeatedly call similar sequences of getX().forEach(...accept(this,...))). This suggests extractable common behavior (visit children, visit comments) that is implemented redundantly rather than delegated to helpers or split across focused classes.\n- High responsibility count: the adapter implements default visitation for expressions, statements, types, declarations, module directives, comments, patterns, etc., so it mixes concerns that could be grouped (e.g., separate visitors or helper delegates for expressions, statements, declarations, modules/comments).\n- Maintenance and evolution risk: because all node-type defaults live in one monolithic class, adding new node types or changing traversal strategy requires modifying this large class, increasing coupling and reducing readability.\n\nRefactoring opportunities that support the detection: factor out shared child-iteration/comment-handling logic into utility methods or delegate per-category visit implementations (expression visitor, statement visitor, declaration visitor, module visitor), or compose smaller adapters to reduce the class size and responsibilities."
    ]
}