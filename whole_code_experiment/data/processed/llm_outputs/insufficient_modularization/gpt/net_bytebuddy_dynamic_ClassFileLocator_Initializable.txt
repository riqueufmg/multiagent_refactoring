{
    "smell": "Insufficient Modularization",
    "class": ["net.bytebuddy.dynamic.ClassFileLocator"],
    "detection": true,
    "justification": [
        "The interface groups a very large number of concrete implementations and nested types that cover many distinct responsibilities: resource lookup via ClassLoader (ForClassLoader, ForUrl, WeaklyReferenced), file-system and archive reading (ForFolder, ForJarFile, ForModuleFile), Java module handling (ForModule, ForModule.WeaklyReferenced, boot layer resolution), instrumentation-based extraction (ForInstrumentation and its ExtractionClassFileTransformer), composition and filtering utilities (Compound, Filtering, PackageDiscriminating), simple in-memory maps (Simple), and multi-release jar semantics (MultiReleaseAware).",
        "Many nested classes contain complex, independent logic (e.g. ForInstrumentation uses JavaDispatcher, reflection, and an Instrumentation-based retransformation flow; ForJarFile and ForModuleFile perform Zip/Jar/Manifest scanning; ForFolder handles manifest parsing and multi-release folder discovery). These are distinct concerns (I/O/zip handling, module API, instrumentation, security/privileged actions, class-loading delegation) that increase the single file's size and complexity.",
        "Numerous factory methods and helper enums/classes are defined inside the same top-level type (multiple static factory methods across many nested classes, BootLoaderProxyCreationAction, ClassLoaderCreationAction, Dispatcher proxies, ClassLoadingDelegate subtypes), indicating a bloated interface file that would be easier to understand and maintain if decomposed into separate classes or packages.",
        "The combined responsibilities reduce cohesion: the top-level type mixes low-level I/O/zip logic, JVM-module and classloader intricacies, and agent/instrumentation behavior instead of delegating these to separate, focused modules. This meets the criteria for insufficient modularization."
    ]
}