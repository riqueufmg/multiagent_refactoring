{
    "smell": "Insufficient Modularization",
    "class": "net.bytebuddy.asm.MemberSubstitution",
    "detection": true,
    "justification": "The MemberSubstitution class is extremely large and aggregates many distinct responsibilities that should be separate modules. Evidence: (1) It defines numerous nested types covering unrelated roles: TypePoolResolver, Target, Substitution (with many nested classes and enums), Replacement (with many nested classes and factories), Substitution.Chain and its Step implementations, Dispatcher and BootstrapArgumentResolver, OffsetMapping and many variants, Replacement factories, and an extensive SubstitutingMethodVisitor. (2) It also declares many annotation types (This, Argument, AllArguments, SelfCallHandle, Handle, DynamicConstant, FieldValue, FieldGetterHandle, FieldSetterHandle, Origin, Unused, StubValue, Current) and a Source enum â€” mixing API annotations with core implementation. (3) Several methods are very large and complex (e.g., visitMethodInsn, visitFieldInsn, visitInvokeDynamicInsn, resolve/Chain.resolve logic), indicating multiple responsibilities (byte-code visiting, member resolution, substitution chaining, delegation dispatching, bootstrap argument resolution, offset mapping). (4) Many factory and resolver classes are implemented as inner classes rather than separate cohesive classes, increasing coupling and decreasing clarity. Together these factors show the class is insufficiently modularized and would benefit from splitting into smaller, focused classes/modules."
}