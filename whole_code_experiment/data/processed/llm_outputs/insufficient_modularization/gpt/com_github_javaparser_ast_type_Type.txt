{
    "smell": "Insufficient Modularization",
    "class": ["Type"],
    "detection": true,
    "justification": "The Type class exposes a very large, mixed interface and concentrates multiple responsibilities that could be separated. Evidence in the class: (1) Annotation management (field 'annotations', getAnnotations(), setAnnotations(...), getAnnotation(int), remove(Node), replace(Node,Node)) mixes AST node containment logic into the base type. (2) Many subtype inspection and casting helpers (isArrayType(), asArrayType(), isClassOrInterfaceType(), asClassOrInterfaceType(), isPrimitiveType(), asPrimitiveType(), isReferenceType(), asReferenceType(), isTypeParameter(), asTypeParameter(), isUnionType(), asUnionType(), isUnknownType(), asUnknownType(), isVoidType(), asVoidType(), isWildcardType(), asWildcardType(), isVarType(), asVarType()) and their corresponding ifXxx(Consumer), toXxx() Optional methods â€” this adds a large, repetitive API surface to the base class for every concrete subtype. (3) Core semantics and utilities are combined here (getElementType(), getArrayLevel(), toDescriptor(), asString(), clone(), getMetaModel(), resolve()) so the class mixes representation, casting utilities, cloning, meta-model access and resolution. (4) Many methods are generated (TypeCastingGenerator etc.), indicating the base class is a catch-all for behavior across many concrete Type variants. These factors produce a bloated, multi-responsibility abstraction that is harder to understand and maintain and would be more modular if subtype-specific behavior and casting utilities were moved out (e.g., into visitors, helper classes, or per-subtype abstractions)."
}