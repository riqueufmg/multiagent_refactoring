{
    "smell": "Insufficient Modularization",
    "class": "net.bytebuddy.asm.MemberSubstitution",
    "detection": true,
    "justification": "The MemberSubstitution class is excessively large and bundles many distinct responsibilities and subcomponents into a single top-level type. Evidence: (1) The class declares numerous major inner types and subsystems (TypePoolResolver and its implementations, Target and its subclasses, Substitution and many implementations and factories, Substitution.Chain and many Step implementations, Replacement and many Replacement.Factory implementations, Dispatcher and BootstrapArgumentResolver and many nested classes). (2) It contains a complex method visitor implementation (SubstitutingMethodVisitor) with large methods (visitFieldInsn, visitMethodInsn, visitInvokeDynamicInsn, visitMaxs) that handle resolution, binding and byte-code generation â€” showing mixing of parsing, resolution, and code emission concerns. (3) Many nested annotations and offset-mapping systems (ForDelegation, OffsetMapping and many OffsetMapping.Factory/Resolved classes) increase surface area and indicate multiple separate domains implemented inside one class. (4) Repeated factory classes, enums and long switch/case logic indicate high internal complexity and low cohesion: e.g. Replacement.ForElementMatchers.Factory, Replacement.ForDynamicInvocation.Factory, Substitution.Chain.Factory and numerous Step.Factory implementations. (5) This concentration of functionality (matching, resolving, substitution chain building, delegation, bootstrap argument resolution, local variable tracing, stack size adjustment, and many annotation-based binding behaviors) violates single-responsibility and would be easier to maintain if split into smaller, focused classes/modules. These facts justify that the class exhibits Insufficient Modularization."
}